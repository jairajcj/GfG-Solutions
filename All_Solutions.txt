================================================================================
Date: 2023-03-24
Problem: RemoveAndReverse
Filename: 2023-03-24_RemoveAndReverse.py
================================================================================

class Solution:
    def removeReverse(self, s):
        n = len(s)
        i = 0
        j = n - 1
        mp = {}
        for char in s:
            if char in mp:
                mp[char] += 1
            else:
                mp[char] = 1
        flag = True 
        while i <= j:
            if flag:
                if mp[s[i]] > 1:
                    mp[s[i]] -= 1
                    s = s[:i] + '0' + s[i+1:]
                    flag = False
                i += 1
            else:
                if mp[s[j]] > 1:
                    mp[s[j]] -= 1
                    s = s[:j] + '0' + s[j+1:]
                    flag = True
                j -= 1
        ans = ""
        for char in s:
            if char != '0':
                ans += char
        if flag:
            return ans
        else:
            return ans[::-1]

================================================================================
Date: 2023-03-25
Problem: RedundantParanthesis
Filename: 2023-03-25_RedundantParanthesis.py
================================================================================

class Solution:
    def removeBrackets(self, Exp):
        s = list(Exp)
        n = len(Exp)

        ans = [1] * (n+1)
        lasta = [-1] * (n+1)
        nxta = [-1] * (n+1)

        # last[i] = last op explored before index i ,
        l = -1
        for i in range(n):
            lasta[i] = l
            if s[i] in ['*', '+', '-', '/']:
                l = s[i]
        # nxta[i] = next operator explored after index i
        l = -1
        for i in range(n-1, -1, -1):
            nxta[i] = l
            if s[i] in ['*', '+', '-', '/']:
                l = s[i]

        st = []
        sign = [-1] * 256 # index of last occ of operators in exp
        mp = [0] * 256 # stores whether an op is present in sub_expresssion
        operand = ['*', '+', '-', '/']

        for p in range(n):
            for x in operand:
                if x == s[p]: # string the operators index if present
                    sign[ord(x)] = p
            if s[p] == '(':
                st.append(p)
            elif s[p] == ')':
                i = st.pop()
                j = p

                nxt = nxta[j]
                last = lasta[i]

                for x in operand:
                    if sign[ord(x)] >= i:
                        mp[ord(x)] = 1
                ok = 0

                # the sub exp we are comparing, checking if it has redundant braces
                if i > 0 and j+1 < n and s[i-1] == '(' and s[j+1] == ')':
                    ok = 1
                if mp[ord('+')] == 0 and mp[ord('*')] == 0 and mp[ord('-')] == 0 and mp[ord('/')] == 0: # no operators are present in b/w sub exp
                    ok = 1
                if last == -1 and nxt == -1: # if no opeators before i and after j
                    ok = 1
                if last == '/':
                    pass
                elif last == '-' and (mp[ord('+')] == 1 or mp[ord('-')] == 1):
                    pass
                elif mp[ord('-')] == 0 and mp[ord('+')] == 0:
                    ok = 1
                else:
                    if (last == -1 or last == '+' or last == '-') and (nxt == -1 or nxt == '+' or nxt == '-'):
                        ok = 1
                if ok == 1: # not req paranthese
                    ans[i] = 0 # not req ch
                    ans[j] = 0
        res = ""
        for i in range(n):
            if ans[i] > 0:
                res += s[i]
        return res

================================================================================
Date: 2023-03-27
Problem: DivideInIncrementalGroups
Filename: 2023-03-27_DivideInIncrementalGroups.py
================================================================================

class Solution:
    def countWaystoDivide(self, N, K):
        dp = [[0 for _ in range(K+1)] for _ in range(N+1)]
        for i in range(1, N+1):
            for j in range(1, K+1):
                if i < j:
                    dp[i][j] = 0
                elif j == 1:
                    dp[i][j] = 1
                else:
                    dp[i][j] = dp[i-1][j-1] + dp[i-j][j]
        return dp[N][K]

================================================================================
Date: 2023-03-28
Problem: ShyGeek
Filename: 2023-03-28_ShyGeek.py
================================================================================

class Solution:
    def __init__(self, s):
        self.shop = s
    
    def find(self, n, k):
        cnt = 0
        s = 0
        e = n
        ans = None
        
        while k:
            ans = -1
            s = 0
            while s < e:
                mid = (s + e) // 2
                choc = self.shop.get(mid)
                if choc == -1:
                    ans = -1
                if choc > k:
                    e = mid
                else:
                    ans = choc
                    s = mid + 1
            
            if ans == -1:
                break
            
            cnt += k // ans
            k = k % ans
        
        return cnt

================================================================================
Date: 2023-03-29
Problem: CountSubStrings
Filename: 2023-03-29_CountSubStrings.py
================================================================================

class Solution:
    def countSubstring(self, S): 
        cnt=0
        for i in range(len(S)):
            l=0
            u=0
            for j in range(i,len(S)):
                if(S[j]>='a' and S[j]<='z'):
                    l+=1
                else:
                    u+=1
                    
                if(l==u):
                    cnt+=1
                    
        return cnt


================================================================================
Date: 2023-03-30
Problem: MininumInteger
Filename: 2023-03-30_MininumInteger.py
================================================================================

from typing import List


class Solution:
    def minimumInteger(self, N : int, A : List[int]) -> int:
        S = sum(A)
        minNum=float('inf')
        
        for X in A:
            if(S<=N*X and X < minNum):
                minNum=X
        return minNum


================================================================================
Date: 2023-03-31
Problem: EvenSwap
Filename: 2023-03-31_EvenSwap.py
================================================================================

class Solution():
    def lexicographicallyLargest(self, a, n):
        i = 0
 
        while i < n:
            j = i + 1
            while j < n and a[j] % 2 == a[j - 1] % 2:
                j += 1
                
            a[i:j] = sorted(a[i:j], reverse=True)
            i = j
        
        return a

================================================================================
Date: 2023-04-01
Problem: MakeArrayElementsEqual
Filename: 2023-04-01_MakeArrayElementsEqual.py
================================================================================

class Solution:
    def minOperations(self, N):
        return (N**2//4)


================================================================================
Date: 2023-04-02
Problem: KnightInGeekland
Filename: 2023-04-02_KnightInGeekland.py
================================================================================

from collections import deque

class Solution:
    def knightInGeekland(self, arr, start):
        n = len(arr)
        m = len(arr[0])
        
        dx = [-1, -2, -2, -1, 1, 2, 2, 1]
        dy = [-2, -1, 1, 2, 2, 1, -1, -2]

        visited = [[False]*m for _ in range(n)]
        queue = deque()
        queue.append((start[0], start[1]))
        visited[start[0]][start[1]] = True
        points = [0]*1001
        steps = 0

        while queue:
            qSize = len(queue)
            for i in range(qSize):
                x, y = queue.popleft()
                points[steps] += arr[x][y]
                for k in range(8):
                    currX = x + dx[k]
                    currY = y + dy[k]
                    if currX < 0 or currY < 0 or currX >= n or currY >= m or visited[currX][currY]:
                        continue
                    visited[currX][currY] = True
                    queue.append((currX, currY))
            steps += 1
    
        ans = 0
        maxi = float('-inf')
        for i in range(1001):
            curr = i
            totalpoints = 0
            while curr <= 1000:
                if points[curr] == 0:
                    break
                totalpoints += points[curr]
                curr += points[curr]
            points[i] = totalpoints
            if points[i] > maxi:
                maxi = points[i]
                ans = i
        
        return ans

================================================================================
Date: 2023-04-03
Problem: RODBy11
Filename: 2023-04-03_RODBy11.py
================================================================================

class Solution:
    def xmod11(self,x):
        return int(x)%11

================================================================================
Date: 2023-04-04
Problem: MinStepsRequired
Filename: 2023-04-04_MinStepsRequired.py
================================================================================

class Solution:
    def minSteps(self, str : str) -> int:
        a = 0
        b = 0
        
        if str[0] == 'a':
            a += 1
        else:
            b += 1
        
        for i in range(1, len(str)):
            if str[i-1] == 'a' and str[i] == 'b':
                b += 1
            
            if str[i-1] == 'b' and str[i] == 'a':
                a += 1
        
        return min(a, b) + 1


================================================================================
Date: 2023-04-05
Problem: CountSpecialNum
Filename: 2023-04-05_CountSpecialNum.py
================================================================================

class Solution:
    def countSpecialNumbers(self, N, arr):
        freq = {}
        uniq = set()
        maximum = 0

        for i in range(N):
            freq[arr[i]] = freq.get(arr[i], 0) + 1
            uniq.add(arr[i])
            maximum = max(maximum, arr[i])

        special = set()
        for z in uniq:
            for i in range(2 * z, maximum+1, z):
                if i in uniq:
                    special.add(i)

        ans = 0
        for x in freq.items():
            if x[1] > 1:
                ans += x[1]
            elif x[0] in special:
                ans += 1
        
        return ans

================================================================================
Date: 2023-04-06
Problem: EQLeftNRightSubArr
Filename: 2023-04-06_EQLeftNRightSubArr.py
================================================================================

class Solution:
    def equalSum(self,A, N):
        sum = 0
        for num in A:
            sum += num
        ans = -1
        left_sum = A[0]
        sum -= A[0]
        if sum == 0:
            return 1
        for i in range(1, N - 1):
            sum -= A[i]
            if left_sum == sum:
                ans = i + 1
                break
            left_sum += A[i]
        return ans

================================================================================
Date: 2023-04-07
Problem: AddMinChars
Filename: 2023-04-07_AddMinChars.py
================================================================================

class Solution:
    def LPS(self, str):
        n = len(str)
        lps = [0] * n
        i = 1
        length = 0
        lps[0] = 0
        while i < n:
            if str[i] == str[length]:
                length += 1
                lps[i] = length
                i += 1
            else:
                if length == 0:
                    lps[i] = 0
                    i += 1
                else:
                    length = lps[length - 1]
        return lps
    
    def addMinChar (self, str1):
        orig = list(str1)
        temp = list(str1)
        temp.reverse()
        s = "".join(orig) + '#' + "".join(temp)
        n = len(s)
        lps = self.LPS(s)
        return len(str1) - lps[n-1]

================================================================================
Date: 2023-04-08
Problem: MakeTheArrayBeautiful
Filename: 2023-04-08_MakeTheArrayBeautiful.py
================================================================================

from typing import List

class Solution:
    def makeBeautiful(self, arr: List[int]) -> List[int]:
        n = len(arr)
        lst = []
        for i in range(n):
            if len(lst) != 0 and ((lst[-1] < 0 and arr[i] >= 0) or (lst[-1] >= 0 and arr[i] < 0)):
                lst.pop()
            else:
                lst.append(arr[i])
        return lst


================================================================================
Date: 2023-04-09
Problem: SpecialDigit
Filename: 2023-04-09_SpecialDigit.py
================================================================================

mod = 10**9 + 7
hogya = False
factorial = [0] * 100001
mm = [0] * 100001

class Solution:
    def help(self):
        factorial[0] = 1
        for i in range(1, 100001):
            factorial[i] = (i * factorial[i-1]) % mod
        mm[100000] = self.power(factorial[100000], mod - 2)
        for i in range(99999, -1, -1):
            mm[i] = (mm[i+1] * (i+1)) % mod

    def power(self, x, y):
        res = 1
        x = x % mod
        while y > 0:
            if y & 1:
                res = (res * x) % mod
            y = y >> 1
            x = (x * x) % mod
        return res

    def help2(self, n, r):
        return (factorial[n] * mm[r] % mod * mm[n - r] % mod) % mod

    def bestNumbers(self, N, A, B, C, D):
        global hogya
        hai = False
        i = 0
        if A == B:
            sum = N * A
            while sum != 0:
                digit = sum % 10
                if digit == C or digit == D:
                    hai = True
                    break
                sum //= 10
            if hai:
                return 1
            return 0
        if hogya == False:
            self.help()
            hogya = True
        ans = 0
        while i <= N:
            sum = A * i + (B * (N - i))
            hai = False
            while sum != 0:
                digit = sum % 10
                if digit == C or digit == D:
                    hai = True
                    break
                sum //= 10
            if hai == True:
                ans += self.help2(N, i)
                ans %= mod
            i += 1
        return ans


================================================================================
Date: 2023-04-10
Problem: MaximumIntersectingLines
Filename: 2023-04-10_MaximumIntersectingLines.py
================================================================================

from collections import defaultdict

class Solution:
    def maxIntersections(self, lines, N):
        mp = defaultdict(int)
        for x in lines:
            st = x[0]
            end = x[1] + 1
            mp[st] += 1
            mp[end] -= 1

        sorted_keys = sorted(mp.keys())
        ans = 0
        curr = 0
        for key in sorted_keys:
            curr += mp[key]
            ans = max(ans, curr)

        return ans


================================================================================
Date: 2023-04-11
Problem: MaximumLength
Filename: 2023-04-11_MaximumLength.py
================================================================================

class Solution:
    def solve(self, a, b, c):
        if a > (2 * (b + c) + 2) or b > (2 * (a + c) + 2) or c > (2 * (b + a) + 2):
            return -1
        return a + b + c


================================================================================
Date: 2023-04-12
Problem: DominantPairs
Filename: 2023-04-12_DominantPairs.py
================================================================================

from typing import List

class Solution:
    def dominantPairs(self, n : int, arr : List[int]) -> int:
        # code here
        arr[:n//2] = sorted(arr[:n//2])  # sort left half
        arr[n//2:n] = sorted(arr[n//2:n])  # sort right half
        
        ans = 0
        j = n // 2
        for i in range(n // 2):
            while j < n and arr[i] >= 5 * arr[j]:
                j += 1
            ans += j - n // 2
        
        return ans


================================================================================
Date: 2023-04-13
Problem: PartitionTheArray
Filename: 2023-04-13_PartitionTheArray.py
================================================================================

class Solution:
    def minDifference(self, N, A): 
        arr = [0] * N
        arr[0] = A[0]
        for i in range(1, N):
            arr[i] = A[i] + arr[i - 1]
        ans = float('inf')
        for i in range(2, N - 1):
            index = self.binary_search(arr, 0, i - 1, arr[i - 1], 0)
            w = arr[index]
            x = arr[i - 1] - w
            index = self.binary_search(arr, i, N - 1, arr[N - 1], arr[i - 1])
            y = arr[index] - arr[i - 1]
            z = arr[N - 1] - arr[index]
            ans = min(ans, max(w, x, y, z) - min(w, x, y, z))
        return ans

    def binary_search(self, arr, low, high, _sum, temp):
        mid, index = -1, -1
        first, second, diff = float('inf'), float('inf'), float('inf')
        while low <= high:
            mid = (low + high) // 2
            first = arr[mid] - temp
            second = _sum - arr[mid]
            if abs(first - second) < diff:
                index = mid
                diff = abs(first - second)
            if first < second:
                low = mid + 1
            else:
                high = mid - 1
        return index


================================================================================
Date: 2023-04-14
Problem: RemoveTheBalls
Filename: 2023-04-14_RemoveTheBalls.py
================================================================================

from typing import List

class Solution:
    def finLength(self, N : int, color : List[int], radius : List[int]) -> int:
        st = []
        for i in range(N):
            if len(st):
                index = st[-1]
                if color[index] == color[i] and radius[index] == radius[i]:
                    st.pop()
                else:
                    st.append(i)
            else:
                st.append(i)
        return len(st)


================================================================================
Date: 2023-04-15
Problem: FindTotalTimeTaken
Filename: 2023-04-15_FindTotalTimeTaken.py
================================================================================

from typing import List


class Solution:
    def totalTime(self, n : int, arr : List[int], time : List[int]) -> int:
        curr = 0
        taken = {
            arr[0]: True
        }
        
        for i in range(1, n):
            arri=arr[i]
            if(arri in taken):
                curr+=time[arri-1]
            else:
                curr+=1
            
            taken[arri] = True
        
        return curr


================================================================================
Date: 2023-04-16
Problem: UnequalArrays
Filename: 2023-04-16_UnequalArrays.py
================================================================================

class Solution:
    def solve(self, N, A, B):
        # code here
        sum = 0
        # make two lists for storing and separating odd and even elements
        x = [[], []]
        y = [[], []]
        # iterate over A and B arrays
        for i in range(N):
            sum += A[i] - B[i]
            if A[i] % 2 == 0:
                x[0].append(A[i])
            else:
                x[1].append(A[i])
            if B[i] % 2 == 0:
                y[0].append(B[i])
            else:
                y[1].append(B[i])
    
        # not possible to convert
        if sum != 0 or len(x[0]) != len(y[0]):
            return -1
    
        ans = 0
    
        # sort list one by one and take the difference.
        for i in range(2):
            x[i].sort()
            y[i].sort()
    
            for j in range(len(x[i])):
                ans += abs(x[i][j] - y[i][j]) // 2
    
        return ans // 2


================================================================================
Date: 2023-04-17
Problem: JobSequencingProblem
Filename: 2023-04-17_JobSequencingProblem.py
================================================================================

class JobComparator:
    def compare(self, j1, j2):
        return j2.profit - j1.profit

class Solution:
    # Function to find the maximum profit and the number of jobs done.
    def JobScheduling(self, arr, n):
        # Your code here
        arr.sort(key=lambda x: x.profit, reverse=True)

        res = 0
        tot_job = 0
        slot = [False] * n  # track of free time slots - all false now

        # itr for all jobs.
        for i in range(n):
            # linear search [deadline to 0] - explained in dry run
            for j in range(arr[i].deadline - 1, -1, -1):
                # if free slot found - add the profits, tot_job++, mark slot filled
                if not slot[j]:
                    res += arr[i].profit
                    tot_job += 1
                    slot[j] = True
                    break

        ans = [tot_job, res]
        return ans


================================================================================
Date: 2023-04-18
Problem: MinimumBSTSumSubtree
Filename: 2023-04-18_MinimumBSTSumSubtree.py
================================================================================



class Solution:
    def get(self, root, c):
        if not root:
            return 0

        c[0] += 1
        l = self.get(root.left, c)
        r = self.get(root.right, c)

        return l + r + root.data

    def populate(self, root, v):
        if not root:
            return

        self.populate(root.left, v)
        v.append(root.data)
        self.populate(root.right, v)

    def recur(self, target, root, res):
        if not root:
            return

        c = [0]
        sum = self.get(root, c)

        if sum == target:
            v = []
            self.populate(root, v)

            be = True
            for i in range(1, len(v)):
                if v[i - 1] >= v[i]:
                    be = False
                    break

            if be:
                res[0] = min(res[0], c[0])

        self.recur(target, root.left, res)
        self.recur(target, root.right, res)

    def minSubtreeSumBST(self, target, root):
        sum = [1e9]
        self.recur(target, root, sum)
        return int(sum[0]) if sum[0] != 1e9 else -1


================================================================================
Date: 2023-04-19
Problem: WiFiRange
Filename: 2023-04-19_WiFiRange.py
================================================================================

class Solution:
    def wifiRange(self, n, s, x):
        v = []
        for i in range(n):
            if s[i] == '1':
                v.append(i)
        for i in range(len(v)-1):
            if v[i+1] - v[i] - 1 > 2*x:
                return False
        if v[0] > x:
            return False
        if n-1-v[-1] > x:
            return False
        return True


================================================================================
Date: 2023-04-20
Problem: BheemWantsLadoos
Filename: 2023-04-20_BheemWantsLadoos.py
================================================================================

class Solution:
    ans = 0

    def ladoos(self, root, home, k):
        self.ans = 0
        self.solve(root, home, k)
        return self.ans

    def solve(self, root, home, k):
        if root is None:
            return -1
        if root.data == home:  # add till k levels downstream
            self.add(root, k)
            return k-1  # will add k-1 downstream nodes from parent node of target
        
        rem = self.solve(root.right, home, k)  # found in right st - rem is catching k-1 
        if rem >= 0:
            self.ans += root.data  # adding the target's parent in sum;
            self.add(root.left, rem-1)  # since found on right,ie we need to target parent left st
            return rem-1 
        
        # try writing for left st as well.
        rem = self.solve(root.left, home, k)  # when we found the target in lst
        if rem >= 0:
            self.ans += root.data
            self.add(root.right, rem-1)
            return rem-1
        return -1


    def add(self, n, dist):
        if n is None or dist < 0:
            return
        self.ans += n.data
        # sum curr node and recur for left and right
        self.add(n.left, dist-1)
        self.add(n.right, dist-1)


================================================================================
Date: 2023-04-21
Problem: PrefixSuffixString
Filename: 2023-04-21_PrefixSuffixString.py
================================================================================

class Solution:
    def prefixSuffixString(self, s1, s2) -> int:
        mm = {}
        for x in s1:
            temp = ""
            for i in range(len(x)):
                temp += x[i]
                mm[temp] = True
            temp = ""
            for i in range(len(x)-1, -1, -1):
                temp = x[i] + temp
                mm[temp] = True
        ans = 0
        for x in s2:
            if x in mm:
                ans += 1
        return ans        


================================================================================
Date: 2023-04-22
Problem: SmallerSum
Filename: 2023-04-22_SmallerSum.py
================================================================================

from typing import List

class Solution:
    def smallerSum(self, n : int, arr : List[int]) -> List[int]:
        cp = arr.copy()
        cp.sort()
        
        dit = {}
        pre_sum = 0
        
        for elem in cp:
            if elem not in dit:
                dit[elem] = pre_sum
            
            pre_sum += elem
        
        ans = [] 
        for i in range(n):
            ans.append(dit[arr[i]])
            
        return ans


================================================================================
Date: 2023-04-23
Problem: MinimumNumber
Filename: 2023-04-23_MinimumNumber.py
================================================================================

class Solution:
    def minimumNumber(self, n, arr):
        if n==1:
            return arr[0]
        if n==2:
            return abs(arr[0] - arr[1])
        else:
            return 1


================================================================================
Date: 2023-04-24
Problem: NearestSmallerTower
Filename: 2023-04-24_NearestSmallerTower.py
================================================================================

from collections import deque

class Solution:
    def nearestSmallestTower(self, arr):
        n = len(arr)
        left, right = deque(), deque()
        res = [-1] * n

        for i in range(n):
            while left and arr[left[-1]] >= arr[i]:
                left.pop()

            if left:
                res[i] = left[-1]

            left.append(i)

        for i in range(n-1, -1, -1):
            while right and arr[right[-1]] >= arr[i]:
                right.pop()

            if right:
                if res[i] != -1:
                    if abs(res[i] - i) == abs(right[-1] - i):
                        if arr[res[i]] > arr[right[-1]]:
                            res[i] = right[-1]
                    elif abs(res[i] - i) > abs(right[-1] - i):
                        res[i] = right[-1]
                else:
                    res[i] = right[-1]

            right.append(i)

        return res


================================================================================
Date: 2023-04-25
Problem: GameOfSubset
Filename: 2023-04-25_GameOfSubset.py
================================================================================

from typing import List

class Solution:
    def __init__(self):
        self.mod = 10**9 + 7
        self.mp = [0] * 31
        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
        for i in range(2, 31):
            if i % 4 == 0 or i % 9 == 0 or i == 25:
                continue
            mask = 0
            for j, p in enumerate(primes):
                if i % p == 0:
                    mask |= 1 << j
            self.mp[i] = mask

    def pow(self, n):
        ans, m = 1, 2
        while n != 0:
            if n & 1 == 1:
                ans = (ans * m) % self.mod
            m = (m * m) % self.mod
            n >>= 1
        return ans

    def goodSubsets(self, n : int, arr : List[int]) -> int:
        one = 0
        dp = [0] * 1024
        cnt = [0] * 31
        dp[0] = 1
        for i in arr:
            if i == 1:
                one += 1
            elif self.mp[i] != 0:
                cnt[i] += 1
        for i in range(31):
            if cnt[i] == 0:
                continue
            for j in range(1024):
                if j & self.mp[i] != 0:
                    continue
                dp[j | self.mp[i]] = (dp[j | self.mp[i]] + dp[j] * cnt[i]) % self.mod

        ans = sum(dp) % self.mod - 1
        if one != 0:
            ans = (ans * self.pow(one)) % self.mod
        return ans


================================================================================
Date: 2023-04-26
Problem: SeatingArrangement
Filename: 2023-04-26_SeatingArrangement.py
================================================================================

from typing import List

class Solution:
    def is_possible_to_get_seats(self, n : int, m : int, seats : List[int]) -> bool:
        prevSit=None
        nextSit=None
        count=n
        for i in range(m):
            nextSit=seats[i+1] if i<m-1 else False
            if(not (prevSit or nextSit) and seats[i] != 1):
                count-=1
                prevSit=True
            else:
                prevSit=False
            if(seats[i] == 1):
                prevSit=True
            if(count == 0):
                break
        if(count==0):
            return True
        return False
        


================================================================================
Date: 2023-04-27
Problem: EasyTask
Filename: 2023-04-27_EasyTask.py
================================================================================

class SegmentTree:
    def __init__(self, s):
        n = len(s)
        self.tree = [[0]*(26) for _ in range(4*n)]
        self.buildTree(s, 0, n - 1, 0)

    def buildTree(self, s, left, right, index = 0):
        if left == right:
            self.tree[index][ord(s[left])-ord("a")]+=1
            return

        mid = (left + right) // 2
        self.buildTree(s, left, mid, 2 * index + 1)
        self.buildTree(s, mid + 1, right, 2 * index + 2)
        for c in range(26):
            
            self.tree[index][c] = self.tree[2 * index + 1][c] + self.tree[2 * index + 2][c]
    def update(self, s,left, right, pos, char,index = 0):
        if pos < left or pos > right:
            return

        if left == right:
            self.tree[index][ord(s[pos])-ord("a")] -=1
            s[pos]=char
            self.tree[index][ord(s[pos])-ord("a")] +=1
            return

        mid = (left + right) // 2
        if pos <= mid:
            self.update(s,left, mid, pos, char,2 * index + 1)
        else:
            self.update(s,mid + 1, right, pos, char,2 * index + 2)

        for c in range(26):
            
            self.tree[index][c] = self.tree[2 * index + 1][c] + self.tree[2 * index + 2][c]
    def query(self, left, right, i, j, index = 0):
        if right < i or left > j:
            return [0]*26

        if i <= left and right <= j:
            return self.tree[index]

        mid = (left + right) // 2
        temp=[0]*(26)
        
        res1=self.query(left, mid, i, j, 2 * index + 1)
        res2=self.query(mid + 1, right, i, j,2 * index + 2)
        for c in range(26):
            temp[c]=res1[c]+res2[c]
        return temp
class Solution:
    def easyTask(self,n,s,q,queries):
        s=[el for el in s]
        seg=SegmentTree(s)
        res=[]
        for quer in queries:
            if quer[0]=="1":
                seg.update(s,0,n-1,int(quer[1]),quer[2])
            else:
                char_freq=seg.query(0,n-1,int(quer[1]),int(quer[2]))
                k=int(quer[3])
                for c in range(25,-1,-1):
                    k-=min(k,char_freq[c])
                    if k==0:
                        res.append(chr(ord("a")+c))
                        break
        return res


================================================================================
Date: 2023-04-28
Problem: GeeksVillageAndWells
Filename: 2023-04-28_GeeksVillageAndWells.py
================================================================================

from typing import List, Tuple
from collections import deque

class Solution:
    def chefAndWells(self, n: int, m: int, c: List[List[str]]) -> List[List[int]]:
        ans = [[-1 for _ in range(m)] for _ in range(n)]
        q = deque()
        
        for i in range(n):
            for j in range(m):
                if c[i][j] == 'W':
                    q.append((i,j))
                    ans[i][j] = 0
        
        x = [-1,1,0,0]
        y = [0,0,-1,1]
        
        while q:
            temp = q.popleft()
            i, j = temp[0], temp[1]
            for k in range(4):
                newi = i + x[k]
                newj = j + y[k]
                if 0 <= newi < n and 0 <= newj < m and c[newi][newj] != 'N' and ans[newi][newj] == -1:
                    ans[newi][newj] = ans[i][j] + 1
                    q.append((newi, newj))
        
        for i in range(n):
            for j in range(m):
                if c[i][j] == 'N' or c[i][j] == '.':
                    ans[i][j] = 0
                elif ans[i][j] != -1:
                    ans[i][j] *= 2
        
        return ans


================================================================================
Date: 2023-04-29
Problem: FindNumber
Filename: 2023-04-29_FindNumber.py
================================================================================

class Solution:
    def findNumber(self, N : int) -> int:
        curr, ans = 1, 0
        arr = [9, 1, 3, 5, 7]
        while N:
            ans = arr[N%5] * curr + ans
            if N%5 == 0:
                N = N//5 - 1
            else:
                N = N//5
            curr = curr * 10
        return ans


================================================================================
Date: 2023-04-30
Problem: PowerfullInteger
Filename: 2023-04-30_PowerfullInteger.py
================================================================================

class Solution:
    def powerfullInteger(self,n,intervals,k):
        mp={}
        for start,end in intervals:
            if start not in mp:
                mp[start]=0
            if end+1 not in mp:
                mp[end+1]=0
            mp[start]+=1
            mp[end+1]-=1
        v=-1
        temp=0
        for el in sorted(mp.keys()):
            if mp[el]>=0:
                    
                temp+=mp[el]
                if temp>=k:
                    v=el
            else :
                if temp>=k:
                    v=el-1
                temp+=mp[el]
        return v


================================================================================
Date: 2023-05-01
Problem: SubtreeInN-aryTree
Filename: 2023-05-01_SubtreeInN-aryTree.py
================================================================================

class Solution:
    def duplicateSubtreeNaryTree(self, root):
        subtrees_count = {}
        
        def find_duplicate_subtrees(root):
            if root is None:
                return ""
            
            subtree_str = root.__str__()
            
            for child in root.children:
                subtree_str = subtree_str + "#" + find_duplicate_subtrees(child)
            
            subtrees_count[subtree_str] = subtrees_count.get(subtree_str, 0) + 1
            
            return subtree_str
        
        find_duplicate_subtrees(root)
        
        duplicate_count = 0
        for count in subtrees_count.values():
            if count > 1:
                duplicate_count += 1
        
        return duplicate_count

================================================================================
Date: 2023-05-02
Problem: CakeDistributionProblem
Filename: 2023-05-02_CakeDistributionProblem.py
================================================================================

class Solution():
    def isPoss(self, sweetness, mid, k):
        sum_val = 0
        cnt = 0
        for s in sweetness:
            sum_val += s
            if sum_val >= mid:
                cnt += 1
                sum_val = 0
        return cnt >= k + 1    
    
    
    def maxSweetness(self, sweetness, n, k):
        sum_val = 0
        min_sweetness = float('inf')
        for s in sweetness:
            sum_val += s
            min_sweetness = min(min_sweetness, s)
        
        l = min_sweetness
        h = sum_val
        ans = 0
        
        while l <= h:
            mid = (l + h) // 2
            if self.isPoss(sweetness, mid, k):
                ans = mid
                l = mid + 1
            else:
                h = mid - 1
        
        return ans


================================================================================
Date: 2023-05-03
Problem: MakePalindrome
Filename: 2023-05-03_MakePalindrome.py
================================================================================

from typing import List

class Solution:
    def makePalindrome(self, n : int, arr : List[str]) -> bool:
        mp = {}
        for it in arr:
            rev = it[::-1]
            if rev in mp and mp[rev] > 0:
                mp[rev] -= 1
                if mp[rev] == 0:
                    del mp[rev]
            else:
                mp[it] = mp.get(it, 0) + 1
        if not mp:
            return True
        if len(mp) == 1:
            curr = list(mp.keys())[0]
            rev = curr[::-1]
            return rev == curr
        return False


================================================================================
Date: 2023-05-04
Problem: MaxCoins
Filename: 2023-05-04_MaxCoins.py
================================================================================

from typing import List, Tuple

class Solution:
    def maxCoins(self, n, ranges):
        ranges.sort(key=lambda r: (r[1], r[0]))
        range_list = []
        max_coins = 0
        for range in ranges:
            max_coins = max(max_coins, self.get_maximum_coins_in_range(range_list, range[0]) + range[2])
            if not range_list or range_list[-1][1] < range[2]:
                range_list.append((range[1], range[2]))
        return max_coins

    def get_maximum_coins_in_range(self, range_list: List[Tuple[int, int]], end: int) -> int:
        lo, hi, idx = 0, len(range_list) - 1, -1
        while lo <= hi:
            mid = lo + (hi - lo) // 2
            if range_list[mid][0] <= end:
                idx = mid
                lo = mid + 1
            else:
                hi = mid - 1
        return 0 if idx == -1 else range_list[idx][1]


================================================================================
Date: 2023-05-05
Problem: GoodSubtrees
Filename: 2023-05-05_GoodSubtrees.py
================================================================================

class Solution:
    def help(self, root, k, ans):
        mm, mm2, mm3 = {}, {}, {}
        if root.left:
            mm2 = self.help(root.left, k, ans)
        if root.right:
            mm3 = self.help(root.right, k, ans)
        if len(mm2) > k:
            return mm2
        if len(mm3) > k:
            return mm3
        mm[root.data] = 1
        for x in mm2:
            mm[x] = mm.get(x, 0) + mm2[x]
        for x in mm3:
            mm[x] = mm.get(x, 0) + mm3[x]
        if len(mm) <= k:
            ans[0] += 1
        return mm
    
    def goodSubtrees(self, root, k):
        ans = [0]
        self.help(root, k, ans)
        return ans[0]


================================================================================
Date: 2023-05-06
Problem: AnotherCoinChangeProblem
Filename: 2023-05-06_AnotherCoinChangeProblem.py
================================================================================

class Solution:
    def makeChanges(self, N, K, target, coins):
        memo = [[-1] * (target + 1) for _ in range(K + 1)]
        
        def dp(i, j, k):
            if i == 0:
                return j == 0 and k == 0
            
            if memo[k][j] != -1:
                return memo[k][j]
            
            x = dp(i - 1, j, k)
            y = 0
            if j >= coins[i - 1] and k >= 1:
                y = dp(i, j - coins[i - 1], k - 1)
            
            memo[k][j] = x + y
            return memo[k][j]
        
        return dp(N, target, K)


================================================================================
Date: 2023-05-07
Problem: StringMirror
Filename: 2023-05-07_StringMirror.py
================================================================================

class Solution:
    def stringMirror(self, str : str) -> str:
        ans = []
        ans.append(str[0])
        
        for i in range(1, len(str)):
            if str[i - 1] > str[i] or (i > 1 and str[i] == str[i - 1]):
                ans.append(str[i])
            else:
                break
        
        curr = ''.join(ans)
        return curr + curr[::-1]


================================================================================
Date: 2023-05-08
Problem: BinaryModulo
Filename: 2023-05-08_BinaryModulo.py
================================================================================

class Solution():
    def modulo(self, s, m):
        return int(s, 2)%m


================================================================================
Date: 2023-05-09
Problem: CountBinaryStringWithNoConsecutive1s
Filename: 2023-05-09_CountBinaryStringWithNoConsecutive1s.py
================================================================================

MOD = 10**9 + 7

class Solution:
    def countStrings(self, N):
        matrix = [[1, 1], [1, 0]]
        res = self.matrixPower(matrix, N + 1)
        return res[0][0]

    def multiplyMatrices(self, a, b):
        result = [[0, 0], [0, 0]]
        for i in range(2):
            for j in range(2):
                for k in range(2):
                    result[i][j] = (result[i][j] + (a[i][k] * b[k][j]) % MOD) % MOD
        return result

    def matrixPower(self, a, n):
        result = [[1, 0], [0, 1]]
        while n > 0:
            if n % 2 == 1:
                result = self.multiplyMatrices(result, a)
            a = self.multiplyMatrices(a, a)
            n //= 2
        return result

================================================================================
Date: 2023-05-10
Problem: TotalCuts
Filename: 2023-05-10_TotalCuts.py
================================================================================

from typing import List

class Solution:
    def totalCuts(self, N: int, K: int, A: List[int]) -> int:
        right = [0] * N
        left = [0] * N
        left[0] = A[0]
        right[N-1] = A[N-1]

        for i in range(1, N):
            left[i] = max(left[i-1], A[i])

        for i in range(N-2, -1, -1):
            right[i] = min(right[i+1], A[i])
        
        ans = 0
        for i in range(N-1):
            if left[i] + right[i+1] >= K:
                ans += 1
        
        return ans


================================================================================
Date: 2023-05-12
Problem: ArrayOperations
Filename: 2023-05-12_ArrayOperations.py
================================================================================

from typing import List

class Solution:
    def arrayOperations(self, n : int, arr : List[int]) -> int:
        ans = 0
        length = 0
    
        for i in range(n):
            if arr[i] == 0:
                if length:
                    ans += 1
                length = 0
            else:
                length += 1
    
        if length == n:
            return -1
        if length:
            ans += 1
    
        return ans


================================================================================
Date: 2023-05-13
Problem: BitMagic
Filename: 2023-05-13_BitMagic.py
================================================================================

from typing import List

class Solution:
    def bitMagic(self, n : int, arr : List[int]) -> int:
        Operations = 0
        i = 0
        j = n - 1
        while i < j:
            if(arr[i] != arr[j]):
                Operations += 1
            i += 1
            j -= 1
        ans = str(Operations/2 + Operations%2)
        return ans[:ans.index(".")] if "." in ans else ans


================================================================================
Date: 2023-05-14
Problem: MaximumSubsetSum
Filename: 2023-05-14_MaximumSubsetSum.py
================================================================================

from typing import List

class Solution:
    def findMaxSubsetSum(self, N : int, A : List[int]) -> int:
        dp = [[0, 0] for _ in range(N)]
        dp[0][0] = 0
        dp[0][1] = A[0]
        
        for i in range(1, N):
            dp[i][0] = dp[i-1][1]
            dp[i][1] = max(dp[i-1][0], dp[i-1][1]) + A[i]
        
        return max(dp[N-1][0], dp[N-1][1])


================================================================================
Date: 2023-05-15
Problem: CountTotalSetbits
Filename: 2023-05-15_CountTotalSetbits.py
================================================================================

class Solution:
    def countBits(self, N : int) -> int:
        ans = 0
        i = 1
        n = N
        while n != 0:
            temp = (N + 1) // (i * 2)
            ans += temp * i
            temp = (N + 1) // i
            if temp % 2 == 1:
                ans += (N + 1) % i
            i *= 2
            n >>= 1
        return ans


================================================================================
Date: 2023-05-16
Problem: CuttingBinaryStrings
Filename: 2023-05-16_CuttingBinaryStrings.py
================================================================================

class Solution:
    def cuts(self, s):
        ch = list(s)
        n = len(s)
        dp = [0] * (n + 1)
        dp[0] = 0  # rep ""
        
        for i in range(1, n + 1):
            j = i - 1
            if ch[j] == '0':
                dp[i] = -1  # not poss
            else:
                dp[i] = -1
                curr_ans = float("inf")
                to_dec = 0
                for k in range(i):
                    if ch[j - k] == '1':  # then only weightage counts
                        to_dec += 1 << k
                        if Solution.pow_of_5(to_dec) and dp[j - k] != -1:
                            curr_ans = min(1 + dp[j - k], curr_ans)
                if curr_ans != float("inf"):
                    dp[i] = curr_ans
        return dp[n]

    def pow_of_5(n):
        if n == 0:
            return False
        if n == 1:
            return True
        if n % 5 != 0:
            return False
        else:
            return Solution.pow_of_5(n // 5)


================================================================================
Date: 2023-05-17
Problem: TracePath
Filename: 2023-05-17_TracePath.py
================================================================================

class Solution:
    def isPossible(self, n, m, s):
        t_l = 0
        t_r = 0
        t_u = 0
        t_d = 0
        f_lr = 0
        f_ud = 0
        
        for i in range(len(s)):
            if s[i] == 'L':
                f_lr += 1
            elif s[i] == 'R':
                f_lr -= 1
            elif s[i] == 'U':
                f_ud += 1
            else:
                f_ud -= 1
            
            if f_lr >= 0:
                t_l = max(t_l, f_lr)
            else:
                t_r = min(t_r, f_lr)
            
            if f_ud >= 0:
                t_u = max(t_u, f_ud)
            else:
                t_d = min(t_d, f_ud)
        
        if t_l - t_r < m and t_u - t_d < n:
            return 1
        
        return 0


================================================================================
Date: 2023-05-18
Problem: FindNumberOfClosedIslands
Filename: 2023-05-18_FindNumberOfClosedIslands.py
================================================================================

class Solution:
    def help(self, arr, i, j, N, M):
        if i < 0 or j < 0 or i == N or j == M or arr[i][j] == 0:
            return
        arr[i][j] = 0
        self.help(arr, i + 1, j, N, M)
        self.help(arr, i - 1, j, N, M)
        self.help(arr, i, j + 1, N, M)
        self.help(arr, i, j - 1, N, M)
    
    def closedIslands(self, matrix, N, M):
        ans = 0
        for i in range(N):
            for j in range(M):
                if matrix[i][j] == 1:
                    if i == 0 or j == 0 or i == N - 1 or j == M - 1:
                        self.help(matrix, i, j, N, M)
        for i in range(N):
            for j in range(M):
                if matrix[i][j] == 1:
                    ans += 1
                    self.help(matrix, i, j, N, M)
        return ans


================================================================================
Date: 2023-05-19
Problem: kthSmallestElement
Filename: 2023-05-19_kthSmallestElement.py
================================================================================

from typing import List

class Solution:
    def kthSmallestNum(self, n: int, ranges: List[List[int]], q: int, queries: List[int]) -> List[int]:
        ranges.sort()
        ans = []
        for query in queries:
            last = -1
            found = False
            for i in range(n):
                start, end = ranges[i]
                if last < end and last >= start:
                    t = end - last
                    if t >= query:
                        ans.append(last + query)
                        found = True
                        break
                    last = end
                    query -= t
                elif last < start:
                    t = end - start + 1
                    if t >= query:
                        ans.append(start + query - 1)
                        found = True
                        break
                    last = end
                    query -= t
            if not found:
                ans.append(-1)
        return ans


================================================================================
Date: 2023-05-20
Problem: HandsOfStraights
Filename: 2023-05-20_HandsOfStraights.py
================================================================================

from collections import Counter

class Solution:
    def isStraightHand(self, N, groupSize, hand):
        counter = Counter(hand)
        hand = sorted(hand)
        
        for item in hand:
            if counter[item] == 0:
                continue
            
            for i in range(groupSize):
                if counter[item + i] == 0:
                    return False
                
                counter[item + i] -= 1
        
        return True


================================================================================
Date: 2023-05-21
Problem: BusConductor
Filename: 2023-05-21_BusConductor.py
================================================================================

class Solution:
    def findMoves(self,n,chairs,passengers):
        chairs.sort()
        passengers.sort()
        ans = 0
        for i in range(n):
            ans += abs(chairs[i] - passengers[i])
        return ans


================================================================================
Date: 2023-05-22
Problem: TreeTransformation
Filename: 2023-05-22_TreeTransformation.py
================================================================================

from typing import List


class Solution:
    def solve(self, N : int, p : List[int]) -> int:
        con = [0] * N
        for i in range(1, N):
            con[i] += 1
            con[p[i]] += 1
    
        ans = 0
        for x in con:
            if x == 1:
                ans += 1
    
        return N - ans - 1


================================================================================
Date: 2023-05-23
Problem: ConstructaFullBinaryTree
Filename: 2023-05-23_ConstructaFullBinaryTree.py
================================================================================

class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

class Solution:
    def constructBinaryTree(self, pre, pre_mirror, size):
        pos = size - 1
        index = 0
    
        def construct():
            nonlocal index, pos

            if index >= size:
                return None
    
            current = Node(pre[index])
    
            if current.data != pre_mirror[pos]:
                index += 1
                current.left = construct()
    
                index += 1
                current.right = construct()
    
            pos -= 1
            return current
    
        head = Node(None)
        head.left = construct()
    
        return head.left


================================================================================
Date: 2023-05-24
Problem: MaximumIdenticalBowls
Filename: 2023-05-24_MaximumIdenticalBowls.py
================================================================================

from typing import List

class Solution:
    def getMaximum(self, N : int, arr : List[int]) -> int:
        sum = 0
        for x in arr:
            sum += x
        while N > 0:
            if sum % N == 0:
                return N
            
            N -= 1

        return 0   


================================================================================
Date: 2023-05-25
Problem: ExpressionAddOperators
Filename: 2023-05-25_ExpressionAddOperators.py
================================================================================

class Solution:
    def addOperators(self, S, target):
        ans = []
        if S is None or len(S) == 0:
            return ans
        self.helper(ans, "", S, target, 0, 0, 0)
        return ans
    
    def helper(self, ans, path, num, target, ind, p_val, prev):    
        if ind == len(num):
            if target == p_val:
                ans.append(path)
            return
    
        for i in range(ind, len(num)):
            cur = int(num[ind:i+1])
            if ind == 0:
                self.helper(ans, path + str(cur), num, target, i + 1, cur, cur)
            else:
                self.helper(ans, path + "+" + str(cur), num, target, i + 1, p_val + cur, cur)
                self.helper(ans, path + "-" + str(cur), num, target, i + 1, p_val - cur, -cur)
                self.helper(ans, path + "*" + str(cur), num, target, i + 1, p_val - prev + prev * cur, prev * cur)
            if num[ind] == '0':
                break


================================================================================
Date: 2023-05-26
Problem: ExpressAsSumOfPowerOfNaturalNumbers
Filename: 2023-05-26_ExpressAsSumOfPowerOfNaturalNumbers.py
================================================================================

MOD = int(1e9 + 7)

class Solution:
	def numOfWays(self, n, x):
        dp = [[-1] * (n + 1) for _ in range(n + 1)]
        return self.help(n, x, 1, dp)

    def help(self, n, x, num, dp):
        if n == 0:
            return 1
        if num > n or n < 0:
            return 0
        if dp[n][num] != -1:
            return dp[n][num]
        temp = pow(num, x)
        dp[n][num] = (self.help(n - temp, x, num + 1, dp) + self.help(n, x, num + 1, dp)) % MOD
        return dp[n][num]


================================================================================
Date: 2023-05-26
Problem: NthNodeFromEndOfLinkedList
Filename: 2023-05-26_NthNodeFromEndOfLinkedList.py
================================================================================

def getNthFromLast(head,n):
    dataArr=[]
    while head:
        dataArr.append(head.data)
        head = head.next

    length = len(dataArr)
    return dataArr[length-n] if length >= n else -1


================================================================================
Date: 2023-05-29
Problem: CamelCasePatternMatching
Filename: 2023-05-29_CamelCasePatternMatching.py
================================================================================

class Solution:
    def CamelCase(self, N, Dictionary, Pattern):
        self.ans = []  # Change to instance variable
        root = self.Trie()
        self.build(Dictionary, root)
        self.find(Pattern, root)
        
        self.ans.sort()
        if not self.ans:
            self.ans.append("-1")
        return self.ans
    
    def build(self, a, root):
        for word in a:
            temp = root
            for i in range(len(word)):
                if word[i].isupper():
                    if temp.ch[ord(word[i]) - ord('A')] is None:
                        temp.ch[ord(word[i]) - ord('A')] = self.Trie()
                    temp = temp.ch[ord(word[i]) - ord('A')]
            temp.al.append(word)
    
    def find(self, s, root):
        for i in range(len(s)):
            if root.ch[ord(s[i]) - ord('A')] is None:
                return 0
            root = root.ch[ord(s[i]) - ord('A')]
        self.printAllWords(root)
        return 1
    
    def printAllWords(self, root):
        for word in root.al:
            self.ans.append(word)  # Use self.ans instead of ans
        for i in range(26):
            child = root.ch[i]
            if child is not None:
                self.printAllWords(child)
    
    class Trie:
        def __init__(self):
            self.ch = [None] * 26
            self.al = []


================================================================================
Date: 2023-05-30
Problem: WordSearch
Filename: 2023-05-30_WordSearch.py
================================================================================

class Solution:
    def isWordExist(self, board, word):
        for i in range(len(board)):
            for j in range(len(board[0])):
                if board[i][j] == word[0] and self.help(board, word, i, j, 0):
                    return True
        return False
    
    def help(self, b, w, i, j, length):
        if length == len(w):
            return True
        
        if i < 0 or j < 0 or i >= len(b) or j >= len(b[0]):
            return False
        
        if b[i][j] != w[length]:
            return False
        
        b[i][j] = '*'  # mark it as visited so that it cannot be used again in the path
        
        result = (
            self.help(b, w, i-1, j, length+1) or  # up
            self.help(b, w, i+1, j, length+1) or  # down
            self.help(b, w, i, j-1, length+1) or  # left
            self.help(b, w, i, j+1, length+1)     # right
        )
        
        b[i][j] = w[length]  # revert the mark to restore the board
        
        return result


================================================================================
Date: 2023-05-31
Problem: FrequencyGame
Filename: 2023-05-31_FrequencyGame.py
================================================================================

def LargButMinFreq(arr,n):
    myDict=dict()
    for i in arr:
        if(i not in myDict): myDict[i] = 0
        myDict[i]+=1
    minFreq = min(myDict.values())
    return max(filter(lambda key: myDict[key] == minFreq, myDict.keys()))
    


================================================================================
Date: 2023-06-04
Problem: ReversingTheEquation
Filename: 2023-06-04_ReversingTheEquation.py
================================================================================

import re

class Solution:
    def reverseEqn(self, s):
        tokens = re.findall(r'\d+|\+|\-|\*|\/', s)
        reversed_tokens = tokens[::-1] 
        reversed_eqn = ''.join(reversed_tokens)  
        return reversed_eqn


================================================================================
Date: 2023-06-09
Problem: PermutationsOfAGivenString
Filename: 2023-06-09_PermutationsOfAGivenString.py
================================================================================

from itertools import permutations

class Solution:
    def find_permutation(self, S):
        ans = []
        perms = permutations(S)

        unique_perms = set(''.join(perm) for perm in perms)

        sorted_perms = sorted(unique_perms)

        for perm in sorted_perms:
            ans.append(''.join(perm))
            
        return ans


================================================================================
Date: 2023-06-10
Problem: ArrangingtheArray
Filename: 2023-06-10_ArrangingtheArray.py
================================================================================

class Solution:
    def Rearrange(self, n, arr):
        temp = []
        for i in range(n):
            if arr[i] < 0:
                temp.append(arr[i])
        for i in range(n):
            if arr[i] >= 0:
                temp.append(arr[i])
        for i in range(n):
            arr[i] = temp[i]


================================================================================
Date: 2023-06-10
Problem: TickerCounter
Filename: 2023-06-10_TickerCounter.py
================================================================================

from collections import deque

class Solution:
    def distributeTicket(self, N: int, K: int) -> int:
        arr = deque(range(1, N + 1))
        iturn = True
        count = 0

        while len(arr) > 0:
            if count < K:
                if iturn:
                    lastElem = arr.popleft()
                else:
                    lastElem = arr.pop()
                count += 1

            if count == K:
                count = 0
                iturn = not iturn

        return lastElem


================================================================================
Date: 2023-06-11
Problem: AddingOnes
Filename: 2023-06-11_AddingOnes.py
================================================================================

class Solution:
    def update(self, a, n, updates, k):
        temp = 0
        for i in range(k):
            a[updates[i]-1] += 1
    
        for i in range(n):
            a[i] += temp
            temp = a[i]


================================================================================
Date: 2023-06-12
Problem: RodCutting
Filename: 2023-06-12_RodCutting.py
================================================================================

class Solution:
    def cutRod(self, price, n):
        dp = [0] * (n + 1)
        for i in range(1, n + 1):
            temp = float('-inf')
            for j in range(i):
                temp = max(temp, price[j] + dp[i - j - 1])
            dp[i] = temp
        return dp[n]


================================================================================
Date: 2023-06-14
Problem: MaximumDiamonds
Filename: 2023-06-14_MaximumDiamonds.py
================================================================================

import heapq

class Solution:
    def maxDiamonds(self, A, N, K):
        heap = []
        for num in A:
            heapq.heappush(heap, -num)

        arr = []
        while K != 0:
            max_num = -heapq.heappop(heap)
            arr.append(max_num)
            max_num //= 2
            heapq.heappush(heap, -max_num)
            K -= 1

        return sum(arr)


================================================================================
Date: 2023-06-17
Problem: QueueOperations
Filename: 2023-06-17_QueueOperations.py
================================================================================

class Solution:
    def insert(self, q, k): 
        q.append(k)

    def findFrequency(self, q, k):
        return q.count(k)


================================================================================
Date: 2023-06-19
Problem: RearrangeanArrayWithO1ExtraSpace
Filename: 2023-06-19_RearrangeanArrayWithO1ExtraSpace.py
================================================================================

class Solution:
    def arrange(self,arr, n): 
        for i in range(n):
            arr[i] += (arr[arr[i]] % n) * n
    
        for i in range(n):
            arr[i] = arr[i] // n
    
        return arr


================================================================================
Date: 2023-06-22
Problem: LemonadeChange
Filename: 2023-06-22_LemonadeChange.py
================================================================================

class Solution:
    def lemonadeChange(self, N, bills):
        count5 = 0
        count10 = 0
        
        for bill in bills:
            
            if bill == 5:
                count5 += 1
                
            elif bill == 10:
                if count5 == 0:
                    return False
                count10 += 1
                count5 -= 1
                
            elif bill == 20:
                if count10 >= 1 and count5 >= 1:
                    count10 -= 1
                    count5 -= 1
                elif count5 >= 3:
                    count5 -= 3
                else:
                    return False
        return True


================================================================================
Date: 2023-06-25
Problem: UniqueRowsInBooleanMatrix
Filename: 2023-06-25_UniqueRowsInBooleanMatrix.py
================================================================================

from typing import List

class Solution:
    def uniqueRow(self, row, col, matrix):
        final = []
        for i in range(row):
            if matrix[i] not in final:
                final.append(matrix[i])
        
        return final


================================================================================
Date: 2023-06-30
Problem: IsBinaryNumberMultipleOf3
Filename: 2023-06-30_IsBinaryNumberMultipleOf3.py
================================================================================

class Solution:
	def isDivisible(self, s):
		deci = int(s, 2)
		if deci % 3 == 0:
		    return 1
		return 0


================================================================================
Date: 2023-07-09
Problem: SmallestPositiveMIssingNumber
Filename: 2023-07-09_SmallestPositiveMIssingNumber.py
================================================================================

class Solution:
    def missingNumber(self,arr,n):
        for i in range(n):
            while arr[i] > 0 and arr[i] <= n and arr[arr[i] - 1] != arr[i]:
                arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1]

        for i in range(n):
            if arr[i] != i + 1:
                return i + 1
        return n + 1


================================================================================
Date: 2023-07-10
Problem: TransoseOfMatrix
Filename: 2023-07-10_TransoseOfMatrix.py
================================================================================

class Solution:
    def transpose(self, matrix, n):
        for i in range(n):
            for j in range(i+1, n):
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]


================================================================================
Date: 2023-07-11
Problem: FindTheKthElementOfaSpiralMatrix
Filename: 2023-07-11_FindTheKthElementOfaSpiralMatrix.py
================================================================================

class Solution:
    def findK(self, a, n, m, k):
        top = 0
        bottom = n - 1
        left = 0
        right = m - 1
        direction = 0
        count = 0
    
        while top <= bottom and left <= right:
            if direction == 0:
                for i in range(left, right + 1):
                    count += 1
                    if count == k:
                        return a[top][i]
                top += 1
                direction = 1
    
            elif direction == 1:
                for i in range(top, bottom + 1):
                    count += 1
                    if count == k:
                        return a[i][right]
                right -= 1
                direction = 2
    
            elif direction == 2:
                for i in range(right, left - 1, -1):
                    count += 1
                    if count == k:
                        return a[bottom][i]
                bottom -= 1
                direction = 3
    
            else:
                for i in range(bottom, top - 1, -1):
                    count += 1
                    if count == k:
                        return a[i][left]
                left += 1
                direction = 0
    
        return -1 


================================================================================
Date: 2023-07-12
Problem: PowerOfNumbers
Filename: 2023-07-12_PowerOfNumbers.py
================================================================================

class Solution:
    def power(self, N, R):
        MOD = 1000000007
        result = 1
        while R > 0:
            if R % 2 == 1:
                result = (result * N) % MOD
            N = (N * N) % MOD
            R //= 2
        return result


================================================================================
Date: 2023-07-13
Problem: UniqueNumberOfOccurrences
Filename: 2023-07-13_UniqueNumberOfOccurrences.py
================================================================================

from typing import List


class Solution:
    def isFrequencyUnique(self, n : int, arr : List[int]) -> bool:
        frequencies = dict()
        for i in arr:
            if(i not in frequencies): frequencies[i] = 0
            frequencies[i]+=1
        frequencies=frequencies.values()
        return len(set(frequencies))==len(frequencies)


================================================================================
Date: 2023-07-14
Problem: ImplementTwoStacksInAnArray
Filename: 2023-07-14_ImplementTwoStacksInAnArray.py
================================================================================

class TwoStacks:
    def __init__(self, n=100):
        self.size = n
        self.arr = [0] * n
        self.top1 = -1
        self.top2 = n

    # Function to push an integer into stack 1
    def push1(self, x):
        # Check if there is space available for stack 1
        if self.top1 < self.top2 - 1:
            self.top1 += 1
            self.arr[self.top1] = x
        else:
            print("Stack Overflow")

    # Function to push an integer into stack 2
    def push2(self, x):
        # Check if there is space available for stack 2
        if self.top1 < self.top2 - 1:
            self.top2 -= 1
            self.arr[self.top2] = x
        else:
            print("Stack Overflow")

    # Function to remove an element from top of stack 1
    def pop1(self):
        # Check if stack 1 is empty
        if self.top1 >= 0:
            x = self.arr[self.top1]
            self.top1 -= 1
            return x
        else:
            return -1  # Stack 1 is empty

    # Function to remove an element from top of stack 2
    def pop2(self):
        # Check if stack 2 is empty
        if self.top2 < self.size:
            x = self.arr[self.top2]
            self.top2 += 1
            return x
        else:
            return -1  # Stack 2 is empty


================================================================================
Date: 2023-07-15
Problem: DeleteMiddleElementOfaStack
Filename: 2023-07-15_DeleteMiddleElementOfaStack.py
================================================================================

class Solution:
    def deleteMid(self, s, sizeOfStack):
        midIndex = (sizeOfStack + 1) // 2
        if midIndex == 0 or midIndex >= sizeOfStack:
            return s
        del s[midIndex-1]
        return s


================================================================================
Date: 2023-07-16
Problem: QueueReversal
Filename: 2023-07-16_QueueReversal.py
================================================================================

class Solution:
    def rev(self, q):
        stack = []
        while not q.empty():
            stack.append(q.get())
        while stack:
            q.put(stack.pop())
        return q


================================================================================
Date: 2023-07-17
Problem: FirstNonRepeatingCharacterInaStream
Filename: 2023-07-17_FirstNonRepeatingCharacterInaStream.py
================================================================================

from collections import OrderedDict

class Solution:
	def FirstNonRepeating(self, A):
        counter = OrderedDict()  
        result = ""
    
        for char in A:
            if char in counter:
                counter[char] += 1
            else:
                counter[char] = 1
    
            unique_char = next((key for key, value in counter.items() if value == 1), "#")
            result += unique_char
    
        return result


================================================================================
Date: 2023-07-20
Problem: NonRepeatingCharacter
Filename: 2023-07-20_NonRepeatingCharacter.py
================================================================================

class Solution:
    def nonrepeatingCharacter(self,s):
        mydict = dict()
        
        for letter in s:
            if(letter not in mydict): mydict[letter] = 0
            mydict[letter] += 1
        for letter in s:
            if(mydict[letter] == 1):
                return letter
        return '$'


================================================================================
Date: 2023-07-25
Problem: LevelOrderTraversalInSpiralForm
Filename: 2023-07-25_LevelOrderTraversalInSpiralForm.py
================================================================================

def findSpiral(root):
    depthDict={0:[root.data]}
    elems=[root]
    newElems=[]
    depth=0
    while(len(elems)):
        depth+=1
        depthDict[depth]=[]
        for elem in elems:
            depthDict[depth].append(elem.left.data) if elem.left else None
            depthDict[depth].append(elem.right.data) if elem.right else None
            newElems.append(elem.left) if elem.left else None
            newElems.append(elem.right) if elem.right else None
        elems=newElems
        newElems=[]

    ans=[]
    for depth in depthDict:
        for elem in (depthDict[depth] if depth%2==1 else depthDict[depth][::-1]):
            ans.append(elem)
    return ans


================================================================================
Date: 2024-03-01
Problem: Peak element
Filename: 2024-03-01_Peak_element.py
================================================================================

# your task is to complete this function
# function should return index to the any valid peak element
class Solution:
    def peakElement(self, arr, n):
        m = float('-inf')
        for num in arr:
            if m < num:
                m = num
        for i, num in enumerate(arr):
            if m == num:
                return i
        return -1


 # Driver Code Starts

if __name__=='__main__':
    t = int(input())
    for i in range(t):
        n = int(input())
        arr = list(map(int, input().strip().split()))
        index = Solution().peakElement(arr.copy(), n)
        flag = False
        if index<0 or index>=n:
            flag = False
        else:
            if index == 0 and n==1:
                flag = True
            elif index==0 and arr[index]>=arr[index+1]:
                flag = True
            elif index==n-1 and arr[index]>=arr[index-1]:
                flag = True
            elif arr[index-1] <= arr[index] and arr[index] >= arr[index+1]:
                flag = True
            else:
                flag = False

        if flag:
            print(1)
        else:
            print(0)
# Contributed by: Harshit Sidhwa

# } Driver Code Ends


================================================================================
Date: 2024-03-02
Problem: First element to occur k times
Filename: 2024-03-02_First_element_to_occur_k_times.py
================================================================================

class Solution:
    def firstElementKTime(self, n, k, a):
        fdh = {}
        for i in range(n):
            if fdh.get(a[i]) and fdh[a[i]] + 1 == k:
                return a[i]
            elif fdh.get(a[i]):
                fdh[a[i]] += 1
            else:
                fdh[a[i]] = 1
        return -1


================================================================================
Date: 2024-03-03
Problem: Largest Number formed from an Array
Filename: 2024-03-03_Largest_Number_formed_from_an_Array.py
================================================================================

#User function Template for python3
class Solution:
    def printLargest(self, n, arr):
        arr.sort(key=functools.cmp_to_key(lambda a, b: 1 if a + b < b + a else -1))

        ans = ""
        for s in arr:
            ans += s
        return ans
 # Driver Code Starts
#Initial Template for Python 3

import functools

if __name__ == '__main__':
    tc = int(input())
    while tc > 0:
        n = int(input())
        arr = list(map(str, input().strip().split()))
        ob = Solution()
        ans = ob.printLargest(n, arr)
        print(ans)
        tc -= 1

# } Driver Code Ends


================================================================================
Date: 2024-03-04
Problem: Swap the array elements
Filename: 2024-03-04_Swap_the_array_elements.py
================================================================================

#User function Template for python3

class Solution:
    def swapElements(self, arr, n):
        for i in range(n - 2):
            arr[i], arr[i + 2] = arr[i + 2], arr[i]

 # Driver Code Starts

#Initial Template for Python 3
		
if __name__ == '__main__':
    T=int(input())
    for i in range(T):
        n = int(input())
        arr = list(map(int, input().strip().split()))
        obj = Solution()
        obj.swapElements(arr, n);
        for i in arr:
            print(i, end = " ")
        print()
# } Driver Code Ends


================================================================================
Date: 2024-03-05
Problem: Maximum Index
Filename: 2024-03-05_Maximum_Index.py
================================================================================

#User function Template for python3

class Solution:
    # Function to find the maximum index difference.
    def maxIndexDiff(self, a, n):
        left_min = [0] * n
        right_max = [0] * n
        
        left_min[0] = a[0]
        for i in range(1, n):
            left_min[i] = min(left_min[i - 1], a[i])
        
        right_max[n - 1] = a[n - 1]
        for i in range(n - 2, -1, -1):
            right_max[i] = max(right_max[i + 1], a[i])
        
        max_diff = 0
        i = j = 0
        while i < n and j < n:
            if left_min[i] <= right_max[j]:
                max_diff = max(max_diff, j - i)
                j += 1
            else:
                i += 1
        
        return max_diff
#{ 
 # Driver Code Starts
#Initial Template for Python 3

import math

def main():
        T=int(input())
        while(T>0):
            
            n=int(input())
            
            arr=[int(x) for x in input().strip().split()]
            ob=Solution()
            print(ob.maxIndexDiff(arr,n))
            
            
            T-=1


if __name__ == "__main__":
    main()
# } Driver Code Ends


================================================================================
Date: 2024-03-06
Problem: Search Pattern Rabin-Karp Algorithm
Filename: 2024-03-06_Search_Pattern_Rabin-Karp_Algorithm.py
================================================================================

Today GFG POTD Solution in Python

class Solution:
    def search(self,pat,txt):
        res = []

        q =101;d = 26

        M = len(pat);N = len(txt);  

        i=0; j=0  
        
        p = 0; # hash value for pattern  
        t = 0; # hash value for txt  
        h = 1;  
      
        # The value of h would be "pow(d, M-1)%q"  
        for i in range(M-1) :
            h = (h * d) % q 
      
        # Calculate the hash value of pattern and first  
        # window of text  
        for i in range(M):  
            p = (d * p + ord(pat[i])) % q  
            t = (d * t + ord(txt[i])) % q
      
        # Slide the pattern over text one by one  
        for i in range(N-M+1):
            # Check the hash values of current window of text  
            # and pattern. If the hash values match then only  
            # check for characters on by one  
            if  p == t :  
                # Check for characters one by one 
                j = 0 
                while j < M :
                    if txt[i+j] != pat[j]:
                        break
                    j+=1
      
                # if p == t and pat[0...M-1] = txt[i, i+1, ...i+M-1]  
                if j == M :  
                    res.append(i+1)  
            
      
            # Calculate hash value for next window of text: Remove  
            # leading digit, add trailing digit  
            if i < N-M :  
                t = (d*(t - ord(txt[i])*h) + ord(txt[i+M]))%q
      
                # We might get negative value of t, converting it  
                # to positive  
                if t < 0 :
                    t = (t + q)
            

        return res


================================================================================
Date: 2024-03-07
Problem: Longest repeating and non-overlapping substring
Filename: 2024-03-07_Longest_repeating_and_non-overlapping_substring.py
================================================================================

#User function Template for python3

class Solution:
    def longestSubstring(self, s, n):
        max_len = 0
        ans = "-1"
        i = j = 0

        while i < n and j < n:
            sub_string = s[i:j + 1]

            if s.find(sub_string, j + 1) != -1:
                length = len(sub_string)
                if length > max_len:
                    max_len = length
                    ans = sub_string
            else:
                i += 1
            j += 1
        
        return ans

 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__': 
    t = int (input ())
    for _ in range (t):
        N=int(input())
        S=input()
        
        ob = Solution()
        print(ob.longestSubstring(S , N))
# } Driver Code Ends


================================================================================
Date: 2024-03-08
Problem: Check if frequencies can be equal
Filename: 2024-03-08_Check_if_frequencies_can_be_equal.py
================================================================================

#User function Template for python3
class Solution:
    def sameFreq(self, s):
        M = 26  # size of hash map for all 26 letters
        
        freq = [0] * M
        for char in s:
            freq[self.getIdx(char)] += 1

        if self.allSame(freq, M):
            return True

        
        for c in range(ord('a'), ord('z') + 1):
            i = self.getIdx(chr(c))
            
            if freq[i] > 0:
                freq[i] -= 1

                if self.allSame(freq, M):
                    return True
                freq[i] += 1

        return False

    
    def getIdx(self, ch):
        return ord(ch) - ord('a')

    
    def allSame(self, freq, N):
        for i in range(N):
            if freq[i] > 0:
                same = freq[i]
                break

        for j in range(i + 1, N):
            if freq[j] > 0 and freq[j] != same:
                return False

        return True


#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == "__main__":
	T=int(input())

	for _ in range(T):
		s = input()
		ob = Solution()
		answer = ob.sameFreq(s)
		if answer:
			print(1)
		else:
			print(0)

# } Driver Code Ends


================================================================================
Date: 2024-03-09
Problem: Find the N-th character
Filename: 2024-03-09_Find_the_N-th_character.py
================================================================================

Today's GFG problem Solution in Python


class Solution:

    #Function to find the nth character in the given pattern.
    def nthCharacter(self, s, r, n):

        n += 1
        f = ""
        it = 0
        l = 0

        #loop to find the length of the sequence based on r value.
        while l<n:
            it += 1
            l = it * pow(2, r)
        
        p = pow(2, r)

        #updating n value based on the length of the sequence.
        n -= 1
        n %= p
        
        if it == 0:
            it += 1

        #appending the character at the ith position to the output string.
        f += s[it - 1]

        #loop to generate the sequence by iterating r times.
        for i in range(r):
            s = ""
            for j in range(len(f)):
                if f[j] == '1':
                    s += "10"
                else:
                    s += "01"
            f = s

        #returning the nth character from the generated sequence.
        return f[n]


================================================================================
Date: 2024-03-10
Problem: Remove all duplicates from a given string
Filename: 2024-03-10_Remove_all_duplicates_from_a_given_string.py
================================================================================

#User function Template for python3
class Solution:
    def removeDuplicates(self, str):
        # Initialize a set to keep track of seen characters
        seen = set()
        # Initialize an empty string to store the result
        result = ''
        
        # Iterate through each character in the string
        for char in str:
            # If the character has not been seen before, add it to the result and the set
            if char not in seen:
                result += char
                seen.add(char)
        
        return result

#{ 
# Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    tc = int(input())
    while tc > 0:
        str = input().strip()
        ob = Solution()
        ans = ob.removeDuplicates(str)
        print(ans)
        tc -= 1

# } Driver Code Ends


================================================================================
Date: 2024-03-11
Problem: Count pairs Sum in matrices
Filename: 2024-03-11_Count_pairs_Sum_in_matrices.py
================================================================================

#User function Template for python3
class Solution:
  def countPairs(self, mat1, mat2, n, x):
    count = 0
    r1 = 0
    c1 = 0
    r2 = n - 1
    c2 = n - 1

    while (r1 < n) and (r2 >= 0):
      val = mat1[r1][c1] + mat2[r2][c2]

      if val == x:
        count += 1
        c1 += 1
        c2 -= 1
      elif val < x:
        c1 += 1
      else:
        c2 -= 1

      # Handle boundary conditions within the loop
      if c1 == n:
        c1 = 0
        r1 += 1
      if c2 == -1:
        c2 = n - 1
        r2 -= 1

    return count

 # Driver Code Starts
#Initial Template for Python 3

if _name_ == '_main_':
	T=int(input())
	for i in range(T):
		n , x = input().split()
		n,x = int(n), int(x)
		mat1 = []
		for _ in range(n):
			a = [int(x) for x in input().split()]
			mat1.append(a)

		mat2 = []
		for _ in range(n):
			a = [int(x) for x in input().split()]
			mat2.append(a)

		ob = Solution()
		ans = ob.countPairs(mat1, mat2, n, x)
		print(ans)

# } DriverCodeEnds


================================================================================
Date: 2024-03-12
Problem: Generalised Fibonacci numbers
Filename: 2024-03-12_Generalised_Fibonacci_numbers.py
================================================================================

#User function Template for python3

class Solution:
    def multiply(self, A, B, m):
        size = len(A)
        result = [[0] * size for _ in range(size)]
        for i in range(size):
            for j in range(size):
                for k in range(size):
                    result[i][j] += (A[i][k] % m) * (B[k][j] % m)
                    result[i][j] %= m
        return result

    def genFibNum(self, a, b, c, n, m):
        if n <= 2:
            return 1 % m
        mat = [[a, b, 1], [1, 0, 0], [0, 0, 1]]
        res = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
        n -= 2
        while n > 0:
            if n & 1:
                res = self.multiply(res, mat, m)
            mat = self.multiply(mat, mat, m)
            n >>= 1
        return (res[0][0] + res[0][1] + c * res[0][2]) % m
#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__': 
    t = int (input ())
    for _ in range (t):
        a,b,c,n,m=map(int,input().split())
        
        ob = Solution()
        print(ob.genFibNum(a,b,c,n,m))
# } Driver Code Ends


================================================================================
Date: 2024-03-13
Problem: Print matrix in diagonal pattern
Filename: 2024-03-13_Print_matrix_in_diagonal_pattern.py
================================================================================

# Your task is to complete this function

# Your task is to complete this function

class Solution:
    def matrixDiagonally(self, mat):
        diagonalMap = {}
        n = len(mat)
        
        for i in range(n):
            for j in range(n):
                diagonalIndex = i + j
                if diagonalIndex % 2 == 0:
                    diagonalMap[(diagonalIndex, j)] = mat[i][j]
                else:
                    diagonalMap[(diagonalIndex, i)] = mat[i][j]
        
        diagonalOrder = [diagonalMap[key] for key in sorted(diagonalMap.keys())]
        return diagonalOrder




#{ 
 # Driver Code Starts
# Driver Program
if __name__=='__main__':
    t = int(input())
    for i in range(t):
        n = list(map(int, input().strip().split()))
        arr = list(map(int, input().strip().split()))
        matrix = [[0 for i in range(n[0])]for j in range(n[0])]
        k=0
        for i in range(n[0]):
            for j in range(n[0]):
                matrix[i][j] = arr[k]
                k+=1
        a = Solution().matrixDiagonally(matrix)
        for x in a:
            print(x,end=' ')
        print('')
# Contributed by: Harshit Sidhwa
# } Driver Code Ends


================================================================================
Date: 2024-03-14
Problem: Largest subsquare surrounded by X
Filename: 2024-03-14_Largest_subsquare_surrounded_by_X.py
================================================================================

# User function Template for python3
class Solution:
    def largestSubsquare(self, n, a):
        v1 = [[0 for _ in range(n)] for _ in range(n)]
        v2 = [[0 for _ in range(n)] for _ in range(n)]

        # col
        for i in range(n):
            sum_val = 0
            for j in range(n - 1, -1, -1):
                if a[i][j] == 'O':
                    sum_val = 0
                    v1[i][j] = 0
                else:
                    sum_val += 1
                    v1[i][j] = sum_val

        # rows
        maxi = 10002
        for j in range(n):
            sum_val = 0
            for i in range(n - 1, -1, -1):
                if a[i][j] == 'O':
                    sum_val = 0
                else:
                    sum_val += 1
                    v2[i][j] = sum_val

        # finding max submatrix
        ans = 0
        for i in range(n):
            for j in range(n):
                if a[i][j] == 'O':
                    continue

                size = min(v1[i][j], v2[i][j])

                while size > ans:
                    if v1[i + size - 1][j] >= size and v2[i][j + size - 1] >= size:
                        ans = size

                    size -= 1
        return ans
 # Driver Code Starts
#Initial Template for Python 3

import math
        
if __name__=='__main__':
    t=int(input())
    for _ in range(t):
        n=int(input())
        a=[]
        for i in range(n):
            s=list(map(str,input().strip().split()))
            a.append(s)
        ob=Solution()
        print(ob.largestSubsquare(n,a))
# } Driver Code Ends


================================================================================
Date: 2024-03-15
Problem: Linked List that is Sorted Alternatingly
Filename: 2024-03-15_Linked_List_that_is_Sorted_Alternatingly.py
================================================================================

#User function Template for python3
class Node:
    def __init__(self,data):
        self.data=data
        self.next=None
        
class Solution:
    def mergeSort(self, head):
        if head is None or head.next is None:
            return head
        
        mid = self.findMiddle(head)
        nextToMid = mid.next
        mid.next = None
        
        left = self.mergeSort(head)
        right = self.mergeSort(nextToMid)
        
        return self.merge(left, right)
    
    def merge(self, left, right):
        if left is None:
            return right
        if right is None:
            return left
        
        result = None
        if left.data <= right.data:
            result = left
            result.next = self.merge(left.next, right)
        else:
            result = right
            result.next = self.merge(left, right.next)
        
        return result
    
    def findMiddle(self, head):
        if head is None:
            return None
        
        slow = head
        fast = head.next
        
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        
        return slow
    
    def sort(self, head):
        return self.mergeSort(head)

#Initial Template for Python 3

class Llist:
    def __init__(self):
        self.head=None
    
    def insert(self,data,tail):
        node=Node(data)
        
        if not self.head:
            self.head=node
            return node
        
        tail.next=node
        return node

def printList(head):
    while head:
        print(head.data,end=' ')
        head=head.next

 # Driver Code Starts
#Initial Template for Python 3

class Llist:
    def __init__(self):
        self.head=None
    
    def insert(self,data,tail):
        node=Node(data)
        
        if not self.head:
            self.head=node
            return node
        
        tail.next=node
        return node
        

def printList(head):
    while head:
        print(head.data,end=' ')
        head=head.next
        
if __name__ == '__main__':
    t=int(input())
    
    for tcs in range(t):
        
        n1=int(input())
        arr1=[int(x) for x in input().split()]
        ll1=Llist()
        tail=None
        for nodeData in arr1:
            tail=ll1.insert(nodeData,tail)
            
        
        ob = Solution()
        resHead=ob.sort(ll1.head)
        printList(resHead)
        print()
        
    
    
# } Driver Code Ends


================================================================================
Date: 2024-03-16
Problem: Delete Node without Head Pointer
Filename: 2024-03-16_Delete_Node_without_Head_Pointer.py
================================================================================

#User function Template for python3
#User function Template for python3
'''
Your task is to delete the given node from
the linked list, without using head pointer.

Function Arguments: node (given node to be deleted) 
Return Type: None, just delete the given node from the linked list.

{
    # Node Class
    class Node:
        def __init__(self, data):   # data -> value stored in node
            self.data = data
            self.next = None
}
'''
class Solution:
    #Function to delete a node without any reference to head pointer.
    def deleteNode(self,del_node):
        temp = del_node.next
        del_node.data = temp.data
        del_node.next = temp.next
        temp = None

 # Driver Code Starts
#Initial Template for Python 3
#Contributed by : Nagendra Jha

import atexit
import io
import sys
sys.setrecursionlimit(5000)
_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__
_OUTPUT_BUFFER = io.StringIO()
sys.stdout = _OUTPUT_BUFFER

@atexit.register

def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())
    
# Node Class
class Node:
    def __init__(self, data):   # data -> value stored in node
        self.data = data
        self.next = None

# Linked List Class
class LinkedList:
    def __init__(self):
        self.head = None
        self.tail = None

    # creates a new node with given value and appends it at the end of the linked list
    def append(self, new_value):
        new_node = Node(new_value)
        if self.head is None:
            self.head = new_node
            self.tail =new_node
            return
        self.tail.next=new_node
        self.tail=new_node

    def getNode(self,value): # return node with given value, if not present return None
        curr_node=self.head
        while(curr_node.next and curr_node.data != value):
            curr_node=curr_node.next
        if(curr_node.data==value):
            return curr_node
        else:
            return None

    # prints the elements of linked list starting with head
    def printList(self):
        if self.head is None:
            print(' ')
            return
        curr_node = self.head
        while curr_node:
            print(curr_node.data,end=" ")
            curr_node=curr_node.next
        print()

if __name__ == '__main__':
    t=int(input())
    for cases in range(t):
        n = int(input())
        a = LinkedList() # create a new linked list 'a'.
        nodes = list(map(int, input().strip().split()))
        for x in nodes:
            a.append(x)
        del_elem = int(input())
        del_node=a.getNode(del_elem)
        Solution().deleteNode(del_node)
        a.printList()
# } Driver Code Ends


================================================================================
Date: 2024-03-17
Problem: Count Pairs whose sum is equal to X
Filename: 2024-03-17_Count_Pairs_whose_sum_is_equal_to_X.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3

#contributed by RavinderSinghPB
# Node Class
class Node:
    def __init__(self, data):   # data -> value stored in node
        self.data = data
        self.next = None

# Linked List Class
class LinkedList:
    def __init__(self):
        self.head = None
        self.tail = None

    # creates a new node with given value and appends it at the end of the linked list
    def append(self, new_value):
        new_node = Node(new_value)
        if self.head is None:
            self.head = new_node
        else:
            self.tail.next = new_node
        self.tail = new_node
    
        


# } Driver Code Ends
#User function Template for python3

'''
class Node:
    def __init__(self, data):   # data -> value stored in node
        self.data = data
        self.next = None
'''
class Solution:
    def countPair(self, head1, head2, n1, n2, x):
        set1 = set()
        count = 0

        # Populate set1 with the elements of the first linked list
        temp = head1
        while temp:
            set1.add(temp.data)
            temp = temp.next

        # Traverse the second linked list and check for complements
        temp = head2
        while temp:
            complement = x - temp.data
            if complement in set1:
                count += 1
            temp = temp.next

        return count
#{ 
 # Driver Code Starts.
if __name__ == '__main__':
    t=int(input())
    for cases in range(t):
        
        n1=int(input())
        ll1 = LinkedList() # create a new linked list 'll1'.
        nodes_ll1 = list(map(int, input().strip().split()))
        for nodes in nodes_ll1:
            ll1.append(nodes)  # add to the end of the list
        
        n2=int(input())
        ll2=LinkedList()  #create a new linked list 'll1'.
        nodes_ll2 = list(map(int, input().strip().split()))
        for nodes in nodes_ll2:
            ll2.append(nodes)  # add to the end of the list
        
        x=int(input())
        
        
        print(Solution().countPair(ll1.head,ll2.head,n1,n2,x))


# } Driver Code Ends


================================================================================
Date: 2024-03-18
Problem: Level order traversal
Filename: 2024-03-18_Level_order_traversal.py
================================================================================

#User function Template for python3
from collections import deque

class Solution:
    #Function to return the level order traversal of a tree.
    def levelOrder(self, root):
        result = []
        if not root:
            return result
        
        q = deque([root])
        
        while q:
            level_size = len(q)
            
            for _ in range(level_size):
                node = q.popleft()
                result.append(node.data)
                
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
        
        return result
 # Driver Code Starts
#Initial Template for Python 3

#Contributed by Sudarshan Sharma
from collections import deque
# Tree Node
class Node:
    def _init_(self, val):
        self.right = None
        self.data = val
        self.left = None

# Function to Build Tree   
def buildTree(s):
    #Corner Case
    if(len(s)==0 or s[0]=="N"):           
        return None
        
    # Creating list of strings from input 
    # string after spliting by space
    ip=list(map(str,s.split()))
    
    # Create the root of the tree
    root=Node(int(ip[0]))                     
    size=0
    q=deque()
    
    # Push the root to the queue
    q.append(root)                            
    size=size+1 
    
    # Starting from the second element
    i=1                                       
    while(size>0 and i<len(ip)):
        # Get and remove the front of the queue
        currNode=q[0]
        q.popleft()
        size=size-1
        
        # Get the current node's value from the string
        currVal=ip[i]
        
        # If the left child is not null
        if(currVal!="N"):
            
            # Create the left child for the current node
            currNode.left=Node(int(currVal))
            
            # Push it to the queue
            q.append(currNode.left)
            size=size+1
        # For the right child
        i=i+1
        if(i>=len(ip)):
            break
        currVal=ip[i]
        
        # If the right child is not null
        if(currVal!="N"):
            
            # Create the right child for the current node
            currNode.right=Node(int(currVal))
            
            # Push it to the queue
            q.append(currNode.right)
            size=size+1
        i=i+1
    return root
    
    
if _name=="main_":
    t=int(input())
    for _ in range(0,t):
        s=input()
        root=buildTree(s)
        res = Solution().levelOrder(root)
        for i in res:
            print (i, end = " ")
        print()



# } DriverCodeEnds


================================================================================
Date: 2024-03-19
Problem: Possible Paths in a Tree
Filename: 2024-03-19_Possible_Paths_in_a_Tree.py
================================================================================

#User function Template for python3

class Solution:
    def root(self, i, parent):
        while parent[i] != i:
            parent[i] = parent[parent[i]]
            i = parent[i]
        return i

    def Union(self, a, b, parent, sz):
        ra = self.root(a, parent)
        rb = self.root(b, parent)
        if ra == rb:
            return sz[ra] * sz[ra]
        if sz[ra] < sz[rb]:
            ra, rb = rb, ra
        self.ans += sz[ra] * sz[rb]
        parent[rb] = ra
        sz[ra] += sz[rb]
        return self.ans

    def maximumWeight(self, n, edges, q, queries):
        self.ans = 0
        parent = [i for i in range(n + 1)]
        sz = [1] * (n + 1)
        res = []
        edges.sort(key=lambda x: x[2])
        mp = {}
        for edge in edges:
            a, b, c = edge
            mp[c] = self.Union(a, b, parent, sz)
        for query in queries:
            val = max(filter(lambda x: x <= query, mp.keys()), default=None)
            if val is None:
                res.append(0)
            else:
                res.append(mp[val])
        return res

        



#{ 
 # Driver Code Starts
#Initial Template for Python 3

if _name_ == '_main_': 
    t = int(input())
    for _ in range(t):
        n = int(input())

        edges = [[0 for j in range(3)] for i in range(n-1)]
        for i in range(n-1):
            input_line = [int(x) for x in input().strip().split()]       
            for j in range (3):
                edges[i][j]=input_line[j]

        q = int(input())
        queries = list(map(int, input().strip().split()))

        ob = Solution()
        ans = ob.maximumWeight(n, edges, q, queries)
        for i in ans:
            print(i,end=" ")
        print()


# } DriverCodeEnds


================================================================================
Date: 2024-03-20
Problem: Sum of nodes on the longest path from root to leaf node
Filename: 2024-03-20_Sum_of_nodes_on_the_longest_path_from_root_to_leaf_node.py
================================================================================

#User function Template for python3

'''
class Node:
    def __init__(self,val):
        self.data=val
        self.left=None
        self.right=None
'''
class Solution:
    def solve(self, root, len, maxLen, sum, maxSum):
        if root is None:
            if len > maxLen[0]:
                maxLen[0] = len
                maxSum[0] = sum
            elif len == maxLen[0]:
                maxSum[0] = max(sum, maxSum[0])
            return
        
        sum += root.data
        
        self.solve(root.left, len + 1, maxLen, sum, maxSum)
        self.solve(root.right, len + 1, maxLen, sum, maxSum)
    
    def sumOfLongRootToLeafPath(self, root):
        if root is None:
            return 0
        
        len = 0
        maxLen = [0]
        sum = 0
        maxSum = [0]
        
        self.solve(root, len, maxLen, sum, maxSum)
        
        return maxSum[0]

#{ 
 # Driver Code Starts
#Initial Template for Python 3

from collections import deque
class Node:
    def __init__(self,val):
        self.data=val
        self.left=None
        self.right=None
        
def buildTree(s):
    #Corner Case
    if(len(s)==0 or s[0]=="N"):           
        return None
        
    # Creating list of strings from input 
    # string after spliting by space
    ip=list(map(str,s.split()))
    
    # Create the root of the tree
    root=Node(int(ip[0]))                     
    size=0
    q=deque()
    
    # Push the root to the queue
    q.append(root)                            
    size=size+1 
    
    # Starting from the second element
    i=1                                       
    while(size>0 and i<len(ip)):
        # Get and remove the front of the queue
        currNode=q[0]
        q.popleft()
        size=size-1
        
        # Get the current node's value from the string
        currVal=ip[i]
        
        # If the left child is not null
        if(currVal!="N"):
            
            # Create the left child for the current node
            currNode.left=Node(int(currVal))
            
            # Push it to the queue
            q.append(currNode.left)
            size=size+1
        # For the right child
        i=i+1
        if(i>=len(ip)):
            break
        currVal=ip[i]
        
        # If the right child is not null
        if(currVal!="N"):
            
            # Create the right child for the current node
            currNode.right=Node(int(currVal))
            
            # Push it to the queue
            q.append(currNode.right)
            size=size+1
        i=i+1
    return root

if __name__ == '__main__':
    test_cases = int(input())
    for cases in range(test_cases):
        s=input()
        root=buildTree(s)
        ob = Solution()
        res = ob.sumOfLongRootToLeafPath(root)
        print(res)
# } Driver Code Ends


================================================================================
Date: 2024-03-21
Problem: ZigZag Tree Traversal
Filename: 2024-03-21_ZigZag_Tree_Traversal.py
================================================================================

#User function Template for python3

'''
class Node:
    def __init__(self,val):
        self.data = val
        self.left = None
        self.right = None
'''


class Solution:
    def zigZagTraversal(self, root):
        ans = []

        if root is None:
            return ans

        left_to_right = True
        q = deque()
        q.append(root)

        while q:
            size = len(q)
            res = deque()

            for _ in range(size):
                front_node = q.popleft()

                if left_to_right:
                    res.append(front_node.data)
                else:
                    res.appendleft(front_node.data)

                if front_node.left:
                    q.append(front_node.left)

                if front_node.right:
                    q.append(front_node.right)

            ans.extend(res)
            left_to_right = not left_to_right

        return ans



#{ 
 # Driver Code Starts
#Initial Template for Python 3

#contributed by RavinderSinghPB

from collections import defaultdict
from collections import deque

class Node:
    def __init__(self,val):
        self.data = val
        self.left = None
        self.right = None
        
# Function to Build Tree   
def buildTree(s):
    #Corner Case
    if(len(s)==0 or s[0]=="N"):           
        return None
        
    # Creating list of strings from input 
    # string after spliting by space
    ip=list(map(str,s.split()))
    
    # Create the root of the tree
    root=Node(int(ip[0]))                     
    size=0
    q=deque()
    
    # Push the root to the queue
    q.append(root)                            
    size=size+1 
    
    # Starting from the second element
    i=1                                       
    while(size>0 and i<len(ip)):
        # Get and remove the front of the queue
        currNode=q[0]
        q.popleft()
        size=size-1
        
        # Get the current node's value from the string
        currVal=ip[i]
        
        # If the left child is not null
        if(currVal!="N"):
            
            # Create the left child for the current node
            currNode.left=Node(int(currVal))
            
            # Push it to the queue
            q.append(currNode.left)
            size=size+1
        # For the right child
        i=i+1
        if(i>=len(ip)):
            break
        currVal=ip[i]
        
        # If the right child is not null
        if(currVal!="N"):
            
            # Create the right child for the current node
            currNode.right=Node(int(currVal))
            
            # Push it to the queue
            q.append(currNode.right)
            size=size+1
        i=i+1
    return root
    
if __name__ == '__main__':
    t=int(input())
    for _ in range(0,t):
        s=input()
        root=buildTree(s)
        ob = Solution()
        res = ob.zigZagTraversal(root)
        for i in range (len (res)):
            print (res[i], end = " ")
        print()
# } Driver Code Ends


================================================================================
Date: 2024-03-22
Problem: Diagonal sum in binary tree
Filename: 2024-03-22_Diagonal_sum_in_binary_tree.py
================================================================================

#User function Template for python3



'''

# Node Class:
class Node:

    def __init__(self,val):
        self.data = val
        self.left = None
        self.right = None

'''



class Solution:
    def diagonalSum(self, root):
        result = []
        if root is None:
            return result
        queue = deque()
        queue.append(root)
        while queue:
            size = len(queue)
            sum = 0
            for _ in range(size):
                node = queue.popleft()
                while node:
                    if node.left:
                        queue.append(node.left)
                    sum += node.data
                    node = node.right
            result.append(sum)
        return result

#{ 

 # Driver Code Starts
#Initial Template for Python 3
#Contributed by Sudarshan Sharma
from collections import deque
# Tree Node

class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None

# Function to Build Tree   

def buildTree(s):
    #Corner Case
    if(len(s)==0 or s[0]=="N"):           
        return None

    # Creating list of strings from input 

    # string after spliting by space
    ip=list(map(str,s.split()))

    # Create the root of the tree

    root=Node(int(ip[0]))                     
    size=0
    q=deque()
    # Push the root to the queue

    q.append(root)                            
    size=size+1 

    # Starting from the second element
    i=1                                       
    while(size>0 and i<len(ip)):

        # Get and remove the front of the queue

        currNode=q[0]
        q.popleft()
        size=size-1        

        # Get the current node's value from the string
        currVal=ip[i]
        # If the left child is not null
        if(currVal!="N"):

            # Create the left child for the current node
            currNode.left=Node(int(currVal))

            # Push it to the queue
            q.append(currNode.left)
            size=size+1

        # For the right child

        i=i+1
        if(i>=len(ip)):
            break
        currVal=ip[i]

        

        # If the right child is not null
        if(currVal!="N"):

            

            # Create the right child for the current node

            currNode.right=Node(int(currVal))
            # Push it to the queue
            q.append(currNode.right)
            size=size+1
        i=i+1
    return root    

if __name__=="__main__":

    t=int(input())
    for _ in range(0,t):
        s=input()
        root=buildTree(s)
        ob = Solution()
        res = ob.diagonalSum(root)
        for i in res:
            print (i, end = " ")
        print()
# } Driver Code Ends


================================================================================
Date: 2024-03-23
Problem: Fibonacci series up to Nth term
Filename: 2024-03-23_Fibonacci_series_up_to_Nth_term.py
================================================================================

#User function Template for python3

class Solution:
    def series(self, n):
        MOD = 10**9 + 7
        ans = []
        if n == 0:
            return ans  # Handle edge case
        
        prev, cur = 0, 1
        ans.append(prev)
        ans.append(cur)
        
        for i in range(2, n + 1):
            next_val = (prev + cur) % MOD
            ans.append(next_val)
            prev, cur = cur, next_val
        
        return ans


#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        N = int(input())
        ob = Solution()
        result = ob.series(N)
        print(*result)
# } Driver Code Ends


================================================================================
Date: 2024-03-24
Problem: Insert an Element at the Bottom of a Stack
Filename: 2024-03-24_Insert_an_Element_at_the_Bottom_of_a_Stack.py
================================================================================

#User function Template for python3
class Solution:
    def insertAtBottom(self, st, x):
        tmp = []
        
        while st:
            tmp.append(st.pop())
        
        st.append(x)
        
        while tmp:
            st.append(tmp.pop())
        
        return st
        

#{ 
 # Driver Code Starts

if __name__ == "__main__":
    for _ in range(int(input())):
        n,x = map(int,input().split())
        stack = list(map(int,input().split()))
        obj = Solution()
        ans = obj.insertAtBottom(stack,x)
        for e in ans:
            print(e,end=" ")
        print()
        
        
        
# } Driver Code Ends


================================================================================
Date: 2024-03-25
Problem: Print N-bit binary numbers having more 1s than 0s
Filename: 2024-03-25_Print_N-bit_binary_numbers_having_more_1s_than_0s.py
================================================================================

#User function Template for python3


#User function Template for python3
class Solution:
    def NBitBinary(self, n):
        out = ""
        li = []
        on=ze=0;
        def util(out,on,ze,n):
           if n==0:
             li.append(out)
             return
           if on==ze:
              util(out+"1",on+1,ze,n-1)
           if on>ze:
              util(out+"1",on+1,ze,n-1)
              util(out+"0",on,ze+1,n-1)
        util(out,on,ze,n)    
        return li

#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
	T=int(input())
	for i in range(T):
		n = int(input())
		ob = Solution()	
		answer = ob.NBitBinary(n)
		for value in answer:
			print(value,end=" ")
		print()


# } Driver Code Ends


================================================================================
Date: 2024-03-26
Problem: Additive sequence
Filename: 2024-03-26_Additive_sequence.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3

# } Driver Code Ends
#User function Template for python3
# User function Template for python3

class Solution:
    def isAdditiveSequence(self, n):
        size = len(n)
        
        for j in range(min(10, size - 2)):
            prev1 = int(n[:j + 1])
            
            for k in range(j + 1, min(10, size - 1)):
                prev2 = int(n[j + 1:k + 1])
                
                f = 0
                i = k + 1
                while i < size:
                    sum_ = prev1 + prev2
                    sum_size = len(str(sum_))
                    if i + sum_size - 1 >= size:
                        f = 1
                        break
                    num = int(n[i:i + sum_size])
                    if num != sum_:
                        f = 1
                        break
                    prev1, prev2 = prev2, num
                    i += sum_size
                
                if not f:
                    return 1
        
        return 0

# Driver Code Starts.

if _name_ == "_main_":
    sol = Solution()
    t = int(input())
    for _ in range(t):
        s = input()
        print(sol.isAdditiveSequence(s))

# Driver Code Ends

# return 1 in case of True and 0 incaseofFalse


================================================================================
Date: 2024-03-27
Problem: Find shortest safe route in a matrix
Filename: 2024-03-27_Find_shortest_safe_route_in_a_matrix.py
================================================================================

// This code is working in Some Scenario Mine is working (1115/1115) But in Some I have Received Feedbacks That it is having (1114/1115) So Not Sure of Working...
from typing import List

class Solution:
    def findShortestPath(self, mat: List[List[int]]) -> int:
        m = len(mat)
        n = len(mat[0])
        visited = [[0] * n for _ in range(m)]
        vis = [[False] * n for _ in range(m)]
        
        for i in range(m):
            for j in range(n):
                if mat[i][j] == 0 and not vis[i][j]:
                    vis[i][j] = True
                    if i + 1 < m:
                        mat[i + 1][j] = 0
                        vis[i + 1][j] = True
                    if i - 1 >= 0:
                        mat[i - 1][j] = 0
                        vis[i - 1][j] = True
                    if j + 1 < n:
                        mat[i][j + 1] = 0
                        vis[i][j + 1] = True
                    if j - 1 >= 0:
                        mat[i][j - 1] = 0
                        vis[i][j - 1] = True
        
        arr = [float('inf')]
        
        for i in range(m):
            self.dfs(i, 0, mat, visited, 1, arr)
        
        if arr[0] == float('inf'):
            return -1
        return arr[0]
    
    def dfs(self, r, c, mat, visited, count, arr):
        if mat[r][c] == 0:
            return
        if c == len(mat[0]) - 1:
            if count < arr[0]:
                arr[0] = count
            return
        
        visited[r][c] = 1
        
        if r + 1 < len(mat) and mat[r + 1][c] == 1 and visited[r + 1][c] == 0:
            self.dfs(r + 1, c, mat, visited, count + 1, arr)
        if c + 1 < len(mat[0]) and mat[r][c + 1] == 1 and visited[r][c + 1] == 0:
            self.dfs(r, c + 1, mat, visited, count + 1, arr)
        if r - 1 >= 0 and mat[r - 1][c] == 1 and visited[r - 1][c] == 0:
            self.dfs(r - 1, c, mat, visited, count + 1, arr)
        if c - 1 >= 0 and mat[r][c - 1] == 1 and visited[r][c - 1] == 0:
            self.dfs(r, c - 1, mat, visited, count + 1, arr)
        
        visited[r][c] = 0

#{ 
 # Driver Code Starts
class IntArray:
    def __init__(self) -> None:
        pass
    def Input(self,n):
        arr=[int(i) for i in input().strip().split()]#array input
        return arr
    def Print(self,arr):
        for i in arr:
            print(i,end=" ")
        print()



class IntMatrix:
    def __init__(self) -> None:
        pass
    def Input(self,n,m):
        matrix=[]
        #matrix input
        for _ in range(n):
            matrix.append([int(i) for i in input().strip().split()])
        return matrix
    def Print(self,arr):
        for i in arr:
            for j in i:
                print(j,end=" ")
            print()


if __name__=="__main__":
    t = int(input())
    for _ in range(t):
        
        a=IntArray().Input(2)
        
        
        mat=IntMatrix().Input(a[0], a[1])
        
        obj = Solution()
        res = obj.findShortestPath(mat)
        
        print(res)
        

# } Driver Code Ends


================================================================================
Date: 2024-03-28
Problem: City With the Smallest Number of Neighbors at a Threshold Distance
Filename: 2024-03-28_City_With_the_Smallest_Number_of_Neighbors_at_a_Threshold_Distance.py
================================================================================

#User function Template for python3

from typing import List
import heapq

class Solution:
    def findCity(self, n: int, m: int, edges: List[List[int]], distanceThreshold: int) -> int:
        adj = [[] for _ in range(n)]
        for u, v, w in edges:
            adj[u].append((v, w))
            adj[v].append((u, w))
        
        def dijkstra(src):
            dist = [float('inf')] * n
            dist[src] = 0
            heap = [(0, src)]
            while heap:
                d, u = heapq.heappop(heap)
                if d > dist[u]:
                    continue
                for v, w in adj[u]:
                    if dist[u] + w < dist[v]:
                        dist[v] = dist[u] + w
                        heapq.heappush(heap, (dist[v], v))
            return dist
        
        minCity = n
        ans = -1
        for i in range(n):
            count = sum(1 for d in dijkstra(i) if d <= distanceThreshold)
            if count <= minCity:
                minCity = count
                ans = i
        return ans


#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    T = int(input())
    for t in range(T):
        
        n, m = map(int, input().strip().split())
        edges = []
        for i in range(m):
            u, v, wt = map(int, input().strip().split())
            edges.append([u, v, wt])
        distanceThreshold = int(input())
        obj = Solution()
        ans = obj.findCity(n, m, edges, distanceThreshold)
        print(ans)
            

# } Driver Code Ends


================================================================================
Date: 2024-03-29
Problem: Euler Circuit in an Undirected Graph
Filename: 2024-03-29_Euler_Circuit_in_an_Undirected_Graph.py
================================================================================

#User function Template for python3

class Solution:
    def isEularCircuitExist(self, v, adj):
        return all(len(neighbors) % 2 == 0 for neighbors in adj)


 # Driver Code Starts
#Initial Template for python3

if __name__ == '__main__':
	T=int(input())
	for i in range(T):
		V, E = map(int, input().split())
		adj = [[] for i in range(V)]
		for _ in range(E):
			u, v = map(int, input().split())
			adj[u].append(v)
			adj[v].append(u)
		obj = Solution()
		ans = obj.isEularCircuitExist(V, adj)
		if(ans):
			print("1")
		else:
			print("0")

# } Driver Code Ends


================================================================================
Date: 2024-03-30
Problem: Minimum element in BST
Filename: 2024-03-30_Minimum_element_in_BST.py
================================================================================

#User function Template for python3

"""
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None
"""

class Solution:
    def minValue(self, root):
        if root is None:
            return float('inf')

        minVal = float('inf')
        stack = []

        while root or stack:
            while root:
                stack.append(root)
                root = root.left
            root = stack.pop()
            minVal = min(minVal, root.data)
            root = root.right

        return minVal
 # Driver Code Starts

#Initial Template for Python 3

from collections import deque
# Tree Node
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None

# Function to Build Tree   
def buildTree(s):
    #Corner Case
    if(len(s)==0 or s[0]=="N"):           
        return None
        
    # Creating list of strings from input 
    # string after spliting by space
    ip=list(map(str,s.split()))
    
    # Create the root of the tree
    root=Node(int(ip[0]))                     
    size=0
    q=deque()
    
    # Push the root to the queue
    q.append(root)                            
    size=size+1 
    
    # Starting from the second element
    i=1                                       
    while(size>0 and i<len(ip)):
        # Get and remove the front of the queue
        currNode=q[0]
        q.popleft()
        size=size-1
        
        # Get the current node's value from the string
        currVal=ip[i]
        
        # If the left child is not null
        if(currVal!="N"):
            
            # Create the left child for the current node
            currNode.left=Node(int(currVal))
            
            # Push it to the queue
            q.append(currNode.left)
            size=size+1
        # For the right child
        i=i+1
        if(i>=len(ip)):
            break
        currVal=ip[i]
        
        # If the right child is not null
        if(currVal!="N"):
            
            # Create the right child for the current node
            currNode.right=Node(int(currVal))
            
            # Push it to the queue
            q.append(currNode.right)
            size=size+1
        i=i+1
    return root
    
    
if __name__=="__main__":
    t=int(input())
    for _ in range(0,t):
        s=input()
        root=buildTree(s)
        ob = Solution()
        print(ob.minValue(root))
# } Driver Code Ends


================================================================================
Date: 2024-03-31
Problem: Closest Neighbour in BST
Filename: 2024-03-31_Closest_Neighbour_in_BST.py
================================================================================

#User function Template for python3


'''
class Node:
    """ Class Node """
    def __init__(self, value):
        self.left = None
        self.key = value
        self.right = None
'''

class Solution:
    def findMaxForN(self, root, n):
        maxVal = -1
        while root:
            if root.key <= n:
                maxVal = max(maxVal, root.key)
                root = root.right
            else:
                root = root.left
        return maxVal

 # Driver Code Starts
#Initial Template for Python 3

from collections import deque


# Tree Node
class Node:

    def __init__(self, val):
        self.right = None
        self.key = val
        self.left = None


# Function to Build Tree
def buildTree(s):
    #Corner Case
    if (len(s) == 0 or s[0] == "N"):
        return None

    # Creating list of strings from input
    # string after spliting by space
    ip = list(map(str, s.split()))

    # Create the root of the tree
    root = Node(int(ip[0]))
    size = 0
    q = deque()

    # Push the root to the queue
    q.append(root)
    size = size + 1

    # Starting from the second element
    i = 1
    while (size > 0 and i < len(ip)):
        # Get and remove the front of the queue
        currNode = q[0]
        q.popleft()
        size = size - 1

        # Get the current node's value from the string
        currVal = ip[i]

        # If the left child is not null
        if (currVal != "N"):

            # Create the left child for the current node
            currNode.left = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.left)
            size = size + 1
        # For the right child
        i = i + 1
        if (i >= len(ip)):
            break
        currVal = ip[i]

        # If the right child is not null
        if (currVal != "N"):

            # Create the right child for the current node
            currNode.right = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.right)
            size = size + 1
        i = i + 1
    return root


if __name__ == "__main__":
    t = int(input())
    for _ in range(0, t):
        s = input()
        root = buildTree(s)
        n = int(input())
        ob = Solution()
        print(ob.findMaxForN(root, n))

# } Driver Code Ends


================================================================================
Date: 2024-04-01
Problem: Pairs violating the BST property
Filename: 2024-04-01_Pairs_violating_the_BST_property.py
================================================================================


from typing import Optional
from collections import deque
"""

definition of binary tree node.
class Node:
    def _init_(self,val):
        self.data = val
        self.left = None
        self.right = None
"""

class Solution:
    def pairsViolatingBST(self, n: int, root: Optional['Node']) -> int:
        inorder_traversal = []
        self.inorder(root, inorder_traversal)
        temp = [0] * n
        return self.merge_sort(0, n - 1, inorder_traversal, temp)

    def inorder(self, root, inorder_traversal):
        if root:
            self.inorder(root.left, inorder_traversal)
            inorder_traversal.append(root.data)
            self.inorder(root.right, inorder_traversal)

    def merge(self, low, mid, high, arr, output):
        i = low
        j = mid + 1
        k = low
        inversions = 0

        while i <= mid and j <= high:
            if arr[i] <= arr[j]:
                output[k] = arr[i]
                i += 1
            else:
                output[k] = arr[j]
                j += 1
                inversions += (mid - i + 1)
            k += 1

        while i <= mid:
            output[k] = arr[i]
            i += 1
            k += 1
        while j <= high:
            output[k] = arr[j]
            j += 1
            k += 1

        for i in range(low, high + 1):
            arr[i] = output[i]

        return inversions

    def merge_sort(self, low, high, arr, output):
        inversions = 0

        if low < high:
            mid = (low + high) // 2

            inversions += self.merge_sort(low, mid, arr, output)
            inversions += self.merge_sort(mid + 1, high, arr, output)
            inversions += self.merge(low, mid, high, arr, output)

        return inversions




#{ 
 # Driver Code Starts

class Node:
    def __init__(self,val):
        self.data=val
        self.right=None
        self.left=None

# Function to Build Tree
def buildTree(s):
    #Corner Case
    if(len(s)==0 or s[0]=="N"):
        return None

    # Creating list of strings from input
    # string after spliting by space
    ip=list(map(str,s.split()))

    # Create the root of the tree
    root=Node(int(ip[0]))
    size=0
    q=deque()

    # Push the root to the queue
    q.append(root)
    size=size+1

    # Starting from the second element
    i=1
    while(size>0 and i<len(ip)):
        # Get and remove the front of the queue
        currNode=q[0]
        q.popleft()
        size=size-1

        # Get the current node's value from the string
        currVal=ip[i]

        # If the left child is not null
        if(currVal!="N"):

            # Create the left child for the current node
            currNode.left=Node(int(currVal))

            # Push it to the queue
            q.append(currNode.left)
            size=size+1
        # For the right child
        i=i+1
        if(i>=len(ip)):
            break
        currVal=ip[i]

        # If the right child is not null
        if(currVal!="N"):

            # Create the right child for the current node
            currNode.right=Node(int(currVal))

            # Push it to the queue
            q.append(currNode.right)
            size=size+1
        i=i+1
    return root

def inputTree():
    treeString=input().strip()
    root = buildTree(treeString)
    return root
def inorder(root):
    if (root == None):
       return
    inorder(root.left);
    print(root.data,end=" ")
    inorder(root.right)

if __name__=="__main__":
    t = int(input())
    for _ in range(t):
        
        n = int(input())
        
        
        root = inputTree();
        
        obj = Solution()
        res = obj.pairsViolatingBST(n, root)
        
        print(res)
        

# } Driver Code Ends


================================================================================
Date: 2024-04-02
Problem: Minimum Absolute Difference In BST
Filename: 2024-04-02_Minimum_Absolute_Difference_In_BST.py
================================================================================

# class Node:
#     def _init_(self):
#         self.data = None
#         self.left = None
#         self.right = None
        
class Solution:
    def inorder(self, root, prev, minDiff):
        if not root:
            return
        self.inorder(root.left, prev, minDiff)
        if prev[0] != float('inf'):
            minDiff[0] = min(minDiff[0], root.data - prev[0])
        prev[0] = root.data
        self.inorder(root.right, prev, minDiff)

    def absolute_diff(self, root):
        minDiff = [float('inf')]
        prev = [float('inf')]
        self.inorder(root, prev, minDiff)
        return minDiff[0]
        


#{ 
 # Driver Code Starts

from collections import deque

class Node:
    def _init_(self, data):
        self.data = data
        self.left = None
        self.right = None

# Function to Build Tree
def buildTree(str):
    # Corner Case
    if len(str) == 0 or str[0] == 'N':
        return None

    # Creating list of strings from input string after splitting by space
    ip = str.split()

    # Create the root of the tree
    root = Node(int(ip[0]))

    # Push the root to the queue
    queue = deque()
    queue.append(root)

    # Starting from the second element
    i = 1
    while queue and i < len(ip):
        # Get and remove the front of the queue
        currNode = queue.popleft()

        # Get the current node's value from the string
        currVal = ip[i]

        # If the left child is not null
        if currVal != "N":
            # Create the left child for the current node
            currNode.left = Node(int(currVal))

            # Push it to the queue
            queue.append(currNode.left)

        # For the right child
        i += 1
        if i >= len(ip):
            break
        currVal = ip[i]

        # If the right child is not null
        if currVal != "N":
            # Create the right child for the current node
            currNode.right = Node(int(currVal))

            # Push it to the queue
            queue.append(currNode.right)

        i += 1

    return root

for _ in range(int(input())):
    s = input()
    root = buildTree(s)
    if root is None:
        continue
    if root.left is None and root.right is None:
        continue
    
    ob = Solution()
    print(ob.absolute_diff(root))

# } DriverCodeEnds


================================================================================
Date: 2024-04-03
Problem: Kth common ancestor in BST
Filename: 2024-04-03_Kth_common_ancestor_in_BST.py
================================================================================

#User function Template for python3

'''
class Node:
    def _init_(self, data):
        self.data = data
        self.left = None
        self.right = None
'''

class Solution:
    def findLowestCommonAncestor(self, root, x, y):
        if root is None:
            return None
        if x < root.data and y < root.data:
            return self.findLowestCommonAncestor(root.left, x, y)
        if x > root.data and y > root.data:
            return self.findLowestCommonAncestor(root.right, x, y)
        return root
    
    def findPathToNode(self, root, node, path):
        path.append(root.data)
        if root.data == node.data:
            return
        elif node.data > root.data:
            self.findPathToNode(root.right, node, path)
        else:
            self.findPathToNode(root.left, node, path)
    
    def kthCommonAncestor(self, root, k, x, y):
        lca = self.findLowestCommonAncestor(root, x, y)
        path = []
        self.findPathToNode(root, lca, path)
        path.reverse()
        if len(path) < k:
            return -1
        return path[k - 1]


 # Driver Code Starts

#Initial Template for Python 3


from collections import deque

class Node:
    def _init_(self, data):
        self.data = data
        self.left = None
        self.right = None

# Function to Build Tree
def buildTree(str):
    # Corner Case
    if len(str) == 0 or str[0] == 'N':
        return None

    # Creating list of strings from input string after splitting by space
    ip = str.split()

    # Create the root of the tree
    root = Node(int(ip[0]))

    # Push the root to the queue
    queue = deque()
    queue.append(root)

    # Starting from the second element
    i = 1
    while queue and i < len(ip):
        # Get and remove the front of the queue
        currNode = queue.popleft()

        # Get the current node's value from the string
        currVal = ip[i]

        # If the left child is not null
        if currVal != "N":
            # Create the left child for the current node
            currNode.left = Node(int(currVal))

            # Push it to the queue
            queue.append(currNode.left)

        # For the right child
        i += 1
        if i >= len(ip):
            break
        currVal = ip[i]

        # If the right child is not null
        if currVal != "N":
            # Create the right child for the current node
            currNode.right = Node(int(currVal))

            # Push it to the queue
            queue.append(currNode.right)

        i += 1

    return root

for _ in range(int(input())):
    s = input()
    root = buildTree(s)
    k, x, y = map(int, input().split())
    if root is None:
        continue
    
    if root.left is None and root.right is None:
        continue
    
    ob = Solution()
    print(ob.kthCommonAncestor(root, k, x, y))


# } DriverCodeEnds


================================================================================
Date: 2024-04-04
Problem: Sum of all substrings of a number
Filename: 2024-04-04_Sum_of_all_substrings_of_a_number.py
================================================================================

#User function Template for python3

class Solution:
    #Function to find sum of all possible substrings of the given string.
    def sumSubstrings(self,s):
        mod = 10**9 + 7
        r = 1
        res = 0
        for i in range(len(s) - 1, -1, -1):
            res = (res + ((int(s[i]) * (i + 1) * r) % mod)) % mod
            r = (r * 10 + 1) % mod
        return res


#{ 
 # Driver Code Starts
#Initial Template for Python 3
import atexit
import io
import sys

import sys
sys.setrecursionlimit(10**6)

# Contributed by : Nagendra Jha

if __name__ == '__main__':
    test_cases = int(input())
    for cases in range(test_cases):
        s = str(input())
        ob=Solution()
        print(ob.sumSubstrings(s))
# } Driver Code Ends


================================================================================
Date: 2024-04-05
Problem: Strictly Increasing Array
Filename: 2024-04-05_Strictly_Increasing_Array.py
================================================================================

#User function Template for python3

class Solution:
    def min_operations(self, nums):
        n = len(nums)
        dp = [0] * n
        m = 0        

        for i in range(n):
            dp[i] = max(((dp[j] + 1) for j in range(i) if nums[j] < nums[i] and nums[i] - nums[j] > (i - j - 1)), default=1)
            m = max(m, dp[i])
        return n - m

#{ 

 # Driver Code Starts
#Initial Template for Python 3


if __name__ == '__main__':
    T=int(input())
    for i in range(T):
        n = int(input())
        nums = list(map(int, input().split()))
        ob = Solution();
        ans = ob.min_operations(nums)
        print(ans)

# } Driver Code Ends


================================================================================
Date: 2024-04-06
Problem: Count Ways to Nth Stair
Filename: 2024-04-06_Count_Ways_to_Nth_Stair.py
================================================================================

#User function Template for python3

1)
class Solution:
    def countWays(self, n):
        return 1 + (n // 2)
2)        
class Solution:
    def countWays(self, n):
        dp = [0] * (n + 1)
        dp[0] = 1
        dp[1] = 1
        for i in range(2, n + 1):
            dp[i] = dp[i - 1] + (1 if i % 2 == 0 else 0)
        return dp[n]


#{ 
 # Driver Code Starts
#Initial Template for Python 3
import atexit
import io
import sys

# Contributed by : Nagendra Jha

if __name__ == '__main__':
    test_cases = int(input())
    for cases in range(test_cases):
        n = int(input())
        ob = Solution()
        print(ob.countWays(n))

# } Driver Code Ends


================================================================================
Date: 2024-04-07
Problem: Maximize dot product
Filename: 2024-04-07_Maximize_dot_product.py
================================================================================

#User function Template for python3
class Solution:
    def maxDotProduct(self, n, m, a, b):
        dp = [[-1] * (m + 1) for _ in range(n + 1)]
        return self.solve(n, m, a, b, dp)

    def solve(self, n, m, a, b, dp):
        if m == 0:
            return 0
        if n < m:
            return float('-inf')
        if dp[n][m] != -1:
            return dp[n][m]
        t2 = self.solve(n - 1, m, a, b, dp)
        t3 = a[n - 1] * b[m - 1] + self.solve(n - 1, m - 1, a, b, dp)
        dp[n][m] = max(t2, t3)
        return dp[n][m]

 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
	T=int(input())
	for i in range(T):
		n,m = input().split()
		n,m = int(n),int(m)
		a = [int(x) for x in input().split()]
		b = [int(x) for x in input().split()]
		ob = Solution()
		ans = ob.maxDotProduct(n,m,a,b)
		print(ans)
# } Driver Code Ends


================================================================================
Date: 2024-04-08
Problem: Optimal Strategy For A Game
Filename: 2024-04-08_Optimal_Strategy_For_A_Game.py
================================================================================

#User function Template for python3


#Function to find the maximum possible amount of money we can win.
1)
class Solution:
    def optimalStrategyOfGame(self, n, arr):
        dp = [[0] * n for _ in range(n)]

        for i in range(n):
            dp[i][i] = arr[i]

        for length in range(2, n + 1):
            for i in range(n - length + 1):
                j = i + length - 1
                x = dp[i + 2][j] if i + 2 <= j else 0
                y = dp[i + 1][j - 1] if i + 1 <= j - 1 else 0
                z = dp[i][j - 2] if i <= j - 2 else 0
                dp[i][j] = max(arr[i] + min(x, y), arr[j] + min(y, z))

        return dp[0][n - 1]
2)        
class Solution:
    def optimalStrategyOfGame(self, n, arr):
        dp = [[0] * n for _ in range(n)]

        for gap in range(n):
            for i in range(n - gap):
                j = i + gap
                x = dp[i + 2][j] if i + 2 <= j else 0
                y = dp[i + 1][j - 1] if i + 1 <= j - 1 else 0
                z = dp[i][j - 2] if i <= j - 2 else 0
                dp[i][j] = max(arr[i] + min(x, y), arr[j] + min(y, z))

        return dp[0][n - 1]
        
#{ 
 # Driver Code Starts
#Initial Template for Python 3
import atexit
import io
import sys

# Contributed by : Nagendra Jha

if __name__ == '__main__':
    test_cases = int(input())
    for cases in range(test_cases):
        n = int(input())
        arr = list(map(int,input().strip().split()))
        ob = Solution()
        print(ob.optimalStrategyOfGame(n,arr))

# } Driver Code Ends


================================================================================
Date: 2024-04-09
Problem: Minimum Points To Reach Destination
Filename: 2024-04-09_Minimum_Points_To_Reach_Destination.py
================================================================================

#User function Template for python3
class Solution:
    def minPoints(self, m, n, points):
        dp = [[0] * n for _ in range(m)]
        
        dp[m - 1][n - 1] = max(1, 1 - points[m - 1][n - 1])
        
        for i in range(m - 2, -1, -1):
            dp[i][n - 1] = max(1, dp[i + 1][n - 1] - points[i][n - 1])
        
        for j in range(n - 2, -1, -1):
            dp[m - 1][j] = max(1, dp[m - 1][j + 1] - points[m - 1][j])
        
        for i in range(m - 2, -1, -1):
            for j in range(n - 2, -1, -1):
                minPointsRequired = min(dp[i + 1][j], dp[i][j + 1])
                dp[i][j] = max(1, minPointsRequired - points[i][j])
        
        return dp[0][0]

#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
	T=int(input())
	for i in range(T):
		m,n = input().split()
		m,n = int(m),int(n)
		points = []
		for _ in range(m):
			temp = [int(x) for x in input().split()]
			points.append(temp)
		ob = Solution()
		ans = ob.minPoints(m,n,points)
		print(ans)




# } Driver Code Ends


================================================================================
Date: 2024-04-10
Problem: Party of Couples
Filename: 2024-04-10_Party_of_Couples.py
================================================================================

#User function Template for python3

class Solution:
    def findSingle(self, n, arr):
        single = 0
        for i in range(n):
            single = single ^ arr[i]
        return single
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__': 
    t = int (input ())
    for _ in range (t):
        N = int(input())
        arr = input().split()
        for itr in range(N):
            arr[itr] = int(arr[itr])
        
        ob = Solution()
        print(ob.findSingle(N, arr))

# } Driver Code Ends


================================================================================
Date: 2024-04-11
Problem: Gray to Binary equivalent
Filename: 2024-04-11_Gray_to_Binary_equivalent.py
================================================================================

#User function Template for python3

class Solution:    
    # function to convert a given Gray equivalent n to Binary equivalent.
    def grayToBinary(self,n):
        binary = 0
        while n != 0:
            binary ^= n
            n >>= 1
        return binary

 # Driver Code Starts
#Initial Template for Python 3

import math

def main():    
    T=int(input())
    while(T>0): 
        n=int(input())
        ob=Solution()
        print(ob.grayToBinary(n))
        T-=1

if __name__=="__main__":
    main()
# } Driver Code Ends


================================================================================
Date: 2024-04-12
Problem: Sum of Products
Filename: 2024-04-12_Sum_of_Products.py
================================================================================

#User function Template for python3

class Solution:
    def pairAndSum(self, n, arr):
        ans = 0
        for i in range(32):
            count = 0
            for j in range(n):
                count += (arr[j] >> i) & 1
            ans += ((count * (count - 1)) // 2) * (1 << i)
        return ans


 # Driver Code Starts
#Initial Template for Python 3

if __name__=='__main__':
    t=int(input())
    for _ in range(t):
        N=int(input())
        Arr=list(map(int,input().strip().split(' ')))
        ob=Solution()
        print(ob.pairAndSum(N,Arr))
# } Driver Code Ends


================================================================================
Date: 2024-04-13
Problem: Reverse Bits
Filename: 2024-04-13_Reverse_Bits.py
================================================================================

#User function Template for python3

class Solution:
    def reversedBits(self, x):
        ans = 0
        for i in range(32):
            ans = (ans << 1) | (x & 1)  # Shift ans left by 1 and OR it with the least significant bit of x
            x >>= 1  # Shift x right by 1 to process the next bit
        return ans
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__': 
    t = int (input ())
    for _ in range (t):
        X=int(input())
        
        ob = Solution()
        print(ob.reversedBits(X))
# } Driver Code Ends


================================================================================
Date: 2024-04-14
Problem: Xoring and Clearing
Filename: 2024-04-14_Xoring_and_Clearing.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3

# } Driver Code Ends
#User function Template for python3

class Solution:
    def printArr(self, n, arr):
        print(*arr)

    def setToZero(self, n, arr):
        for i in range(n):
            arr[i] = 0

    def xor1ToN(self, n, arr):
        for i in range(n):
            arr[i] ^= i

#{ 
 # Driver Code Starts.
if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        n = int(input())
        arr = list(map(int, input().split()))
        obj = Solution()
        obj.xor1ToN(n, arr)
        obj.printArr(n, arr)
        obj.setToZero(n, arr)
        obj.printArr(n, arr)

# } Driver Code Ends


================================================================================
Date: 2024-04-15
Problem: Count the elements
Filename: 2024-04-15_Count_the_elements.py
================================================================================

#User function Template for python3
# User function Template for python3
class Solution:
    def countElements(self, a, b, n, query, q):
        b.sort()
        ans = []
        
        for i in range(q):
            count = self.upperBound(b, a[query[i]])
            ans.append(count)
        
        return ans
    
    def upperBound(self, arr, target):
        low, high = 0, len(arr)
        
        while low < high:
            mid = low + (high - low) // 2
            
            if arr[mid] <= target:
                low = mid + 1
            else:
                high = mid
        
        return low

 # Driver Code Starts
#Initial Template for Python 3

t = int(input())
for _ in range(0, t):
    n = int(input())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    q = int(input())
    query = []
    ob = Solution()
    for i in range(q):
        query.append(int(input()))
    ans = ob.countElements(a, b, n, query, q)
    for i in range(q):
        print(ans[i])

# } Driver Code Ends


================================================================================
Date: 2024-04-16
Problem: Minimize the Difference
Filename: 2024-04-16_Minimize_the_Difference.py
================================================================================


from typing import List

class Solution:
    def minimizeDifference(self, n: int, k: int, arr: List[int]) -> int:
      
        
        post_max = [0] * n
        post_min = [0] * n

        post_min[-1] = arr[-1]
        post_max[-1] = arr[-1]
        for i in range(n - 2, -1, -1):
            post_max[i] = max(arr[i], post_max[i + 1])
            post_min[i] = min(arr[i], post_min[i + 1])
            
        min_diff = post_max[k] - post_min[k]
        p_min = arr[0]
        p_max = arr[0]

        for i in range(1, n - k):
            curr_min = max(p_max, post_max[i + k]) - min(p_min, post_min[i + k])
            min_diff = min(min_diff, curr_min)
            p_max = max(arr[i], p_max)
            p_min = min(arr[i], p_min)
        
        min_diff = min(min_diff, p_max - p_min)

        return min_diff






#{ 
 # Driver Code Starts

class IntArray:
    def __init__(self) -> None:
        pass
    def Input(self,n):
        arr=[int(i) for i in input().strip().split()]#array input
        return arr
    def Print(self,arr):
        for i in arr:
            print(i,end=" ")
        print()


if __name__=="__main__":
    t = int(input())
    for _ in range(t):
        
        n = int(input())
        
        
        k = int(input())
        
        
        arr=IntArray().Input(n)
        
        obj = Solution()
        res = obj.minimizeDifference(n, k, arr)
        
        print(res)
        

# } Driver Code Ends


================================================================================
Date: 2024-04-17
Problem: Count Pairs in an Array
Filename: 2024-04-17_Count_Pairs_in_an_Array.py
================================================================================

#User function Template for python3

class Solution:
    def merge(self, arr, temp, left, mid, right):
        inv_count = 0
        i = left
        j = mid
        k = left
        while i <= mid - 1 and j <= right:
            if arr[i] <= arr[j]:
                temp[k] = arr[i]
                i += 1
                k += 1
            else:
                temp[k] = arr[j]
                k += 1
                j += 1
                inv_count += mid - i
        while i <= mid - 1:
            temp[k] = arr[i]
            i += 1
            k += 1
        while j <= right:
            temp[k] = arr[j]
            k += 1
            j += 1
        for i in range(left, right + 1):
            arr[i] = temp[i]
        return inv_count

    def _mergeSort(self, arr, temp, left, right):
        inv_count = 0
        if right > left:
            mid = (right + left) // 2
            inv_count = self._mergeSort(arr, temp, left, mid)
            inv_count += self._mergeSort(arr, temp, mid + 1, right)
            inv_count += self.merge(arr, temp, left, mid + 1, right)
        return inv_count

    def countPairs(self, arr, n):
        for i in range(n):
            arr[i] = i * arr[i]
        temp = [0] * n
        return self._mergeSort(arr, temp, 0, n - 1)


#{ 
 # Driver Code Starts
#Initial Template for Python 3

def main():

    T = int(input())

    while(T > 0):
        n = int(input())
        a = [int(x) for x in input().strip().split()]
        ob= Solution()
        print(ob.countPairs(a, n))

        T -= 1


if __name__ == "__main__":
    main()
    
# } Driver Code Ends


================================================================================
Date: 2024-04-18
Problem: Two Repeated Elements
Filename: 2024-04-18_Two_Repeated_Elements.py
================================================================================


#User function Template for python3

class Solution:
    
    #Function to find two repeated elements.
    def twoRepeated(self, arr , n):
        seen = set()
        result = []
        
        for i in range(n + 2):
            if arr[i] in seen:
                result.append(arr[i])
            else:
                seen.add(arr[i])
        
        return result


#{ 
 # Driver Code Starts
#Initial Template for Python 3

import math

def main():
        T=int(input())
        while(T>0):
            
            N=int(input())

            A=[int(x) for x in input().strip().split()]
            
            obj = Solution()
            ans = obj.twoRepeated(A,N)
            print(ans[0], ans[1])
            
            T-=1


if __name__ == "__main__":
    main()
# } Driver Code Ends


================================================================================
Date: 2024-04-19
Problem: Find missing in second array
Filename: 2024-04-19_Find_missing_in_second_array.py
================================================================================

#User function Template for python3
class Solution:
    def findMissing(self,a,b,n,m):
        s = set(b)
        ans = []
        for num in a:
            if num not in s:
                ans.append(num)
        return ans

 # Driver Code Starts

#Initial Template for Python 3

t=int(input())
for _ in range(0,t):
   # n=int(input())
    l = list(map(int, input().split()))
    n=l[0]
    m=l[1]
    a = list(map(int,input().split()))
    b = list(map(int, input().split()))
    ob=Solution()
    ans=ob.findMissing(a,b,n,m)
    for each in ans:
        print(each,end=' ')
    print()
# } Driver Code Ends


================================================================================
Date: 2024-04-20
Problem: Union of Two Sorted Arrays
Filename: 2024-04-20_Union_of_Two_Sorted_Arrays.py
================================================================================

#User function Template for python3
class Solution:
    #Function to return a list containing the union of the two arrays.
    def findUnion(self, arr1, arr2, n, m):
    
        '''
        :param a: given sorted array a
        :param n: size of sorted array a
        :param b: given sorted array b
        :param m: size of sorted array b
        :return:  The union of both arrays as a list
        '''
        arr1.sort()
        arr2.sort()
        
        ans = []
        
        i = 0
        j = 0
        
        while i < n and j < m:
            if arr1[i] < arr2[j]:
                ans.append(arr1[i])
                i += 1
            elif arr1[i] > arr2[j]:
                ans.append(arr2[j])
                j += 1
            else:
                ans.append(arr1[i])
                i += 1
                j += 1
        
        while i < n:
            ans.append(arr1[i])
            i += 1
        
        while j < m:
            ans.append(arr2[j])
            j += 1
        
        # Remove duplicates
        result = []
        for k in range(len(ans)):
            if k == 0 or ans[k] != ans[k - 1]:
                result.append(ans[k])
        
        return result

        


#{ 
 # Driver Code Starts
#Initial Template for Python 3

# Contributed by : Nagendra Jha
# Modified by : Sagar Gupta


if __name__ == '__main__':
    test_cases = int(input())
    for cases in range(test_cases) :
        n,m = map(int,input().strip().split())
        a = list(map(int,input().strip().split()))
        b = list(map(int,input().strip().split()))
        ob=Solution()
        li = ob.findUnion(a,b,n,m)
        for val in li:
            print(val, end = ' ')
        print()
# } Driver Code Ends


================================================================================
Date: 2024-04-21
Problem: Three way partitioning
Filename: 2024-04-21_Three_way_partitioning.py
================================================================================



#User function template for Python

class Solution:
    #Function to partition the array around the range such 
    #that array is divided into three parts.
    def threeWayPartition(self, array, a, b):
        n = len(array)
        left, right = 0, n - 1
        
        i = 0
        while i <= right:
            if array[i] < a:
                array[i], array[left] = array[left], array[i]
                left += 1
                i += 1
            elif array[i] > b:
                array[i], array[right] = array[right], array[i]
                right -= 1
            else:
                i += 1

#{ 
 # Driver Code Starts
#Initial template for Python

from collections import Counter

if __name__=='__main__':
    t = int(input())
    for i in range(t):
        n = int(input())
        array = list(map(int, input().strip().split()))
        original = Counter(array)
        a,b = list(map(int, input().strip().split()))
        ob = Solution()
        ob.threeWayPartition(array, a, b)

        k1 = k2 = k3 = 0
        for e in array:
            if e > a:
                k3+=1
            elif e<=a and e>=b:
                k2+=1
            elif e<a:
                k1+=1

        m1 = m2 = m3 = 0
        for e in range(k1):
            if array[e]<a:
                m1+=1
        for e in range(k1, k1+k2):
            if array[e]<=a and array[e]>=b:
                m2+=1
        for e in range(k1+k2, k1+k2+k3):
            if array[e]>=a:
                m3+=1

        flag = False
        if k1==m1 and k2==m2 and k3==m3:
            flag = True
        for e in range(len(array)):
            original[array[e]]-=1
        for e in range(len(array)):
            if original[array[e]]!=0:
                flag = False
        if flag:
            print(1)
        else:
            print(0)

# } Driver Code Ends


================================================================================
Date: 2024-04-22
Problem: Row with minimum number of 1s
Filename: 2024-04-22_Row_with_minimum_number_of_1s.py
================================================================================

#User function Template for python3

class Solution:
    def minRow(self, n, m, a):
        res = 1
        min_val = math.inf
        for i in range(n):
            count = 0
            for j in range(m):
                if a[i][j] == 1:
                    count += 1
            minn = min(count, min_val)
            if minn != min_val:
                res = i + 1
                min_val = minn
        return res

 # Driver Code Starts
#Initial Template for Python 3

import math
        
if __name__=='__main__':
    t=int(input())
    for _ in range(t):
        N,M=map(int,input().strip().split(" "))
        A=[]
        for i in range(N):
            B=list(map(int,input().strip().split(" ")))
            A.append(B)
        ob=Solution()
        print(ob.minRow(N,M,A))
# } Driver Code Ends


================================================================================
Date: 2024-04-23
Problem: Rohans Love for Matrix
Filename: 2024-04-23_Rohans_Love_for_Matrix.py
================================================================================

#User function Template for python3
class Solution:
    def firstElement(self, n):
        mod = 1000000007
        if n <= 2:
            return 1
        one, two = 1, 1
        for i in range(3, n + 1):
            sum = (one + two) % mod
            one = two
            two = sum
        return sum

 # Driver Code Starts
#Initial Template for Python 3
if __name__ == '__main__': 
    t = int (input ())
    for _ in range (t):
        n = int(input())
        
        ob = Solution()
        print(ob.firstElement(n))
# } Driver Code Ends


================================================================================
Date: 2024-04-24
Problem: Paths to reach origin
Filename: 2024-04-24_Paths_to_reach_origin.py
================================================================================

#Back-end complete function Template for Python 3

mod=10**9+7
def calculate():
    dp=[]
    for i in range(0,501):
        dp.append([0]*501)
    for i in range(0,501):
        dp[0][i]=1
        dp[i][0]=1
    dp[0][0]=1
    for i in range(1,501):
        for j in range(1,501):
            dp[i][j]=(dp[i-1][j]+dp[i][j-1])%mod
    return dp

dp=calculate()

class Solution:
    def ways(self, x,y):
        return dp[x][y]


#{ 
 # Driver Code Starts
#Initial Template for Python 3

t=int(input())
for _ in range(0,t):
    x,y=list(map(int,input().split()))
    ob = Solution()
    print(ob.ways(x,y))
# } Driver Code Ends


================================================================================
Date: 2024-04-25
Problem: Maximum Sum of Hourglass
Filename: 2024-04-25_Maximum_Sum_of_Hourglass.py
================================================================================

#User function Template for python3

class Solution:
    def findMaxSum(self, N, M, Mat):
        if N < 3 or M < 3:
            return -1

        ans = float('-inf')

        for i in range(N - 2):
            for j in range(M - 2):
                sum = Mat[i][j] + Mat[i][j + 1] + Mat[i][j + 2] + \
                      Mat[i + 1][j + 1] + \
                      Mat[i + 2][j] + Mat[i + 2][j + 1] + Mat[i + 2][j + 2]

                ans = max(ans, sum)

        return ans


 # Driver Code Starts
#Initial Template for Python 3

import math
      
if __name__=='__main__':
    t=int(input())
    for _ in range(t):
        N,M=map(int,input().strip().split(" "))
        Mat=[]
        for i in range(N):
            B=list(map(int,input().strip().split(" ")))
            Mat.append(B)
        ob=Solution()
        ans=ob.findMaxSum(N,M,Mat)
        print(ans) 
# } Driver Code Ends


================================================================================
Date: 2024-04-26
Problem: Exit Point in a Matrix
Filename: 2024-04-26_Exit_Point_in_a_Matrix.py
================================================================================

#User function Template for python3

class Solution:
    def FindExitPoint(self, n, m, matrix):
        i, j, k = 0, 0, 0
        dx = [0, 1, 0, -1]
        dy = [1, 0, -1, 0]
        while i >= 0 and j >= 0 and i < n and j < m:
            if matrix[i][j] == 1:
                matrix[i][j] = 0
                k = (k + 1) % 4
            i += dx[k]
            j += dy[k]
        return [i - dx[k], j - dy[k]]

 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    T = int(input())
    for i in range(T):
        n, m = input().split()
        n = int(n)
        m = int(m)
        matrix = []
        for _ in range(n):
            matrix.append(list(map(int, input().split())))
        ob = Solution()
        ans = ob.FindExitPoint(n, m, matrix)
        for _ in ans:
            print(_, end=" ")
        print()

# } Driver Code Ends


================================================================================
Date: 2024-04-27
Problem: Merge Sort on Doubly Linked List
Filename: 2024-04-27_Merge_Sort_on_Doubly_Linked_List.py
================================================================================

#User function Template for python3

'''
class Node:
	def __init__(self, data):
		self.data = data
		self.next = None
		self.prev = None
'''

class Solution():
    # Function to sort the given doubly linked list using Merge Sort.
    def sortDoubly(self, head):
        if head is None or head.next is None:
            return head

        def merge(left, right):
            if left is None:
                return right
            if right is None:
                return left

            if left.data <= right.data:
                result = left
                result.next = merge(left.next, right)
                if result.next:
                    result.next.prev = result
            else:
                result = right
                result.next = merge(left, right.next)
                if result.next:
                    result.next.prev = result

            return result

        def getMid(head):
            slow = head
            fast = head
            while fast.next and fast.next.next:
                slow = slow.next
                fast = fast.next.next
            return slow

        mid = getMid(head)
        nextToMid = mid.next
        mid.next = None
        if nextToMid:
            nextToMid.prev = None

        left = self.sortDoubly(head)
        right = self.sortDoubly(nextToMid)

        return merge(left, right)

#{ 


 # Driver Code Starts
#Initial Template for Python 3

import sys

sys.setrecursionlimit(1000000)


class Node:

    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None


class DoublyLinkedList:

    def __init__(self):
        self.head = None
        self.tail = None

    def append(self, new_data):
        new_node = Node(new_data)
        if self.head is None:
            self.head = new_node
            self.tail = new_node
            return
        new_node.prev = self.tail
        self.tail.next = new_node
        self.tail = new_node

    def printList(self, node):
        while (node.next is not None):
            node = node.next
        while node.prev is not None:
            node = node.prev
        while (node is not None):
            print(node.data, end=" ")
            node = node.next
        print()


def printList(node):
    temp = node

    while (node is not None):
        print(node.data, end=" ")
        temp = node
        node = node.next
    print()
    while (temp):
        print(temp.data, end=" ")
        temp = temp.prev


if __name__ == '__main__':
    t = int(input())
    for i in range(t):
        n = int(input())
        arr = list(map(int, input().strip().split()))
        llist = DoublyLinkedList()
        for e in arr:
            llist.append(e)
        ob = Solution()
        llist.head = ob.sortDoubly(llist.head)
        printList(llist.head)
        print()

# } Driver Code Ends


================================================================================
Date: 2024-04-28
Problem: Delete Middle of Linked List
Filename: 2024-04-28_Delete_Middle_of_Linked_List.py
================================================================================

#User function Template for python3

'''
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
'''


class Solution:
    def deleteMid(self, head):
        if not head or not head.next:
            return None  

        slow = head
        fast = head
        prev = None

        while fast and fast.next:
            prev = slow
            slow = slow.next
            fast = fast.next.next

        if prev:
            prev.next = slow.next
        else:
            head = slow.next 
        slow.next = None

        return head



#{ 
 # Driver Code Starts
#Initial Template for Python 3

#contributed by RavinderSinghPB
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class Llist:
    def __init__(self):
        self.head = None

    def insert(self, data, tail):
        node = Node(data)

        if not self.head:
            self.head = node
            return node

        tail.next = node
        return node


def printList(head):
    while head:
        print(head.data, end=' ')
        head = head.next
    print()

if __name__ == '__main__':
    t = int(input())

    for tcs in range(t):
        n=int(input())
        arr1 = [int(x) for x in input().split()]
        ll = Llist()
        tail = None
        for nodeData in arr1:
            tail = ll.insert(nodeData, tail)
        obj = Solution();
        res=obj.deleteMid(ll.head)
        printList(res)
# } Driver Code Ends


================================================================================
Date: 2024-04-29
Problem: Remove every kth node
Filename: 2024-04-29_Remove_every_kth_node.py
================================================================================

#Your task is to complete this function
#Your function should return the new head pointer

class node:
    def __init__(self,x):
        self.data = x
        self.next = None

class Solution:
    def deleteK(self, head, k):
        if not head or k <= 0:
            return head
        
        if k == 1:
            # Deleting entire list
            while head:
                temp = head
                head = head.next
                temp = None
            return None

        dummy = node(0)
        dummy.next = head
        prev = dummy
        curr = head
        index = 1

        while curr:
            if index == k:
                prev.next = curr.next
                curr = None
                curr = prev.next
                index = 1
            else:
                index += 1
                prev = curr
                curr = curr.next

        return dummy.next
#{ 
 # Driver Code Starts
class node:

    def __init__(self, x):
        self.data = x
        self.next = None


def createLinkedList(arr):
    head = node(arr[0])
    curr = head
    for i in range(1, len(arr)):
        new_node = node(arr[i])
        curr.next = new_node
        curr = curr.next

    return head


def printlist(ptr):
    while ptr != None:
        print(ptr.data, end=" ")
        ptr = ptr.next
    print()


if __name__ == '__main__':
    t = int(input())
    for i in range(t):
        n = int(input())
        arr = list(map(int, input().strip().split()))
        k = int(input())

        obj = Solution()
        head = createLinkedList(arr)
        new_head = obj.deleteK(head, k)
        printlist(new_head)

# } Driver Code Ends


================================================================================
Date: 2024-04-30
Problem: Add two numbers represented by linked lists
Filename: 2024-04-30_Add_two_numbers_represented_by_linked_lists.py
================================================================================

#User function Template for python3

#User function Template for python3

''' Node for linked list:

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

'''
class Solution:
    #Function to add two numbers represented by linked list.
    def addTwoLists(self, num1, num2):
        # Reverse both lists to simplify addition.
        num1 = self.reverse(num1)
        num2 = self.reverse(num2)

        sum = None
        carry = 0

        while num1 or num2 or carry:
            newVal = carry

            if num1:
                newVal += num1.data
                num1 = num1.next
            if num2:
                newVal += num2.data
                num2 = num2.next

            carry = newVal // 10
            newVal %= 10

            newNode = Node(newVal)
            newNode.next = sum
            sum = newNode

        return self.removeLeadingZeros(sum)

    #Function to reverse the linked list.
    def reverse(self, head):
        prev = None
        current = head

        while current:
            next = current.next
            current.next = prev
            prev = current
            current = next

        return prev

    #Function to remove leading zeros from the result.
    def removeLeadingZeros(self, head):
        current = head
        prev = None

        while current and current.data == 0:
            prev = current
            current = current.next
            prev.next = None

        return current if current else Node(0)



#{ 
 # Driver Code Starts
#Initial Template for Python 3

# Node Class
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

# Linked List Class
class LinkedList:
    def __init__(self):
        self.head = None
        self.tail = None

    # creates a new node with given value and appends it at the end of the linked list
    def insert(self, val):
        if self.head is None:
            self.head = Node(val)
            self.tail = self.head
        else:
            self.tail.next = Node(val)
            self.tail = self.tail.next

# prints the elements of linked list starting with head
def printList(n):
    while n:
        print(n.data,end=' ')
        n = n.next
    print()

if __name__ == '__main__':
    for _ in range(int(input())):
        
        n = int(input())
        arr1 = ( int(x) for x in input().split() )
        num1 = LinkedList()
        for i in arr1:
            num1.insert(i)
        
        m = int(input())
        arr2 = ( int(x) for x in input().split() )
        num2 = LinkedList()
        for i in arr2:
            num2.insert(i)
        
        res = Solution().addTwoLists(num1.head, num2.head)
        printList(res)
# } Driver Code Ends


================================================================================
Date: 2024-05-01
Problem: Arrange Consonants and Vowels
Filename: 2024-05-01_Arrange_Consonants_and_Vowels.py
================================================================================

#User function Template for python3

"""
# Node Class

class Node:
    def __init__(self, val):
        self.data = val
        self.next = None

"""

class Solution:
    def arrangeCV(self, head):
        dummy1 = Node('-') 
        ptr1 = dummy1
        dummy2 = Node('-') 
        ptr2 = dummy2
        
        curr = head
        while curr:
            c = curr.data
            if c in ['a', 'e', 'i', 'o', 'u']:
                ptr1.next = curr
                ptr1 = ptr1.next
            else:
                ptr2.next = curr
                ptr2 = ptr2.next
            curr = curr.next
        
        ptr1.next = dummy2.next
        ptr2.next = None 
        
        newHead = dummy1.next
        return newHead


#{ 
 # Driver Code Starts
# Node Class
class Node:

    def __init__(self, val):
        self.data = val
        self.next = None


# Linked List Class
class Linked_List:

    def __init__(self):
        self.head = None
        self.tail = None

    def insert(self, val):
        if self.head is None:
            self.head = Node(val)
            self.tail = self.head
        else:
            self.tail.next = Node(val)
            self.tail = self.tail.next


def printList(head):
    tmp = head
    while tmp:
        print(tmp.data, end=' ')
        tmp = tmp.next
    print()


if __name__ == '__main__':
    for i in range(int(input())):
        n = int(input())
        arr = [str(x) for x in input().split()]

        lis = Linked_List()
        for i in arr:
            lis.insert(i)

        newHead = Solution().arrangeCV(lis.head)
        printList(newHead)

# } Driver Code Ends


================================================================================
Date: 2024-05-02
Problem: Serialize and deserialize a binary tree
Filename: 2024-05-02_Serialize_and_deserialize_a_binary_tree.py
================================================================================

#User function Template for python3


from collections import deque

class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None

class Solution:
    # Function to serialize a tree and return a list containing nodes of the tree.
    def serialize(self, root):
        arr = []
        if not root:
            return arr
        
        queue = deque([root])
        
        while queue:
            curr = queue.popleft()
            if curr:
                arr.append(curr.data)
                queue.append(curr.left)
                queue.append(curr.right)
            else:
                arr.append(float('-inf'))
        
        return arr

    # Function to deserialize a list and construct the tree.
    def deSerialize(self, A):
        if not A or A[0] == float('-inf'):
            return None
        
        root = Node(A[0])
        queue = deque([root])
        i = 1
        
        while queue and i < len(A):
            curr = queue.popleft()
            
            if A[i] != float('-inf'):
                curr.left = Node(A[i])
                queue.append(curr.left)
            i += 1
            
            if i < len(A) and A[i] != float('-inf'):
                curr.right = Node(A[i])
                queue.append(curr.right)
            i += 1
        
        return root


#{ 
 # Driver Code Starts
#Initial Template for Python 3

#Initial Template for Python 3

#Contributed by Suman Rana
from collections import deque


# Tree Node
class Node:

    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None


# Function to Build Tree
def buildTree(s):
    #Corner Case
    if (len(s) == 0 or s[0] == "N"):
        return None

    # Creating list of strings from input
    # string after spliting by space
    ip = list(map(str, s.split()))

    # Create the root of the tree
    root = Node(int(ip[0]))
    size = 0
    q = deque()

    # Push the root to the queue
    q.append(root)
    size = size + 1

    # Starting from the second element
    i = 1
    while (size > 0 and i < len(ip)):
        # Get and remove the front of the queue
        currNode = q[0]
        q.popleft()
        size = size - 1

        # Get the current node's value from the string
        currVal = ip[i]

        # If the left child is not null
        if (currVal != "N"):

            # Create the left child for the current node
            currNode.left = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.left)
            size = size + 1
        # For the right child
        i = i + 1
        if (i >= len(ip)):
            break
        currVal = ip[i]

        # If the right child is not null
        if (currVal != "N"):

            # Create the right child for the current node
            currNode.right = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.right)
            size = size + 1
        i = i + 1
    return root


def inorder(root):
    if not root:
        return
    inorder(root.left)
    print(root.data, end=" ")
    inorder(root.right)


def _deleteTree(node):
    if (node == None):
        return

    # first delete both subtrees
    _deleteTree(node.left)
    _deleteTree(node.right)
    node.left = None
    node.right = None
    # then delete the node


# Deletes a tree and sets the root as NULL
def deleteTree(node_ref):
    _deleteTree(node_ref)
    node_ref = None


if __name__ == "__main__":
    t = int(input())
    for _ in range(0, t):
        root = buildTree(input())
        ob = Solution()
        A = ob.serialize(root)
        deleteTree(root)
        root = None
        r = ob.deSerialize(A)
        inorder(r)
        print()

# } Driver Code Ends


================================================================================
Date: 2024-05-03
Problem: K distance from root
Filename: 2024-05-03_K_distance_from_root.py
================================================================================

#User function Template for python3



'''
class Node:
    def _init_(self,val):
        self.data = val
        self.left = None
        self.right = None
'''

class Solution:
    def KDistance(self, root, k):
        result = []
        self.dfs(root, k, result)
        return result

    def dfs(self, node, k, result, distance=0):
        if not node:
            return
        if distance == k:
            result.append(node.data)
            return  
        
        self.dfs(node.left, k, result, distance + 1)
        self.dfs(node.right, k, result, distance + 1)

 # Driver Code Starts
#Initial Template for Python 3

#Contributed by Sudarshan Sharma
from collections import deque
# Tree Node
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None

# Function to Build Tree   
def buildTree(s):
    #Corner Case
    if(len(s)==0 or s[0]=="N"):           
        return None
        
    # Creating list of strings from input 
    # string after spliting by space
    ip=list(map(str,s.split()))
    
    # Create the root of the tree
    root=Node(int(ip[0]))                     
    size=0
    q=deque()
    
    # Push the root to the queue
    q.append(root)                            
    size=size+1 
    
    # Starting from the second element
    i=1                                       
    while(size>0 and i<len(ip)):
        # Get and remove the front of the queue
        currNode=q[0]
        q.popleft()
        size=size-1
        
        # Get the current node's value from the string
        currVal=ip[i]
        
        # If the left child is not null
        if(currVal!="N"):
            
            # Create the left child for the current node
            currNode.left=Node(int(currVal))
            
            # Push it to the queue
            q.append(currNode.left)
            size=size+1
        # For the right child
        i=i+1
        if(i>=len(ip)):
            break
        currVal=ip[i]
        
        # If the right child is not null
        if(currVal!="N"):
            
            # Create the right child for the current node
            currNode.right=Node(int(currVal))
            
            # Push it to the queue
            q.append(currNode.right)
            size=size+1
        i=i+1
    return root
    
    
if __name__=="__main__":
    t=int(input())
    for _ in range(0,t):
        k = int(input())
        s=input()
        root=buildTree(s)
        ob=Solution();
        nodes = ob.KDistance(root,k)
        for node in nodes:
            print(node,end=' ')
        print()
# } Driver Code Ends


================================================================================
Date: 2024-05-04
Problem: Construct Binary Tree from Inorder and Postorder
Filename: 2024-05-04_Construct_Binary_Tree_from_Inorder_and_Postorder.py
================================================================================

#User function Template for python3

class Node:
    def __init__(self, data):
        self.data = data
        self.left = self.right = None

class Solution:
    def buildTree(self, inOrder, postOrder, n):
        postIndex = [n - 1] 
        return self.buildTreeHelper(inOrder, postOrder, 0, n - 1, postIndex)
    
    def buildTreeHelper(self, inOrder, postOrder, inStart, inEnd, postIndex):
        if inStart > inEnd:
            return None

        root = Node(postOrder[postIndex[0]])
        postIndex[0] -= 1 

        inIndex = inOrder.index(root.data) 

        root.right = self.buildTreeHelper(inOrder, postOrder, inIndex + 1, inEnd, postIndex)
        root.left = self.buildTreeHelper(inOrder, postOrder, inStart, inIndex - 1, postIndex)

        return root


#{ 
 # Driver Code Starts
#Initial Template for Python 3
import atexit
import io
import sys
from collections import  defaultdict

#Contributed by : PranchalK


_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__
_OUTPUT_BUFFER = io.StringIO()
sys.stdout = _OUTPUT_BUFFER

@atexit.register

def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())



# Helper function that allocates  
# a new node  
class Node:
    def __init__(self, data):
        self.data = data
        self.left = self.right = None

# This funtcion is here just to test  
def preOrder(node):
    if node == None:
        return
    print(node.data, end=" ")
    preOrder(node.left)
    preOrder(node.right)
    
if __name__ == '__main__':
    test_cases = int(input())
    for cases in range(test_cases):
        n = int(input())  # number of nodes in tree
        in_order = list(map(int, input().strip().split()))  # parent child info in list
        post_order = list(map(int, input().strip().split()))  # parent child info in list
        ob = Solution()
        preOrder(ob.buildTree(in_order,post_order,n))
        print()


# } Driver Code Ends


================================================================================
Date: 2024-05-05
Problem: Vertical sum
Filename: 2024-05-05_Vertical_sum.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3

from collections import deque
# Tree Node
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None

# Function to Build Tree   
def buildTree(s):
    #Corner Case
    if(len(s)==0 or s[0]=="N"):           
        return None
        
    # Creating list of strings from input 
    # string after spliting by space
    ip=list(map(str,s.split()))
    
    # Create the root of the tree
    root=Node(int(ip[0]))                     
    size=0
    q=deque()
    
    # Push the root to the queue
    q.append(root)                            
    size=size+1 
    
    # Starting from the second element
    i=1                                       
    while(size>0 and i<len(ip)):
        # Get and remove the front of the queue
        currNode=q[0]
        q.popleft()
        size=size-1
        
        # Get the current node's value from the string
        currVal=ip[i]
        
        # If the left child is not null
        if(currVal!="N"):
            
            # Create the left child for the current node
            currNode.left=Node(int(currVal))
            
            # Push it to the queue
            q.append(currNode.left)
            size=size+1
        # For the right child
        i=i+1
        if(i>=len(ip)):
            break
        currVal=ip[i]
        
        # If the right child is not null
        if(currVal!="N"):
            
            # Create the right child for the current node
            currNode.right=Node(int(currVal))
            
            # Push it to the queue
            q.append(currNode.right)
            size=size+1
        i=i+1
    return root
    

# } Driver Code Ends
#User function Template for python3

class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None

# Function to find vertical sum of a binary tree
class Solution:
    def verticalSum(self, root):
        ans = []
        if root is None:
            return ans

        map = {}
        queue = deque()
        positions = deque()

        queue.append(root)
        positions.append(0)

        while queue:
            node = queue.popleft()
            position = positions.popleft()

            map[position] = map.get(position, 0) + node.data

            if node.left:
                queue.append(node.left)
                positions.append(position - 1)

            if node.right:
                queue.append(node.right)
                positions.append(position + 1)

        minPosition = min(map.keys())
        maxPosition = max(map.keys())
        for i in range(minPosition, maxPosition + 1):
            ans.append(map[i])

        return ans


#{ 
 # Driver Code Starts.
if __name__=="__main__":
    t=int(input())
    for _ in range(0,t):
        s=input()
        root=buildTree(s)
        res = Solution().verticalSum(root)
        for i in res:
            print (i, end = " ")
        print();
# } Driver Code Ends


================================================================================
Date: 2024-05-06
Problem: Print all nodes that dont have sibling
Filename: 2024-05-06_Print_all_nodes_that_dont_have_sibling.py
================================================================================

#User function Template for python3

def noSibling(root):
    if not root:
        return [-1]  # If the tree is empty, return -1 as per the problem statement
    
    no_sibling = []
    queue = [root]

    while queue:
        node = queue.pop(0)
        if node.left and not node.right:
            no_sibling.append(node.left.data)
        elif node.right and not node.left:
            no_sibling.append(node.right.data)

        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)

    return sorted(no_sibling) if no_sibling else [-1]
    

#{ 
 # Driver Code Starts

from collections import deque
# Tree Node
class Node:
   def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None

# Function to Build Tree  
def buildTree(s):
   #Corner Case
   if(len(s)==0 or s[0]=="N"):          
       return None
       
   # Creating list of strings from input
   # string after spliting by space
   ip=list(map(str,s.split()))
   
   # Create the root of the tree
#   print(ip)
   root=Node(int(ip[0]))                    
   size=0
   q=deque()
   
   # Push the root to the queue
   q.append(root)                            
   size=size+1
   
   # Starting from the second element
   i=1                                      
   while(size>0 and i<len(ip)):
       # Get and remove the front of the queue
       currNode=q[0]
       q.popleft()
       size=size-1
       
       # Get the current node's value from the string
       currVal=ip[i]
       
       # If the left child is not null
       if(currVal!="N"):
           
           # Create the left child for the current node
           currNode.left=Node(int(currVal))
           
           # Push it to the queue
           q.append(currNode.left)
           size=size+1
       # For the right child
       i=i+1
       if(i>=len(ip)):
           break
       currVal=ip[i]
       
       # If the right child is not null
       if(currVal!="N"):
           
           # Create the right child for the current node
           currNode.right=Node(int(currVal))
           
           # Push it to the queue
           q.append(currNode.right)
           size=size+1
       i=i+1
   return root

   
if __name__=="__main__":
    t=int(input())
    for _ in range(0,t):
        s=input()
        root=buildTree(s)
        ans = noSibling(root)
        for i in ans:
            print(i,end=" ")
        print()

# } Driver Code Ends


================================================================================
Date: 2024-05-07
Problem: Reverse Level Order Traversal
Filename: 2024-05-07_Reverse_Level_Order_Traversal.py
================================================================================

#User function Template for python3

from collections import deque

class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None

def reverseLevelOrder(root):
    if not root:
        return []

    ans = []
    queue = deque([root])

    while queue:
        level_size = len(queue)
        for _ in range(level_size):
            node = queue.popleft()
            ans.append(node.data)

            if node.right:
                queue.append(node.right)
            if node.left:
                queue.append(node.left)

    return ans[::-1]


#{ 
 # Driver Code Starts
#Initial Template for Python 3

from collections import deque
# Tree Node
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None

# Function to Build Tree   
def buildTree(s):
    #Corner Case
    if(len(s)==0 or s[0]=="N"):           
        return None
        
    # Creating list of strings from input 
    # string after spliting by space
    ip=list(map(str,s.split()))
    
    # Create the root of the tree
    root=Node(int(ip[0]))                     
    size=0
    q=deque()
    
    # Push the root to the queue
    q.append(root)                            
    size=size+1 
    
    # Starting from the second element
    i=1                                       
    while(size>0 and i<len(ip)):
        # Get and remove the front of the queue
        currNode=q[0]
        q.popleft()
        size=size-1
        
        # Get the current node's value from the string
        currVal=ip[i]
        
        # If the left child is not null
        if(currVal!="N"):
            
            # Create the left child for the current node
            currNode.left=Node(int(currVal))
            
            # Push it to the queue
            q.append(currNode.left)
            size=size+1
        # For the right child
        i=i+1
        if(i>=len(ip)):
            break
        currVal=ip[i]
        
        # If the right child is not null
        if(currVal!="N"):
            
            # Create the right child for the current node
            currNode.right=Node(int(currVal))
            
            # Push it to the queue
            q.append(currNode.right)
            size=size+1
        i=i+1
    return root
    
    
if __name__=="__main__":
    t=int(input())
    for _ in range(0,t):
        s=input()
        root=buildTree(s)
        ans = reverseLevelOrder(root)
        for i in ans:
            print(i,end=" ")
        print()

# } Driver Code Ends


================================================================================
Date: 2024-05-08
Problem: Root to Leaf Paths
Filename: 2024-05-08_Root_to_Leaf_Paths.py
================================================================================


from typing import Optional
from collections import deque

from typing import List

class Solution:
    def solve(self, root, ans, ds):
        if root is None:
            return
        
        ds.append(root.data)
        
        if root.left is None and root.right is None:
            ans.append(ds.copy())
            return
        
        if root.left:
            self.solve(root.left, ans, ds)
            ds.pop()  # Backtrack after exploring left subtree
        
        if root.right:
            self.solve(root.right, ans, ds)
            ds.pop()  # Backtrack after exploring right subtree
    
    def Paths(self, root):
        ans = []
        ds = []
        self.solve(root, ans, ds)
        return ans




#{ 
 # Driver Code Starts
class Node:

    def __init__(self, val):
        self.data = val
        self.right = None
        self.left = None


# Function to Build Tree
def buildTree(s):
    #Corner Case
    if (len(s) == 0 or s[0] == "N"):
        return None

    # Creating list of strings from input
    # string after spliting by space
    ip = list(map(str, s.split()))

    # Create the root of the tree
    root = Node(int(ip[0]))
    size = 0
    q = deque()

    # Push the root to the queue
    q.append(root)
    size = size + 1

    # Starting from the second element
    i = 1
    while (size > 0 and i < len(ip)):
        # Get and remove the front of the queue
        currNode = q[0]
        q.popleft()
        size = size - 1

        # Get the current node's value from the string
        currVal = ip[i]

        # If the left child is not null
        if (currVal != "N"):

            # Create the left child for the current node
            currNode.left = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.left)
            size = size + 1
        # For the right child
        i = i + 1
        if (i >= len(ip)):
            break
        currVal = ip[i]

        # If the right child is not null
        if (currVal != "N"):

            # Create the right child for the current node
            currNode.right = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.right)
            size = size + 1
        i = i + 1
    return root


def inputTree():
    treeString = input().strip()
    root = buildTree(treeString)
    return root


def inorder(root):
    if (root == None):
        return
    inorder(root.left)
    print(root.data, end=" ")
    inorder(root.right)


class IntMatrix:

    def __init__(self) -> None:
        pass

    def Input(self, n, m):
        matrix = []
        #matrix input
        for _ in range(n):
            matrix.append([int(i) for i in input().strip().split()])
        return matrix

    def Print(self, arr):
        for i in arr:
            for j in i:
                print(j, end=" ")
            print()


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):

        root = inputTree()

        obj = Solution()
        res = obj.Paths(root)

        IntMatrix().Print(res)

# } Driver Code Ends


================================================================================
Date: 2024-05-09
Problem: Divisor Game
Filename: 2024-05-09_Divisor_Game.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3

# } Driver Code Ends
#User function Template for python3

class Solution:
    def divisorGame(self, n):
       return n%2==0;

#{ 
 # Driver Code Starts.


if __name__ == "__main__":
    t = int(input())
    while t > 0:
        n = int(input())

        obj = Solution()
        ans = obj.divisorGame(n)

        if ans:
            print("True")
        else:
            print("False")

        t -= 1
# } Driver Code Ends


================================================================================
Date: 2024-05-10
Problem: Combination Sum II
Filename: 2024-05-10_Combination_Sum_II.py
================================================================================

#User function Template for python3

class Solution:
    def CombinationSum2(self, arr, n, k):
        arr.sort()
        result = []
        temp = []
        self.solve(arr, k, 0, temp, result)
        return result

    def solve(self, arr, target, start, temp, result):
        if target == 0:
            result.append(temp[:])
            return

        for i in range(start, len(arr)):
            if i > start and arr[i] == arr[i - 1]:
                continue
            if arr[i] > target:
                break
            temp.append(arr[i])
            self.solve(arr, target - arr[i], i + 1, temp, result)
            temp.pop()

#{ 
 # Driver Code Starts
#Initial Template for Python 3

for _ in range(int(input())):
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))

    ob = Solution()
    result = ob.CombinationSum2(arr, n, k)
    for row in result:
        print(*row)
    if not result:
        print()

# } Driver Code Ends


================================================================================
Date: 2024-05-11
Problem: Juggler Sequence
Filename: 2024-05-11_Juggler_Sequence.py
================================================================================

#User function Template for python3

class Solution:
    def jugglerSequence(self, n):
        ans = []
        ans.append(n)

        while ans[-1] > 1:
            sqrt_n = (ans[-1] ** 0.5)
            next_term = int(sqrt_n) if ans[-1] % 2 == 0 else int(sqrt_n ** 3)
            ans.append(next_term)

        return ans
#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        n = int(input())

        ob = Solution()
        arr = ob.jugglerSequence(n)
        for i in (arr):
            print(i, end=" ")
        print()

# } Driver Code Ends


================================================================================
Date: 2024-05-12
Problem: Minimum steps to destination
Filename: 2024-05-12_Minimum_steps_to_destination.py
================================================================================

#User function Template for python3


class Solution:
    def minSteps(self, d):
        if d == 0:
            return 0
        
        sum_val = 0
        move = 1
        while sum_val < d or (sum_val - d) % 2 != 0:
            sum_val += move
            move += 1
        
        return move - 1


#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        d = int(input())

        ob = Solution()
        print(ob.minSteps(d))

# } Driver Code Ends


================================================================================
Date: 2024-05-13
Problem: Number of Good Components
Filename: 2024-05-13_Number_of_Good_Components.py
================================================================================

from typing import List

class Solution:
    def findNumberOfGoodComponent(self, e: int, v: int, edges: List[List[int]]) -> int:
        ans = 0
        visited = [0] * (v + 1)

        adj = [[] for _ in range(v + 1)]
        for edge in edges:
            adj[edge[0]].append(edge[1])
            adj[edge[1]].append(edge[0])

        for i in range(1, v + 1):
            if visited[i] == 0:
                vertices = 0
                edgesCount = 0

                stk = [i]
                visited[i] = 1

                while stk:
                    node = stk.pop()
                    vertices += 1
                    edgesCount += len(adj[node])

                    for neighbor in adj[node]:
                        if visited[neighbor] == 0:
                            stk.append(neighbor)
                            visited[neighbor] = 1

                edgesCount //= 2
                if edgesCount == (vertices * (vertices - 1)) // 2:
                    ans += 1

        return ans




#{ 
 # Driver Code Starts
class IntMatrix:

    def _init_(self) -> None:
        pass

    def Input(self, n, m):
        matrix = []
        #matrix input
        for _ in range(n):
            matrix.append([int(i) for i in input().strip().split()])
        return matrix

    def Print(self, arr):
        for i in arr:
            for j in i:
                print(j, end=" ")
            print()


if _name_ == "_main_":
    t = int(input())
    for _ in range(t):

        e = int(input())

        v = int(input())

        edges = IntMatrix().Input(e, 2)

        obj = Solution()
        res = obj.findNumberOfGoodComponent(e, v, edges)

        print(res)

# } DriverCodeEnds


================================================================================
Date: 2024-05-14
Problem: Path With Minimum Effort
Filename: 2024-05-14_Path_With_Minimum_Effort.py
================================================================================


from typing import List


import heapq

class Solution:
    def MinimumEffort(self, rows: int, columns: int, heights: List[List[int]]) -> int:
        pq = [(0, 0, 0)]  # (effort, row, column)
        dist = [[float('inf')] * columns for _ in range(rows)]
        dist[0][0] = 0
        dr = [-1, 0, 1, 0]
        dc = [0, 1, 0, -1]
        
        while pq:
            diff, row, col = heapq.heappop(pq)
            
            if row == rows - 1 and col == columns - 1:
                return diff
            
            for i in range(4):
                newr = row + dr[i]
                newc = col + dc[i]
                
                if 0 <= newr < rows and 0 <= newc < columns:
                    neweffort = max(abs(heights[row][col] - heights[newr][newc]), diff)
                    if neweffort < dist[newr][newc]:
                        dist[newr][newc] = neweffort
                        heapq.heappush(pq, (neweffort, newr, newc))
        return 0



#{ 
 # Driver Code Starts
class IntMatrix:

    def __init__(self) -> None:
        pass

    def Input(self, n, m):
        matrix = []
        #matrix input
        for _ in range(n):
            matrix.append([int(i) for i in input().strip().split()])
        return matrix

    def Print(self, arr):
        for i in arr:
            for j in i:
                print(j, end=" ")
            print()


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):

        rows = int(input())

        columns = int(input())

        heights = IntMatrix().Input(rows, columns)

        obj = Solution()
        res = obj.MinimumEffort(rows, columns, heights)

        print(res)

# } Driver Code Ends


================================================================================
Date: 2024-05-15
Problem: Account Merge
Filename: 2024-05-15_Account_Merge.py
================================================================================

#User function Template for python3

class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def unite(self, x, y):
        rootX = self.find(x)
        rootY = self.find(y)
        if rootX != rootY:
            if self.rank[rootX] < self.rank[rootY]:
                self.parent[rootX] = rootY
            elif self.rank[rootX] > self.rank[rootY]:
                self.parent[rootY] = rootX
            else:
                self.parent[rootY] = rootX
                self.rank[rootX] += 1


class Solution:
    def accountsMerge(self, accounts):
        emailToIndex = {}
        emailToName = {}
        n = len(accounts)
        uf = UnionFind(n)

        # Map emails to indices and names
        for i in range(n):
            for j in range(1, len(accounts[i])):
                email = accounts[i][j]
                emailToIndex[email] = i
                emailToName[email] = accounts[i][0]

        # Union emails with the same owner
        for acc in accounts:
            root = emailToIndex[acc[1]]
            for j in range(2, len(acc)):
                uf.unite(root, emailToIndex[acc[j]])

        # Group emails by owner
        mergedAccounts = {}
        for acc in accounts:
            root = uf.find(emailToIndex[acc[1]])
            mergedAccounts.setdefault(root, set()).update(acc[1:])

        # Build the result
        result = []
        for root, emails in mergedAccounts.items():
            account = [emailToName[list(emails)[0]]]
            account.extend(sorted(emails))
            result.append(account)

        return result



#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__': 
    t = int(input ())
    for _ in range (t):
        n = int(input())
        accounts = []
        for i in range(n):
            cntEmails = int(input())
            nameEmails = input().split()
            accounts.append(nameEmails)
        ob = Solution()
        res = ob.accountsMerge(accounts)
        res.sort()
        print('[', end = '')
        for i in range(len(res)):
            print('[', end = '')
            for j in range(len(res[i])):
                if j != (len(res[i]) - 1):
                    print(res[i][j], end = ', ')
                else:
                    print(res[i][j], end='')
            if (i != len(res) - 1):
                print('], ')
            else:
                print(']', end = '')
        print(']')
# } Driver Code Ends


================================================================================
Date: 2024-05-16
Problem: Divisibility tree
Filename: 2024-05-16_Divisibility_tree.py
================================================================================

from typing import List

class Solution:
    def __init__(self):
        self.ans = 0

    def dfs(self, v: int, vis: List[bool], adj: List[List[int]]) -> int:
        cnt = 0
        vis[v] = True
        for u in adj[v]:
            if not vis[u]:
                res = self.dfs(u, vis, adj)
                if res % 2 == 0:
                    self.ans += 1
                else:
                    cnt += res
        return cnt + 1

    def minimumEdgeRemove(self, n: int, edges: List[List[int]]) -> int:
        adj = [[] for _ in range(n)]
        vis = [False] * n
        for i in edges:
            adj[i[0] - 1].append(i[1] - 1)
            adj[i[1] - 1].append(i[0] - 1)
        self.dfs(0, vis, adj)
        return self.ans
#{ 
 # Driver Code Starts
class IntMatrix:

    def __init__(self) -> None:
        pass

    def Input(self, n, m):
        matrix = []
        #matrix input
        for _ in range(n):
            matrix.append([int(i) for i in input().strip().split()])
        return matrix

    def Print(self, arr):
        for i in arr:
            for j in i:
                print(j, end=" ")
            print()


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):

        n = int(input())

        edges = IntMatrix().Input(n - 1, 2)

        obj = Solution()
        res = obj.minimumEdgeRemove(n, edges)

        print(res)

# } Driver Code Ends


================================================================================
Date: 2024-05-17
Problem: Find Pair Given Difference
Filename: 2024-05-17_Find_Pair_Given_Difference.py
================================================================================


from typing import List

class Solution:
    def findPair(self, n: int, x: int, arr: List[int]) -> int:
        seen = set()
        
        for i in range(n):
            if (arr[i] - x) in seen or (arr[i] + x) in seen:
                return 1
            seen.add(arr[i])
        
        return -1
#{ 
 # Driver Code Starts
class IntArray:

    def __init__(self) -> None:
        pass

    def Input(self, n):
        arr = [int(i) for i in input().strip().split()]  #array input
        return arr

    def Print(self, arr):
        for i in arr:
            print(i, end=" ")
        print()


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):

        n = int(input())

        x = int(input())

        arr = IntArray().Input(n)

        obj = Solution()
        res = obj.findPair(n, x, arr)

        print(res)

# } Driver Code Ends


================================================================================
Date: 2024-05-18
Problem: Find the Highest number
Filename: 2024-05-18_Find_the_Highest_number.py
================================================================================

#User function Template for python3
from typing import List

class Solution:
    def findPeakElement(self, a: List[int]) -> int:
        return max(a)

#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    T = int(input())
    for i in range(T):
        n = int(input())
        a = list(map(int, input().split()))
        ob = Solution()
        ans = ob.findPeakElement(a)
        print(ans)

# } Driver Code Ends


================================================================================
Date: 2024-05-19
Problem: Find the closest number
Filename: 2024-05-19_Find_the_closest_number.py
================================================================================


from typing import List

class Solution:
    def findClosest(self, n: int, k: int, arr: List[int]) -> int:
        from bisect import bisect_left
        r = bisect_left(arr, k)
        l = r - 1
        if l < 0:
            return arr[r]
        else:
            diff1 = abs(k - arr[r]) if r < n else float('inf')
            diff2 = abs(k - arr[l])
            if diff1 <= diff2:
                return arr[r]
            return arr[l]


#{ 
 # Driver Code Starts

class IntArray:
    def __init__(self) -> None:
        pass
    def Input(self,n):
        arr=[int(i) for i in input().strip().split()]#array input
        return arr
    def Print(self,arr):
        for i in arr:
            print(i,end=" ")
        print()


if __name__=="__main__":
    t = int(input())
    for _ in range(t):
        
        n = int(input())
        
        
        k = int(input())
        
        
        arr=IntArray().Input(n)
        
        obj = Solution()
        res = obj.findClosest(n, k, arr)
        
        print(res)
        

# } Driver Code Ends


================================================================================
Date: 2024-05-20
Problem: Modular Exponentiation for large numbers
Filename: 2024-05-20_Modular_Exponentiation_for_large_numbers.py
================================================================================

#User function Template for python3

class Solution:
    def PowMod(self, x, n, m):
        if n == 0:
            return 1  # Base case: x^0 is 1

        x %= m
        half = self.PowMod(x, n // 2, m)

        if n % 2 == 0:
            return (half * half) % m
        else:
            return (((half * half) % m) * x) % m


#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
	T=int(input())
	for i in range(T):
		x, n , m = input().split()
		x = int(x)
		n = int(n) 
		m = int(m)
		ob = Solution();
		ans = ob.PowMod(x, n, m)
		print(ans)
# } Driver Code Ends


================================================================================
Date: 2024-05-21
Problem: K closest elements
Filename: 2024-05-21_K_closest_elements.py
================================================================================

#User function Template for Python 

class Solution:
    def printKClosest(self, arr, n, k, x):
       
        def findCrossOver(arr, low, high, x):
            if arr[high] <= x:
                return high
            if arr[low] > x:
                return low
            mid = (low + high) // 2
            if arr[mid] <= x and arr[mid + 1] > x:
                return mid
            elif arr[mid] < x:
                return findCrossOver(arr, mid + 1, high, x)
            return findCrossOver(arr, low, mid - 1, x)
        
        result = []
        closest = []
        
        l = findCrossOver(arr, 0, n - 1, x) 
        r = l + 1 
        count = 0
        
        if arr[l] == x: 
            l -= 1
       
        
        while l >= 0 and r < n and count < k:
            if (x - arr[l] < arr[r] - x):
                closest.append(arr[l])
                l -= 1
            else:
                closest.append(arr[r])
                r += 1
            count += 1
        
        
        while (count < k and l >= 0):
            closest.append(arr[l])
            l -= 1
            count += 1
        
       
        while (count < k and r < n):
            closest.append(arr[r])
            r += 1
            count += 1
        
        return closest



#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    tc = int(input())
    while tc > 0:
        n = int(input())
        arr = list(map(int, input().strip().split()))
        k, x = list(map(int, input().strip().split()))
        ob = Solution()
        ans = ob.printKClosest(arr, n, k, x)
        for xx in ans:
            print(xx, end=" ")
        print()
        tc -= 1

# } Driver Code Ends


================================================================================
Date: 2024-05-22
Problem: Minimize Max Distance to Gas Station
Filename: 2024-05-22_Minimize_Max_Distance_to_Gas_Station.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3


# } Driver Code Ends
#User function Template for python3
import math

class Solution:
    def countIntervals(self, x, v):
        ret = 0
        for i in range(len(v) - 1):
            ret += math.ceil((v[i + 1] - v[i]) / x) - 1
        return ret

    def findSmallestMaxDist(self, stations, K):
        stations.sort()
        n = len(stations)
        l = 1e-9
        h = stations[-1] - stations[0]

        while (h - l) > 1e-6:
            mid = l + (h - l) / 2.0
            intervals = self.countIntervals(mid, stations)
            if intervals > K:
                l = mid
            else:
                h = mid
        return h


#{ 
 # Driver Code Starts.
import math
if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        N = int(input())
        stations = list(map(int, input().split()))
        K = int(input())
        ob = Solution()
        print('%.2f' % ob.findSmallestMaxDist(stations, K))
# } Driver Code Ends


================================================================================
Date: 2024-05-23
Problem: K-Palindrome
Filename: 2024-05-23_K-Palindrome.py
================================================================================

#User function Template for python3

class Solution:
    def kPalindrome(self, str, n, k):
        prev = [0] * (n + 1)
        curr = [0] * (n + 1)
        
        for i in range(1, n + 1):
            for j in range(1, n + 1):
                if str[i - 1] == str[n - j]:
                    curr[j] = prev[j - 1] + 1
                else:
                    curr[j] = max(prev[j], curr[j - 1])
            prev, curr = curr, prev
        
        lps = prev[n]
        minDeletions = n - lps
        return 1 if minDeletions <= k else 0

#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        arr = input().split()
        n = int(arr[0])
        k = int(arr[1])
        str = input()

        ob = Solution()
        print(ob.kPalindrome(str, n, k))

# } Driver Code Ends


================================================================================
Date: 2024-05-24
Problem: Partitions with Given Difference
Filename: 2024-05-24_Partitions_with_Given_Difference.py
================================================================================


from typing import List

class Solution:
    MOD = 1000000007

    def findWays(self, num: List[int], tar: int) -> int:
        dp = [0] * (tar + 1)
        dp[0] = 2 if num[0] == 0 else 1

        if num[0] != 0 and num[0] <= tar:
            dp[num[0]] = 1

        for ind in range(1, len(num)):
            for target in range(tar, num[ind] - 1, -1):
                dp[target] = (dp[target] + dp[target - num[ind]]) % self.MOD
        
        return dp[tar]

    def countPartitions(self, n: int, d: int, arr: List[int]) -> int:
        total_sum = sum(arr)
        if total_sum < d or (total_sum - d) % 2 != 0:
            return 0
        return self.findWays(arr, (total_sum - d) // 2)

#{ 
 # Driver Code Starts

class IntArray:
    def __init__(self) -> None:
        pass
    def Input(self,n):
        arr=[int(i) for i in input().strip().split()]#array input
        return arr
    def Print(self,arr):
        for i in arr:
            print(i,end=" ")
        print()


if __name__=="__main__":
    t = int(input())
    for _ in range(t):
        
        n = int(input())
        
        
        d = int(input())
        
        
        arr=IntArray().Input(n)
        
        obj = Solution()
        res = obj.countPartitions(n, d, arr)
        
        print(res)
        

# } Driver Code Ends


================================================================================
Date: 2024-05-25
Problem: You and your books
Filename: 2024-05-25_You_and_your_books.py
================================================================================

class Solution:
    # Function to find the maximum number of books
    def max_Books(self, n, k, arr):
        max_sum = 0
        current_sum = 0

        for i in range(n):
            if arr[i] <= k:
                current_sum += arr[i]
                max_sum = max(max_sum, current_sum)
            else:
                current_sum = 0

        return max_sum

#{ 
 # Driver Code Starts
if __name__ == '__main__':
    t = int(input())
    for i in range(t):
        temp = list(map(int, input().strip().split()))
        n = temp[0]
        k = temp[1]
        arr = list(map(int, input().strip().split()))
        ob = Solution()
        print(ob.max_Books(n, k, arr))
# Contributed by:Harshit Sidhwa

# } Driver Code Ends


================================================================================
Date: 2024-05-26
Problem: Minimum Cost To Make Two Strings Identical
Filename: 2024-05-26_Minimum_Cost_To_Make_Two_Strings_Identical.py
================================================================================

#User function Template for python3
class Solution:
    def lcs(self, x, y):
        n, m = len(x), len(y)
        prev = [0] * (m + 1)
        curr = [0] * (m + 1)

        for i in range(1, n + 1):
            for j in range(1, m + 1):
                if x[i - 1] == y[j - 1]:
                    curr[j] = prev[j - 1] + 1
                else:
                    curr[j] = max(prev[j], curr[j - 1])
            prev, curr = curr, prev
        return prev[m]

    def findMinCost(self, x, y, costX, costY):
        length = self.lcs(x, y)
        return costX * (len(x) - length) + costY * (len(y) - length)

#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    T = int(input())
    for i in range(T):
        X, Y, costX, costY = input().split()
        costX = int(costX)
        costY = int(costY)
        ob = Solution()
        ans = ob.findMinCost(X, Y, costX, costY)
        print(ans)

# } Driver Code Ends


================================================================================
Date: 2024-05-27
Problem: Longest subsequence-1
Filename: 2024-05-27_Longest_subsequence-1.py
================================================================================


from typing import List

class Solution:
    def longestSubseq(self, n : int, a : List[int]) -> int:
        dp = {}
        ans = 0

        for x in a:
            len1 = dp.get(x - 1, 0) + 1
            len2 = dp.get(x + 1, 0) + 1
            dp[x] = max(dp.get(x, 0), len1, len2)
            ans = max(ans, dp[x])

        return ans



#{ 
 # Driver Code Starts
class IntArray:

    def __init__(self) -> None:
        pass

    def Input(self, n):
        arr = [int(i) for i in input().strip().split()]  #array input
        return arr

    def Print(self, arr):
        for i in arr:
            print(i, end=" ")
        print()


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):

        n = int(input())

        a = IntArray().Input(n)

        obj = Solution()
        res = obj.longestSubseq(n, a)

        print(res)

# } Driver Code Ends


================================================================================
Date: 2024-05-28
Problem: Minimum cost to fill given weight in a bag
Filename: 2024-05-28_Minimum_cost_to_fill_given_weight_in_a_bag.py
================================================================================


from typing import List

class Solution:
    def findMinCost(self, index: int, cost: List[int], weight: int, memo: List[List[int]]) -> int:
        if weight == 0:
            return 0
        if index >= len(cost) or index + 1 > weight:
            return float('inf')
        if memo[index][weight] != -1:
            return memo[index][weight]

        includeCurrent = float('inf')
        if cost[index] != -1 and index + 1 <= weight:
            result = self.findMinCost(index, cost, weight - (index + 1), memo)
            if result != float('inf'):
                includeCurrent = cost[index] + result
        
        excludeCurrent = self.findMinCost(index + 1, cost, weight, memo)
        
        memo[index][weight] = min(includeCurrent, excludeCurrent)
        return memo[index][weight]

    def minimumCost(self, n: int, w: int, cost: List[int]) -> int:
        memo = [[-1] * (w + 1) for _ in range(n + 1)]
        result = self.findMinCost(0, cost, w, memo)
        return -1 if result == float('inf') else result
#{ 
 # Driver Code Starts
class IntArray:

    def __init__(self) -> None:
        pass

    def Input(self, n):
        arr = [int(i) for i in input().strip().split()]  #array input
        return arr

    def Print(self, arr):
        for i in arr:
            print(i, end=" ")
        print()


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):

        n = int(input())

        w = int(input())

        cost = IntArray().Input(n)

        obj = Solution()
        res = obj.minimumCost(n, w, cost)

        print(res)

# } Driver Code Ends


================================================================================
Date: 2024-05-29
Problem: Geek and its Game of Coins
Filename: 2024-05-29_Geek_and_its_Game_of_Coins.py
================================================================================


class Solution:
    def findWinner(self, n: int, x: int, y: int) -> int:
        dp = [0] * (n + 1)
        dp[1] = 1

        for i in range(2, n + 1):
            if i >= 1 and dp[i - 1] == 0:
                dp[i] = 1
            elif i >= x and dp[i - x] == 0:
                dp[i] = 1
            elif i >= y and dp[i - y] == 0:
                dp[i] = 1
            else:
                dp[i] = 0

        return dp[n]


#{ 
 # Driver Code Starts
if __name__ == "__main__":
    t = int(input())
    for _ in range(t):

        n = int(input())

        x = int(input())

        y = int(input())

        obj = Solution()
        res = obj.findWinner(n, x, y)

        print(res)

# } Driver Code Ends


================================================================================
Date: 2024-05-30
Problem: String Subsequence
Filename: 2024-05-30_String_Subsequence.py
================================================================================


class Solution:
    def countWays(self, s1: str, s2: str) -> int:
        n, m = len(s1), len(s2)
        memo = [[-1] * (m + 1) for _ in range(n + 1)]
        mod = 10**9 + 7

        def dp(i, j):
            if j == 0:
                return 1  # s2 is empty, one way to match
            if i == 0:
                return 0  # s1 is empty, no way to match
            if memo[i][j] != -1:
                return memo[i][j]

            if s1[i - 1] == s2[j - 1]:
                memo[i][j] = (dp(i - 1, j - 1) + dp(i - 1, j)) % mod
            else:
                memo[i][j] = dp(i - 1, j) % mod

            return memo[i][j]

        return dp(n, m)
#{ 
 # Driver Code Starts
if __name__ == "__main__":
    t = int(input())
    for _ in range(t):

        s1 = (input())

        s2 = (input())

        obj = Solution()
        res = obj.countWays(s1, s2)

        print(res)

# } Driver Code Ends


================================================================================
Date: 2024-05-31
Problem: Swap two nibbles in a byte
Filename: 2024-05-31_Swap_two_nibbles_in_a_byte.py
================================================================================

#User function Template for python3
class Solution:
    def swapNibbles(self, n: int) -> int:
        rn = (n & 0xF0) >> 4  
        ln = (n & 0x0F) << 4  
        return rn | ln


#{ 
 # Driver Code Starts
#Initial Template for Python 3
if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        n = int(input())

        ob = Solution()
        print(ob.swapNibbles(n))

# } Driver Code Ends


================================================================================
Date: 2024-06-01
Problem: Odd Even Problem
Filename: 2024-06-01_Odd_Even_Problem.py
================================================================================

class Solution:
    def oddEven(self, s: str) -> str:
        x = 0
        y = 0
        count = [0] * 26
        for c in s:
            count[ord(c) - ord('a')] += 1
        for i in range(26):
            if count[i] > 0:
                if count[i] % 2 == 0 and (i + 1) % 2 == 0:
                    x += 1
                elif count[i] % 2 == 1 and (i + 1) % 2 == 1:
                    y += 1
        
        sum_value = x + y
        return "ODD" if sum_value % 2 == 1 else "EVEN"

 



#{ 
 # Driver Code Starts
if __name__ == "__main__":
    t = int(input())
    for _ in range(t):

        s = (input())

        obj = Solution()
        res = obj.oddEven(s)

        print(res)

# } Driver Code Ends


================================================================================
Date: 2024-06-02
Problem: Construct list using given q XOR queries
Filename: 2024-06-02_Construct_list_using_given_q_XOR_queries.py
================================================================================


from typing import List

class Solution:
    def constructList(self, q: int, queries: List[List[int]]) -> List[int]:
        xr = 0
        results = []
        for i in range(q - 1, -1, -1):
            if queries[i][0] == 0:
                results.append(queries[i][1] ^ xr)
            else:
                xr ^= queries[i][1]
        results.append(xr)
        results.sort()
        return results
#{ 
 # Driver Code Starts
class IntMatrix:

    def __init__(self) -> None:
        pass

    def Input(self, n, m):
        matrix = []
        #matrix input
        for _ in range(n):
            matrix.append([int(i) for i in input().strip().split()])
        return matrix

    def Print(self, arr):
        for i in arr:
            for j in i:
                print(j, end=" ")
            print()


class IntArray:

    def __init__(self) -> None:
        pass

    def Input(self, n):
        arr = [int(i) for i in input().strip().split()]  #array input
        return arr

    def Print(self, arr):
        for i in arr:
            print(i, end=" ")
        print()


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):

        q = int(input())

        queries = IntMatrix().Input(q, 2)

        obj = Solution()
        res = obj.constructList(q, queries)

        IntArray().Print(res)

# } Driver Code Ends


================================================================================
Date: 2024-06-03
Problem: Trail of ones
Filename: 2024-06-03_Trail_of_ones.py
================================================================================

#User function Template for python3
class Solution:
    def numberOfConsecutiveOnes(self, n):
        MOD = 1000000007  # Removed underscores for compatibility
        if n == 1 or n == 2:
            return 1
        a, b = 1, 1
        res = 1
        for i in range(3, n + 1):
            c = (a + b) % MOD
            a, b = b, c
            res = (res * 2 + a) % MOD
        return res
#{ 
 # Driver Code Starts
#Initial Template for Python 3
if __name__ == '__main__':
    t = int(input())
    for _ in range(t):

        N = int(input())

        ob = Solution()
        print(ob.numberOfConsecutiveOnes(N))

# } Driver Code Ends


================================================================================
Date: 2024-06-04
Problem: Binary representation of next number
Filename: 2024-06-04_Binary_representation_of_next_number.py
================================================================================

#User function Template for python3
class Solution:
    def binaryNextNumber(self, s):
        s = s.lstrip('0')
        if not s:
            s = '0'
        n = len(s)
        carry = True
        char_array = list(s)
        for i in range(n - 1, -1, -1):
            if char_array[i] == '0':
                char_array[i] = '1'
                carry = False
                break
            else:
                char_array[i] = '0'
        if carry:
            s = '1' + ''.join(char_array)
        else:
            s = ''.join(char_array)
        
        return s


#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    T = int(input())
    for i in range(T):
        S = input()
        ob = Solution()
        ans = ob.binaryNextNumber(S)
        print(ans)

# } Driver Code Ends

================================================================================
Date: 2024-06-05
Problem: Swapping pairs make sum equal
Filename: 2024-06-05_Swapping_pairs_make_sum_equal.py
================================================================================

class Solution:
    def findSwapValues(self, a, n, b, m):
        sumA = sum(a)
        sumB = sum(b)
        if (sumA - sumB) % 2 != 0:
            return -1
        target = (sumA - sumB) // 2
        setB = set(b)
        for num in a:
            if (num - target) in setB:
                return 1
        return -1

#{ 
 # Driver Code Starts
if __name__ == '__main__': 
    
    
    t=int(input())
    for _ in range(0,t):
        l=list(map(int,input().split()))
        n=l[0]
        m=l[1]
        a = list(map(int,input().split()))
        b = list(map(int, input().split()))
        ob = Solution()
        print(ob.findSwapValues(a,n,b,m))
# } Driver Code Ends


================================================================================
Date: 2024-06-06
Problem: Max sum in the configuration
Filename: 2024-06-06_Max_sum_in_the_configuration.py
================================================================================

#User function Template for python3

def max_sum(a, n):
    total_sum = sum(a)
    
    curr_sum = 0
    for i in range(n):
        curr_sum += i * a[i]
    
    max_sum_value = curr_sum
    for i in range(1, n):
        curr_sum = curr_sum + total_sum - n * a[n - i]
        max_sum_value = max(max_sum_value, curr_sum)
    
    return max_sum_value


#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    t = int(input())
    for i in range(t):
        n = int(input())
        arr = list(map(int, input().strip().split()))
        print(max_sum(arr, n))

# } Driver Code Ends


================================================================================
Date: 2024-06-07
Problem: Maximum occured integer
Filename: 2024-06-07_Maximum_occured_integer.py
================================================================================

#User function Template for python3
class Solution:
    def maxOccured(self, n, l, r, maxx):
        a = [0] * (maxx + 2)
        for i in range(n):
            a[l[i]] += 1
            if r[i] + 1 <= maxx:
                a[r[i] + 1] -= 1
        
        maxCount = a[0]
        result = 0
        for i in range(1, maxx + 1):
            a[i] += a[i - 1]
            if a[i] > maxCount:
                maxCount = a[i]
                result = i
        
        return result

#{ 
 # Driver Code Starts
#Initial Template for Python 3

import math

A = [0] * 1000000


def main():

    T = int(input())

    while (T > 0):

        global A
        A = [0] * 1000000

        n = int(input())

        l = [int(x) for x in input().strip().split()]
        r = [int(x) for x in input().strip().split()]

        maxx = max(r)
        ob = Solution()
        print(ob.maxOccured(n, l, r, maxx))

        T -= 1


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2024-06-08
Problem: Index of an Extra Element
Filename: 2024-06-08_Index_of_an_Extra_Element.py
================================================================================

class Solution:
    def findExtra(self, n, a, b):
        low, high = 0, n - 1
        while low <= high:
            mid = (low + high) // 2
            if mid < len(b) and a[mid] == b[mid]:
                low = mid + 1
            else:
                high = mid - 1
        return low


#{ 
 # Driver Code Starts
if __name__ == "__main__":
    t = int(input())
    for i in range(t):
        n = int(input())
        a = list(map(int, input().split()))
        b = list(map(int, input().split()))
        print(Solution().findExtra(n, a, b))

# } Driver Code Ends


================================================================================
Date: 2024-06-09
Problem: Convert array into Zig-Zag fashion
Filename: 2024-06-09_Convert_array_into_Zig-Zag_fashion.py
================================================================================

from typing import List

class Solution:
    def zigZag(self, n : int, arr : List[int]) -> None:
        for i in range(n - 1):
            if (i % 2 == 0 and arr[i] > arr[i + 1]) or (i % 2 == 1 and arr[i] < arr[i + 1]):
                arr[i], arr[i + 1] = arr[i + 1], arr[i]


#{ 
 # Driver Code Starts
class IntArray:

    def __init__(self) -> None:
        pass

    def Input(self, n):
        arr = [int(i) for i in input().strip().split()]  #array input
        return arr

    def Print(self, arr):
        for i in arr:
            print(i, end=" ")
        print()


if __name__ == "__main__":

    def isZigzag(n: int, arr: List[int]) -> bool:
        f = 1

        for i in range(1, n):
            if f:
                if arr[i - 1] > arr[i]:
                    return False
            else:
                if arr[i - 1] < arr[i]:
                    return False
            f = f ^ 1

        return True

    t = int(input())
    for _ in range(t):

        n = int(input())

        arr = IntArray().Input(n)

        obj = Solution()
        obj.zigZag(n, arr)
        check = True
        check = isZigzag(n, arr)
        if check:
            print("1")
        else:
            print("0")

# } Driver Code Ends


================================================================================
Date: 2024-06-10
Problem: Nuts and Bolts Problem
Filename: 2024-06-10_Nuts_and_Bolts_Problem.py
================================================================================

#User function Template for python3
class Solution:
    def matchPairs(self, n, nuts, bolts):
        # Sort the nuts and bolts arrays
        nuts.sort()
        bolts.sort()
#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    tc = int(input())
    while tc > 0:
        n = int(input())
        nuts = list(map(str, input().strip().split()))
        bolts = list(map(str, input().strip().split()))
        ob = Solution()
        ob.matchPairs(n, nuts, bolts)
        for x in nuts:
            print(x, end=" ")
        print()
        for x in bolts:
            print(x, end=" ")
        print()
        tc -= 1

# } Driver Code Ends


================================================================================
Date: 2024-06-11
Problem: Maximum Tip Calculator
Filename: 2024-06-11_Maximum_Tip_Calculator.py
================================================================================

from typing import List

class Solution:
    def maxTip(self, n: int, x: int, y: int, arr: List[int], brr: List[int]) -> int:
        diff = [(abs(arr[i] - brr[i]), i) for i in range(n)]
        diff.sort(reverse=True, key=lambda x: x[0])

        ans = 0
        for _, i in diff:
            if (arr[i] > brr[i] and x > 0) or y == 0:
                ans += arr[i]
                x -= 1
            else:
                ans += brr[i]
                y -= 1
        return ans


#{ 
 # Driver Code Starts
class IntArray:

    def __init__(self) -> None:
        pass

    def Input(self, n):
        arr = [int(i) for i in input().strip().split()]  #array input
        return arr

    def Print(self, arr):
        for i in arr:
            print(i, end=" ")
        print()


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):

        n = int(input())

        x = int(input())

        y = int(input())

        arr = IntArray().Input(n)

        brr = IntArray().Input(n)

        obj = Solution()
        res = obj.maxTip(n, x, y, arr, brr)

        print(res)

# } Driver Code Ends


================================================================================
Date: 2024-06-12
Problem: Count numbers containing 4
Filename: 2024-06-12_Count_numbers_containing_4.py
================================================================================


class Solution:
    def hasFour(self, n: int) -> bool:
        while n > 0:
            if n % 10 == 4:
                return True
            n //= 10
        return False

    def countNumberswith4(self, n: int) -> int:
        ans = 0
        for i in range(n + 1):
            if self.hasFour(i):
                ans += 1
        return ans



#{ 
 # Driver Code Starts
if __name__ == "__main__":
    t = int(input())
    for _ in range(t):

        n = int(input())

        obj = Solution()
        res = obj.countNumberswith4(n)

        print(res)

# } Driver Code Ends


================================================================================
Date: 2024-06-13
Problem: Padovan Sequence
Filename: 2024-06-13_Padovan_Sequence.py
================================================================================

#User function Template for python3

class Solution:
    def padovanSequence(self, n):
        if n <= 2:
            return 1

        MOD = 1000000007
        pPrevPrev, pPrev, pCurr = 1, 1, 1
        for _ in range(3, n + 1):
            pNext = (pPrevPrev + pPrev) % MOD
            pPrevPrev, pPrev, pCurr = pPrev, pCurr, pNext

        return pCurr

#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        n = int(input())
        ob = Solution()
        print(ob.padovanSequence(n))

# } Driver Code Ends


================================================================================
Date: 2024-06-14
Problem: Armstrong Numbers
Filename: 2024-06-14_Armstrong_Numbers.py
================================================================================

#User function Template for python3

class Solution:
    def armstrongNumber(self, n):
        original = n
        sum = 0
        while n > 0:
            digit = n % 10
            sum += digit ** 3
            n //= 10
        return "true" if sum == original else "false"



#{ 
 # Driver Code Starts
#Initial Template for Python 3
if __name__ == '__main__': 
    t = int (input ())
    for _ in range (t):
        n = input()
        n=int(n)
        ob = Solution()
        print(ob.armstrongNumber(n))
# } Driver Code Ends


================================================================================
Date: 2024-06-15
Problem: Mobile numeric keypad
Filename: 2024-06-15_Mobile_numeric_keypad.py
================================================================================

#User function Template for python3
class Solution:
    def __init__(self):
        self.a = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [-1, 0, -1]]
        self.dp = [[[0 for _ in range(26)] for _ in range(3)] for _ in range(4)]
    
    def getCount(self, n):
        for i in range(4):
            for j in range(3):
                if self.a[i][j] != -1:
                    self.dp[i][j][1] = 1
        
        for length in range(2, n + 1):
            for i in range(4):
                for j in range(3):
                    if self.a[i][j] != -1:
                        self.dp[i][j][length] = self.dp[i][j][length - 1]
                        if j + 1 < 3 and self.a[i][j + 1] != -1:
                            self.dp[i][j][length] += self.dp[i][j + 1][length - 1]
                        if j - 1 >= 0 and self.a[i][j - 1] != -1:
                            self.dp[i][j][length] += self.dp[i][j - 1][length - 1]
                        if i + 1 < 4 and self.a[i + 1][j] != -1:
                            self.dp[i][j][length] += self.dp[i + 1][j][length - 1]
                        if i - 1 >= 0 and self.a[i - 1][j] != -1:
                            self.dp[i][j][length] += self.dp[i - 1][j][length - 1]
        
        ans = 0
        for i in range(4):
            for j in range(3):
                if self.a[i][j] != -1:
                    ans += self.dp[i][j][n]
        
        return ans

#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    T = int(input())
    for i in range(T):
        n = int(input())
        ob = Solution()
        ans = ob.getCount(n)
        print(ans)

# } Driver Code Ends


================================================================================
Date: 2024-06-16
Problem: Prime Pair with Target Sum
Filename: 2024-06-16_Prime_Pair_with_Target_Sum.py
================================================================================


from typing import List

class Solution:
    def getPrimes(self, n: int) -> List[int]:
        if n <= 2:
            return [-1, -1] 
        isPrime = [True] * (n + 1)
        isPrime[0] = isPrime[1] = False
        for i in range(2, int(n**0.5) + 1):
            if isPrime[i]:
                for j in range(i * i, n + 1, i):
                    isPrime[j] = False
        
        result = [-1, -1]
        for i in range(2, n // 2 + 1):
            if isPrime[i] and isPrime[n - i]:
                result[0] = i
                result[1] = n - i
                break
        
        return result       
#{ 
 # Driver Code Starts
class IntArray:

    def __init__(self) -> None:
        pass

    def Input(self, n):
        arr = [int(i) for i in input().strip().split()]  #array input
        return arr

    def Print(self, arr):
        for i in arr:
            print(i, end=" ")
        print()


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):

        n = int(input())

        obj = Solution()
        res = obj.getPrimes(n)

        IntArray().Print(res)

# } Driver Code Ends


================================================================================
Date: 2024-06-17
Problem: Check If two Line segments Intersect
Filename: 2024-06-17_Check_If_two_Line_segments_Intersect.py
================================================================================

#User function Template for python3
class Solution:
    def onSegment(self, p, q, r):
        if min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and min(p[1], r[1]) <= q[1] <= max(p[1], r[1]):
            return True
        return False

    def orientation(self, p, q, r):
        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])
        if val == 0:
            return 0  
        elif val > 0:
            return 1 
        else:
            return 2  

    def doIntersect(self, p1, q1, p2, q2):
        o1 = self.orientation(p1, q1, p2)
        o2 = self.orientation(p1, q1, q2)
        o3 = self.orientation(p2, q2, p1)
        o4 = self.orientation(p2, q2, q1)

        if o1 != o2 and o3 != o4:
            return "true"

        if o1 == 0 and self.onSegment(p1, p2, q1):
            return "true"
        if o2 == 0 and self.onSegment(p1, q2, q1):
            return "true"
        if o3 == 0 and self.onSegment(p2, p1, q2):
            return "true"
        if o4 == 0 and self.onSegment(p2, q1, q2):
            return "true"

        return "false"

#{ 
 # Driver Code Starts
#Initial Template for Python 3

import math

if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        S1 = list(map(int, input().strip().split(" ")))
        S2 = list(map(int, input().strip().split(" ")))
        p1 = []
        q1 = []
        p2 = []
        q2 = []
        p1.append(S1[0])
        p1.append(S1[1])
        q1.append(S1[2])
        q1.append(S1[3])
        p2.append(S2[0])
        p2.append(S2[1])
        q2.append(S2[2])
        q2.append(S2[3])
        ob = Solution()
        ans = ob.doIntersect(p1, q1, p2, q2)
        print(ans)

# } Driver Code Ends


================================================================================
Date: 2024-06-18
Problem: Number of Rectangles in a Circle
Filename: 2024-06-18_Number_of_Rectangles_in_a_Circle.py
================================================================================

#User function template for Python

class Solution:
    def rectanglesInCircle(self, R):
        ans = 0
        limit = 2 * R * 2 * R
        for i in range(1, 2 * R + 1):
            for j in range(1, 2 * R + 1):
                if i * i + j * j <= limit:
                    ans += 1
        return ans

 # Driver Code Starts
#Initial Template for Python

import math

if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        N = int(input())
        ob = Solution()
        ans = ob.rectanglesInCircle(N)
        print(ans)

# } Driver Code Ends


================================================================================
Date: 2024-06-19
Problem: Find maximum volume of a cuboid
Filename: 2024-06-19_Find_maximum_volume_of_a_cuboid.py
================================================================================

#User function Template for python3

class Solution:
    def maxVolume(self, perimeter, area):
        part1 = (perimeter - (perimeter ** 2 - 24 * area) ** 0.5) / 12
        part2 = (perimeter / 4) - (2 * part1)
        ans = part1 ** 2 * part2
        return ans


#{ 
 # Driver Code Starts
#Initial Template for Python 3
import math
if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        perimeter, area = [int(x) for x in input().split()]

        ob = Solution()
        print('%.2f' % ob.maxVolume(perimeter, area))

# } Driver Code Ends


================================================================================
Date: 2024-06-20
Problem: Integral Points Inside Triangle
Filename: 2024-06-20_Integral_Points_Inside_Triangle.py
================================================================================

#User function Template for python3

class Solution:
    def gcd(self, a, b):
        while b != 0:
            a, b = b, a % b
        return a

    def boundaryPoints(self, x1, y1, x2, y2):
        return self.gcd(abs(x2 - x1), abs(y2 - y1)) + 1

    def InternalCount(self, p, q, r):
        area = abs(p[0] * (q[1] - r[1]) + q[0] * (r[1] - p[1]) + r[0] * (p[1] - q[1]))

        B = self.boundaryPoints(p[0], p[1], q[0], q[1]) + \
            self.boundaryPoints(q[0], q[1], r[0], r[1]) + \
            self.boundaryPoints(r[0], r[1], p[0], p[1]) - 3

        I = (area - B + 2) // 2

        return I


#{ 
 # Driver Code Starts
#Initial Template for Python 3

import math
        
if __name__=='__main__':
    t=int(input())
    for _ in range(t):
        p=[0]*2
        q=[0]*2
        r=[0]*2
        p[0],p[1],q[0],q[1],r[0],r[1]=map(int,input().strip().split(" "))
        ob=Solution()
        ans=ob.InternalCount(p,q,r);
        print(ans)
# } Driver Code Ends


================================================================================
Date: 2024-06-21
Problem: Compare two fractions
Filename: 2024-06-21_Compare_two_fractions.py
================================================================================

#User function Template for python3


class Solution:
    def compareFrac(self, s):
        parts = s.split(", ")
        a, b = map(int, parts[0].split('/'))
        c, d = map(int, parts[1].split('/'))

        if a * d > b * c:
            return "{}/{}".format(a, b)
        elif a * d < b * c:
            return "{}/{}".format(c, d)
        else:
            return "equal"



#{ 
 # Driver Code Starts
#Initial Template for Python 3
import re

if __name__ == '__main__':
    ob = Solution()
    t = int(input())
    for _ in range(t):
        str = input()
        print(ob.compareFrac(str))

# } Driver Code Ends


================================================================================
Date: 2024-06-22
Problem: Extract the Number from the String
Filename: 2024-06-22_Extract_the_Number_from_the_String.py
================================================================================

import re

class Solution:
    def ExtractNumber(self, sentence):
        numbers = re.findall(r'\d+', sentence)
        
        answer = -1
        max_value = -1
        
        for number in numbers:
            num_value = int(number)
            if '9' not in number and num_value > max_value:
                answer = number
                max_value = num_value
        
        return answer



#{ 
 # Driver Code Starts
t = int(input())
for _ in range(t):
    S = input()
    ob = Solution()
    ans = ob.ExtractNumber(S)
    print(ans)

# } Driver Code Ends


================================================================================
Date: 2024-06-23
Problem: Print Bracket Number
Filename: 2024-06-23_Print_Bracket_Number.py
================================================================================

#User function Template for python3
class Solution:
    def bracketNumbers(self, str):
        op = 0
        result = []
        stack = []

        for c in str:
            if c == '(':
                op += 1
                stack.append(op)
                result.append(op)
            elif c == ')':
                result.append(stack.pop())

        return result


#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    T = int(input())
    for i in range(T):
        S = input()
        ob = Solution()
        answer = ob.bracketNumbers(S)
        for value in answer:
            print(value, end=" ")
        print()

# } Driver Code Ends


================================================================================
Date: 2024-06-24
Problem: Summed Matrix
Filename: 2024-06-24_Summed_Matrix.py
================================================================================

#User function Template for python3

class Solution:
    def sumMatrix(self, n, q):
        if q > 2 * n:
            return 0
        elif q <= n + 1:
            return q - 1
        else:
            return 2 * n - q + 1
#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        n, q = map(int, input().split())

        ob = Solution()
        print(ob.sumMatrix(n, q))

# } Driver Code Ends


================================================================================
Date: 2024-06-25
Problem: Left Rotate Matrix K times
Filename: 2024-06-25_Left_Rotate_Matrix_K_times.py
================================================================================

class Solution:
    def rotateMatrix(self, k, mat):
        n = len(mat)
        m = len(mat[0])
        ans = [[0] * m for _ in range(n)]

        k %= m

        for i in range(n):
            for j in range(m):
                new_col = (j - k + m) % m
                ans[i][new_col] = mat[i][j]
        
        return ans



#{ 
 # Driver Code Starts
import math

if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        n, m, k = map(int, input().strip().split(" "))
        mat = []
        for i in range(n):
            mat.append(list(map(int, input().strip().split(" "))))
        ob = Solution()
        ans = ob.rotateMatrix(k, mat)
        for i in range(n):
            for j in range(m):
                print(ans[i][j], end=" ")
            print()

# } Driver Code Ends


================================================================================
Date: 2024-06-26
Problem: Coverage of all Zeros in a Binary Matrix
Filename: 2024-06-26_Coverage_of_all_Zeros_in_a_Binary_Matrix.py
================================================================================

#User function Template for python3

class Solution:
    def FindCoverage(self, matrix):
        cnt = 0
        m, n = len(matrix), len(matrix[0])
        
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == 0:
                    if j < n - 1 and matrix[i][j + 1] == 1:
                        cnt += 1  # Right
                    if j > 0 and matrix[i][j - 1] == 1:
                        cnt += 1  # Left
                    if i < m - 1 and matrix[i + 1][j] == 1:
                        cnt += 1  # Down
                    if i > 0 and matrix[i - 1][j] == 1:
                        cnt += 1  # Up
        
        return cnt
#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    T = int(input())
    for i in range(T):
        n, m = input().split()
        n = int(n)
        m = int(m)
        matrix = []
        for _ in range(n):
            matrix.append(list(map(int, input().split())))
        ob = Solution()
        ans = ob.FindCoverage(matrix)
        print(ans)

# } Driver Code Ends


================================================================================
Date: 2024-06-27
Problem: Toeplitz matrix
Filename: 2024-06-27_Toeplitz_matrix.py
================================================================================

# You are required to complete this method
# Return True/False or 1/0
def isToepliz(mat):
    mp = {}
    m, n = len(mat), len(mat[0])
    
    for i in range(m):
        for j in range(n):
            diff = i - j
            if diff in mp:
                if mp[diff] != mat[i][j]:
                    return False
            else:
                mp[diff] = mat[i][j]
    
    return True

#{ 
 # Driver Code Starts
# Your code goes here
if __name__ == '__main__':
    t = int(input())
    for i in range(t):
        n, m = list(map(int, input().strip().split()))
        arr = list(map(int, input().strip().split()))
        matrix = [[0 for i in range(m)] for j in range(n)]
        k = 0
        for i in range(n):
            for j in range(m):
                matrix[i][j] = arr[k]
                k += 1
        b = isToepliz(matrix)

        if n == 2 and m == 4:
            print(0)
        else:
            if b == True:
                print("true")
            else:
                print("false")

# } Driver Code Ends


================================================================================
Date: 2024-06-28
Problem: The Palindrome Pattern
Filename: 2024-06-28_The_Palindrome_Pattern.py
================================================================================

#User function Template for python3
class Solution:
    def is_palindrome(self, arr):
        n = len(arr)
        for i in range(n // 2):
            if arr[i] != arr[n - 1 - i]:
                return False
        return True

    def pattern(self, arr):
        n = len(arr)

        for i in range(n):
            if self.is_palindrome(arr[i]):
                return "{} R".format(i)

        for j in range(n):
            col = [arr[i][j] for i in range(n)]
            if self.is_palindrome(col):
                return "{} C".format(j)

        return "-1"
#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    ob = Solution()
    t = int(input())
    for _ in range(t):
        n = int(input())
        arr = list(map(int, input().split()))
        a = list()
        c = 0
        for i in range(0, n):
            X = list()
            for j in range(0, n):
                X.append(arr[c])
                c += 1
            a.append(X)
        ans = ob.pattern(a)
        print(ans)

# } Driver Code Ends


================================================================================
Date: 2024-06-29
Problem: Identical Linked Lists
Filename: 2024-06-29_Identical_Linked_Lists.py
================================================================================

# your task is to complete this function
# function should return true/1 if both
# are identical else return false/0
'''
# Node Class    
class node:
    def __init__(self, val):
        self.data = val
        self.next = None
        
'''

#Function to check whether two linked lists are identical or not.
def areIdentical(head1, head2):
    while head1 is not None and head2 is not None:
        if head1.data != head2.data:
            return False
        head1 = head1.next
        head2 = head2.next
    return head1 == head2


#{ 
 # Driver Code Starts
# Node Class
class node:

    def __init__(self, val):
        self.data = val
        self.next = None


# Linked List Class
class Linked_List:

    def __init__(self):
        self.head = None

    def insert(self, val):
        new_node = node(val)
        new_node.data = val
        new_node.next = self.head
        self.head = new_node


def printList(head):
    while head:
        print(head.data, end=' ')
        head = head.next
    print()


def createList(arr, n):
    lis = Linked_List()
    for i in range(n):
        lis.insert(arr[i])
    return lis.head


if __name__ == '__main__':
    t = int(input())
    for i in range(t):
        n = int(input())
        arr = list(map(int, input().strip().split()))
        head1 = createList(arr, n)
        n = int(input())
        arr = list(map(int, input().strip().split()))
        head2 = createList(arr, n)
        if (areIdentical(head1, head2)):
            print('true')
        else:
            print('false')

# } Driver Code Ends


================================================================================
Date: 2024-06-30
Problem: Delete node in Doubly Linked List
Filename: 2024-06-30_Delete_node_in_Doubly_Linked_List.py
================================================================================

class Solution:
    def delete_node(self, head, x):
        if not head:
            return None

        current = head

        for i in range(1, x):
            if not current.next:
                return head  
            current = current.next
        if current == head:
            head = head.next
            if head:
                head.prev = None
            return head
        prev = current.prev
        next = current.next

        if prev:
            prev.next = next
        if next:
            next.prev = prev

        return head



#{ 
 # Driver Code Starts
class Node:

    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None

    @staticmethod
    def print_list(node):
        while node is not None:
            print(node.data, end=" ")
            node = node.next
        print()


if __name__ == "__main__":
    import sys
    input = sys.stdin.read
    data = input().split()

    index = 0
    t = int(data[index])
    index += 1
    for _ in range(t):
        n = int(data[index])
        index += 1
        head = None
        tail = head

        for i in range(n):
            temp = int(data[index])
            index += 1
            if head is None:
                head = Node(temp)
                tail = head
            else:
                new_node = Node(temp)
                tail.next = new_node
                new_node.prev = tail
                tail = new_node

        x = int(data[index])
        index += 1

        obj = Solution()
        res = obj.delete_node(head, x)

        Node.print_list(res)

# } Driver Code Ends


================================================================================
Date: 2024-07-01
Problem: Make Binary Tree From Linked List
Filename: 2024-07-01_Make_Binary_Tree_From_Linked_List.py
================================================================================

# Back-end complete function Template for Python 3

class ListNode:
    def __init__(self, data=0, next=None):
        self.data = data
        self.next = next

class TreeNode:
    def __init__(self, data=0, left=None, right=None):
        self.data = data
        self.left = left
        self.right = right

def convert(head):
    if head is None:
        return None

    root = TreeNode(head.data)
    queue = [root]
    head = head.next

    while head:
        parent = queue.pop(0)

        if head:
            left_child = TreeNode(head.data)
            parent.left = left_child
            queue.append(left_child)
            head = head.next

        if head:
            right_child = TreeNode(head.data)
            parent.right = right_child
            queue.append(right_child)
            head = head.next

    return root



#{ 
 # Driver Code Starts
# Initial Template for Python 3
import atexit
import io
import sys

# Contributed by : Nikhil Kumar Singh

# Linked List node


class ListNode:

    # Constructor to create a new node
    def __init__(self, data):
        self.data = data
        self.next = None


# Tree Node structure
class Tree:

    # Constructor to create a new node
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None


# Class to convert the linked list to Binary Tree
class Conversion:
    # Constructor for storing head of linked list
    # and root for the Binary Tree
    def __init__(self, data=None):
        self.head = None
        self.root = None

    def push(self, new_data):

        # Creating a new linked list node and storing data
        new_node = ListNode(new_data)

        # Make next of new node as head
        new_node.next = self.head

        # Move the head to point to new node
        self.head = new_node

    def levelorderTraversal(self, root):
        mylist = []  # reverse list of nodes
        if root is None:
            return
        que = []
        que.append(root)
        while True:
            n = len(que)
            if n == 0:
                break
            while (n > 0):
                node = que.pop(0)
                mylist.append(node.data)
                if node.left is not None:
                    que.append(node.left)
                if node.right is not None:
                    que.append(node.right)
                n -= 1
        mylist = mylist[::-1]
        print(*mylist)
        return


if __name__ == '__main__':
    test_cases = int(input())
    for cases in range(test_cases):
        n = int(input())
        a = list(map(int, input().strip().split()))
        mylist = Conversion()  # Create Linked List to be used
        for i in range(n):
            mylist.push(a[i])  # push elements in linked list
        # convert the linked list to binary tree
        root = convert(mylist.head)
        mylist.levelorderTraversal(root)

# } Driver Code Ends


================================================================================
Date: 2024-07-02
Problem: linked list of strings forms a palindrome
Filename: 2024-07-02_linked_list_of_strings_forms_a_palindrome.py
================================================================================

#User function Template for python3

'''
class Node:
    def __init__(self,data):
        self.data=data
        self.next=None
'''
def compute(head):
    ans = ""
    t = head
    while t:
        ans += t.data
        t = t.next
    i, j = 0, len(ans) - 1
    while i < j:
        if ans[i] != ans[j]:
            return False
        i += 1
        j -= 1
    return True




#{ 
 # Driver Code Starts
#Initial Template for Python 3


#contributed by RavinderSinghPB
class Node:

    def __init__(self, data):
        self.data = data
        self.next = None


class Llist:

    def __init__(self):
        self.head = None

    def insert(self, data, tail):
        node = Node(data)

        if not self.head:
            self.head = node
            return node

        tail.next = node
        return node


if __name__ == '__main__':
    t = int(input())
    for tcs in range(t):

        n1 = int(input())
        arr1 = input().split()
        ll1 = Llist()
        tail = None
        for nodeData in arr1:
            tail = ll1.insert(nodeData, tail)

        if compute(ll1.head):
            print('true')
        else:
            print('false')

# } Driver Code Ends


================================================================================
Date: 2024-07-03
Problem: Remove all occurences of duplicates in a linked list
Filename: 2024-07-03_Remove_all_occurences_of_duplicates_in_a_linked_list.py
================================================================================

#User function Template for python3

"""
# Linked list Node class

    class Node :
        def __init__(self, val):
            self.data = val
            self.next = None

"""

class Solution:
    def removeAllDuplicates(self, head):
        if not head:
            return None

        dummy = Node(-1)
        dummy.next = head
        prev = dummy
        current = head

        while current:
            is_duplicate = False
            while current.next and current.data == current.next.data:
                current = current.next
                is_duplicate = True
            if is_duplicate:
                prev.next = current.next
            else:
                prev = prev.next
            current = current.next

        return dummy.next




#{ 
 # Driver Code Starts
#Initial Template for Python 3

import atexit
import io
import sys

_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__
_OUTPUT_BUFFER = io.StringIO()
sys.stdout = _OUTPUT_BUFFER


@atexit.register
def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())


# Node Class
class Node:

    def __init__(self, data):  # data -> value stored in node
        self.data = data
        self.next = None


# Linked List Class
class LinkedList:

    def __init__(self):
        self.head = None
        self.tail = None

    # creates a new node with given value and appends it at the end of the linked list
    def append(self, new_value):
        new_node = Node(new_value)
        if self.head is None:
            self.head = new_node
            self.tail = new_node
            return
        self.tail.next = new_node
        self.tail = new_node

    # prints the elements of linked list starting with head
    def printList(self, head):
        if head is None:
            print(' ')
            return
        curr_node = head
        while curr_node:
            print(curr_node.data, end=" ")
            curr_node = curr_node.next
        print(' ')


if __name__ == '__main__':
    t = int(input())
    for cases in range(t):
        N = int(input())
        a = LinkedList()  # create a new linked list 'a'.
        nodes = list(map(int, input().strip().split()))
        for x in nodes:
            a.append(x)
        ob = Solution()
        head = ob.removeAllDuplicates(a.head)
        a.printList(head)

# } Driver Code Ends


================================================================================
Date: 2024-07-04
Problem: Duplicate Subtrees
Filename: 2024-07-04_Duplicate_Subtrees.py
================================================================================

class Solution:

    def __init__(self):
        self.map = defaultdict(int)
        self.result = []

    def helper(self, root):
        if not root:
            return ""
        left = self.helper(root.left)
        right = self.helper(root.right)
        curr = "{} {} {}".format(root.data, left, right)
        if self.map[curr] == 1:
            self.result.append(root)
        self.map[curr] += 1

        return curr

    def printAllDups(self, root):
        self.helper(root)
        self.result.sort(key=lambda node: node.data)
        return self.result



#{ 
 # Driver Code Starts
#Initial Template for Python 3

from collections import deque
from collections import defaultdict


class Node:

    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None


def buildTree(s):
    #Corner Case
    if (len(s) == 0 or s[0] == "N"):
        return None

    # Creating list of strings from input
    # string after spliting by space
    ip = list(map(str, s.split()))

    # Create the root of the tree
    root = Node(int(ip[0]))
    size = 0
    q = deque()

    # Push the root to the queue
    q.append(root)
    size = size + 1

    # Starting from the second element
    i = 1
    while (size > 0 and i < len(ip)):
        # Get and remove the front of the queue
        currNode = q[0]
        q.popleft()
        size = size - 1

        # Get the current node's value from the string
        currVal = ip[i]

        # If the left child is not null
        if (currVal != "N"):

            # Create the left child for the current node
            currNode.left = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.left)
            size = size + 1
        # For the right child
        i = i + 1
        if (i >= len(ip)):
            break
        currVal = ip[i]

        # If the right child is not null
        if (currVal != "N"):

            # Create the right child for the current node
            currNode.right = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.right)
            size = size + 1
        i = i + 1
    return root


def preord(root):
    if not root:
        return
    print(root.data, end=' ')
    preord(root.left)
    preord(root.right)


if __name__ == '__main__':
    test_cases = int(input())
    for cases in range(test_cases):
        s = input()
        root = buildTree(s)
        ob = Solution()
        res = ob.printAllDups(root)
        for i in res:
            preord(i)
            print()

# } Driver Code Ends


================================================================================
Date: 2024-07-05
Problem: Vertical Width of a Binary Tree
Filename: 2024-07-05_Vertical_Width_of_a_Binary_Tree.py
================================================================================

#User function Template for python3
#Function to find the vertical width of a Binary Tree.
def solve(root, x, bounds):
    if not root:
        return
    bounds[0] = max(bounds[0], x)
    bounds[1] = min(bounds[1], x)
    solve(root.left, x - 1, bounds)
    solve(root.right, x + 1, bounds)

def verticalWidth(root):
    if not root:
        return 0
    bounds = [0, 0]
    solve(root, 0, bounds)
    return bounds[0] - bounds[1] + 1
#{ 
 # Driver Code Starts
from collections import deque


# Tree Node
class Node:

    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None


# Function to Build Tree
def buildTree(s):
    #Corner Case
    if (len(s) == 0 or s[0] == "N"):
        return None

    # Creating list of strings from input
    # string after spliting by space
    ip = list(map(str, s.split()))

    # Create the root of the tree
    root = Node(int(ip[0]))
    size = 0
    q = deque()

    # Push the root to the queue
    q.append(root)
    size = size + 1

    # Starting from the second element
    i = 1
    while (size > 0 and i < len(ip)):
        # Get and remove the front of the queue
        currNode = q[0]
        q.popleft()
        size = size - 1

        # Get the current node's value from the string
        currVal = ip[i]

        # If the left child is not null
        if (currVal != "N"):

            # Create the left child for the current node
            currNode.left = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.left)
            size = size + 1
        # For the right child
        i = i + 1
        if (i >= len(ip)):
            break
        currVal = ip[i]

        # If the right child is not null
        if (currVal != "N"):

            # Create the right child for the current node
            currNode.right = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.right)
            size = size + 1
        i = i + 1
    return root


if __name__ == "__main__":
    t = int(input())
    for _ in range(0, t):
        s = input()
        root = buildTree(s)
        print(verticalWidth(root))

# } Driver Code Ends


================================================================================
Date: 2024-07-06
Problem: Populate Inorder Successor for all nodes
Filename: 2024-07-06_Populate_Inorder_Successor_for_all_nodes.py
================================================================================

#User function Template for python3


class Node:

    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None
        self.next = None


class Solution:
    def __init__(self):
        self.prev = None

    def populateNext(self, root):
        if not root:
            return

        self.populateNext(root.left)

        if self.prev:
            self.prev.next = root

        self.prev = root

        self.populateNext(root.right)



#{ 
 # Driver Code Starts
#Initial Template for Python 3

from collections import defaultdict
from collections import deque
from sys import stdin, stdout


class Node:

    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None
        self.next = None


# Function to Build Tree
def buildTree(s):
    #Corner Case
    if (len(s) == 0 or s[0] == "N"):
        return None

    # Creating list of strings from input
    # string after spliting by space
    ip = list(map(str, s.split()))

    # Create the root of the tree
    root = Node(int(ip[0]))
    size = 0
    q = deque()

    # Push the root to the queue
    q.append(root)
    size = size + 1

    # Starting from the second element
    i = 1
    while (size > 0 and i < len(ip)):
        # Get and remove the front of the queue
        currNode = q[0]
        q.popleft()
        size = size - 1

        # Get the current node's value from the string
        currVal = ip[i]

        # If the left child is not null
        if (currVal != "N"):

            # Create the left child for the current node
            currNode.left = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.left)
            size = size + 1
        # For the right child
        i = i + 1
        if (i >= len(ip)):
            break
        currVal = ip[i]

        # If the right child is not null
        if (currVal != "N"):

            # Create the right child for the current node
            currNode.right = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.right)
            size = size + 1
        i = i + 1
    return root


def Inorder(root):
    if root.left == None:
        return root
    return Inorder(root.left)


if __name__ == '__main__':
    test_cases = int(input())
    for _ in range(test_cases):
        root = buildTree(input())
        obj = Solution()
        obj.populateNext(root)
        ptr = Inorder(root)
        while ptr:
            print("{}->{}".format(ptr.data,
                                  (ptr.next.data if ptr.next else -1)),
                  end=" ")
            ptr = ptr.next
        print()

# } Driver Code Ends


================================================================================
Date: 2024-07-07
Problem: Ancestors in Binary Tree
Filename: 2024-07-07_Ancestors_in_Binary_Tree.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3

import sys
sys.setrecursionlimit(50000)
from collections import deque
# Tree Node
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None

'''
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None
'''

# Function to Build Tree   
def buildTree(s):
    #Corner Case
    if(len(s)==0 or s[0]=="N"):           
        return None
        
    # Creating list of strings from input 
    # string after spliting by space
    ip=list(map(str,s.split()))
    
    # Create the root of the tree
    root=Node(int(ip[0]))                     
    size=0
    q=deque()
    
    # Push the root to the queue
    q.append(root)                            
    size=size+1 
    
    # Starting from the second element
    i=1                                       
    while(size>0 and i<len(ip)):
        # Get and remove the front of the queue
        currNode=q[0]
        q.popleft()
        size=size-1
        
        # Get the current node's value from the string
        currVal=ip[i]
        
        # If the left child is not null
        if(currVal!="N"):
            
            # Create the left child for the current node
            currNode.left=Node(int(currVal))
            
            # Push it to the queue
            q.append(currNode.left)
            size=size+1
        # For the right child
        i=i+1
        if(i>=len(ip)):
            break
        currVal=ip[i]
        
        # If the right child is not null
        if(currVal!="N"):
            
            # Create the right child for the current node
            currNode.right=Node(int(currVal))
            
            # Push it to the queue
            q.append(currNode.right)
            size=size+1
        i=i+1
    return root
    

# } Driver Code Ends
#User function Template for python3
'''
# Node Class:
class Node:
    def __init__(self,val):
        self.data = val
        self.left = None
        self.right = None
'''


class Solution:
    def findAncestors(self, root, target, ancestors):
        if root is None:
            return False

        if root.data == target:
            return True

        if (self.findAncestors(root.left, target, ancestors) or 
            self.findAncestors(root.right, target, ancestors)):
            ancestors.append(root.data)
            return True

        return False

    def Ancestors(self, root, target):
        ancestors = []
        self.findAncestors(root, target, ancestors)
        return ancestors



#{ 
 # Driver Code Starts.
if __name__=="__main__":
    t=int(input())
    for _ in range(0,t):
        s=input()
        root=buildTree(s)
        target=int(input())
        nodes = Solution().Ancestors(root, target)
        for node in nodes:
            print(node,end=' ')
        print()


# } Driver Code Ends


================================================================================
Date: 2024-07-08
Problem: Search in Rotated Sorted Array
Filename: 2024-07-08_Search_in_Rotated_Sorted_Array.py
================================================================================

#User function Template for python3

class Solution:
    def search(self, arr, key):
        n = len(arr)
        for i in range(n):
            if arr[i] == key:
                return i
        return -1
#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    t = int(input())

    for _ in range(t):
        A = list(map(int, input().strip().split()))
        k = int(input())
        ob = Solution()
        print(ob.search(A, k))

# } Driver Code Ends


================================================================================
Date: 2024-07-09
Problem: Closest Three Sum
Filename: 2024-07-09_Closest_Three_Sum.py
================================================================================

#User function Template for python3

# arr    : list of integers denoting the elements of the array
# target : as specified in the problem statement

class Solution:
    def threeSumClosest(self, arr, target):
        arr.sort()
        closest_sum = float('inf')
        n = len(arr)

        for i in range(n - 2):
            left, right = i + 1, n - 1

            while left < right:
                current_sum = arr[i] + arr[left] + arr[right]

                if current_sum == target:
                    return current_sum

                if abs(current_sum - target) < abs(closest_sum - target) or (
                    abs(current_sum - target) == abs(closest_sum - target) and current_sum > closest_sum):
                    closest_sum = current_sum

                if current_sum < target:
                    left += 1
                else:
                    right -= 1

        return closest_sum
#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    t = int(input())

    for _ in range(t):
        A = list(map(int, input().strip().split()))
        k = int(input())
        ob = Solution()
        print(ob.threeSumClosest(A, k))

# } Driver Code Ends


================================================================================
Date: 2024-07-10
Problem: Largest square formed in a matrix
Filename: 2024-07-10_Largest_square_formed_in_a_matrix.py
================================================================================


from typing import List

class Solution:
    def maxSquare(self, n: int, m: int, mat: List[List[int]]) -> int:
        dp = [0] * m
        maxsize = 0
        prev = 0

        for i in range(n):
            for j in range(m):
                temp = dp[j]
                if i == 0 or j == 0:
                    dp[j] = mat[i][j]
                elif mat[i][j] == 1:
                    dp[j] = min(dp[j], dp[j - 1], prev) + 1
                else:
                    dp[j] = 0
                maxsize = max(maxsize, dp[j])
                prev = temp

        return maxsize



#{ 
 # Driver Code Starts
class IntMatrix:

    def __init__(self) -> None:
        pass

    def Input(self, n, m):
        matrix = []
        #matrix input
        for _ in range(n):
            matrix.append([int(i) for i in input().strip().split()])
        return matrix

    def Print(self, arr):
        for i in arr:
            for j in i:
                print(j, end=" ")
            print()


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):

        n, m = map(int, input().split())

        mat = IntMatrix().Input(n, m)

        obj = Solution()
        res = obj.maxSquare(n, m, mat)

        print(res)

# } Driver Code Ends


================================================================================
Date: 2024-07-11
Problem: Maximum Connected group
Filename: 2024-07-11_Maximum_Connected_group.py
================================================================================

from typing import List, Set
from collections import defaultdict, deque

class Solution:
    def __init__(self):
        self.directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    def bfs(self, grid: List[List[int]], i: int, j: int, index: int) -> int:
        n = len(grid)
        queue = deque([(i, j)])
        grid[i][j] = index
        area_size = 0

        while queue:
            x, y = queue.popleft()
            area_size += 1
            for dx, dy in self.directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 1:
                    grid[nx][ny] = index
                    queue.append((nx, ny))

        return area_size

    def findNeighbours(self, grid: List[List[int]], i: int, j: int) -> Set[int]:
        n = len(grid)
        neighbors = set()
        for dx, dy in self.directions:
            ni, nj = i + dx, j + dy
            if 0 <= ni < n and 0 <= nj < n and grid[ni][nj] > 1:
                neighbors.add(grid[ni][nj])
        return neighbors

    def MaxConnection(self, grid: List[List[int]]) -> int:
        n = len(grid)
        index = 2
        area = defaultdict(int)
        max_area = 0
        for i in range(n):
            for j in range(n):
                if grid[i][j] == 1:
                    area[index] = self.bfs(grid, i, j, index)
                    max_area = max(max_area, area[index])
                    index += 1
        for i in range(n):
            for j in range(n):
                if grid[i][j] == 0:
                    neighbors = self.findNeighbours(grid, i, j)
                    potential_area = 1 + sum(area[idx] for idx in neighbors)
                    max_area = max(max_area, potential_area)

        return max_area


#{ 
 # Driver Code Starts
class IntMatrix:

    def __init__(self) -> None:
        pass

    def Input(self, n, m):
        matrix = []
        #matrix input
        for _ in range(n):
            matrix.append([int(i) for i in input().strip().split()])
        return matrix

    def Print(self, arr):
        for i in arr:
            for j in i:
                print(j, end=" ")
            print()


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):

        n = int(input())

        grid = IntMatrix().Input(n, n)

        obj = Solution()
        res = obj.MaxConnection(grid)

        print(res)

# } Driver Code Ends


================================================================================
Date: 2024-07-12
Problem: Root to leaf path sum
Filename: 2024-07-12_Root_to_leaf_path_sum.py
================================================================================

#User function Template for python3
'''
class Node:
    def __init__(self,val):
        self.data = val
        self.left = None
        self.right = None
'''


class Solution:
    def hasPathSum(self, root, target):
        if root is None:
            return False
        target -= root.data
        if root.left is None and root.right is None:
            return target == 0
        return self.hasPathSum(root.left, target) or self.hasPathSum(root.right, target)
        
#{ 
 # Driver Code Starts
#Initial Template for Python 3

from collections import deque


# Tree Node
class Node:

    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None


# Function to Build Tree
def buildTree(s):
    #Corner Case
    if (len(s) == 0 or s[0] == "N"):
        return None

    # Creating list of strings from input
    # string after spliting by space
    ip = list(map(str, s.split()))

    # Create the root of the tree
    root = Node(int(ip[0]))
    size = 0
    q = deque()

    # Push the root to the queue
    q.append(root)
    size = size + 1

    # Starting from the second element
    i = 1
    while (size > 0 and i < len(ip)):
        # Get and remove the front of the queue
        currNode = q[0]
        q.popleft()
        size = size - 1

        # Get the current node's value from the string
        currVal = ip[i]

        # If the left child is not null
        if (currVal != "N"):

            # Create the left child for the current node
            currNode.left = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.left)
            size = size + 1
        # For the right child
        i = i + 1
        if (i >= len(ip)):
            break
        currVal = ip[i]

        # If the right child is not null
        if (currVal != "N"):

            # Create the right child for the current node
            currNode.right = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.right)
            size = size + 1
        i = i + 1
    return root


if __name__ == '__main__':
    test_cases = int(input())
    for cases in range(test_cases):
        s = input()
        root = buildTree(s)
        sum = int(input())
        if Solution().hasPathSum(root, sum) == True:
            print("true")
        else:
            print("false")

# } Driver Code Ends


================================================================================
Date: 2024-07-13
Problem: Shortest Path in Weighted undirected graph
Filename: 2024-07-13_Shortest_Path_in_Weighted_undirected_graph.py
================================================================================

#User function Template for python3
from collections import defaultdict
from heapq import heappush, heappop
from typing import List


class Solution:

    def shortestPath(self, n: int, m: int,
                     edges: List[List[int]]) -> List[int]:
        par = [-1] * (n + 1)
        inf = float('inf')
        dist = [inf] * (n + 1)

        gp = defaultdict(list)

        for a, b, w in edges:
            gp[a].append((b, w))
            gp[b].append((a, w))

        pq = []
        heappush(pq, (0, 1, -1))

        while pq:
            w, node, p = heappop(pq)
            if w > dist[node]:
                continue
            dist[node] = w
            par[node] = p

            for adj, d in gp[node]:
                if dist[adj] > w + d:
                    dist[adj] = w + d
                    heappush(pq, (w + d, adj, node))

        if dist[n] == inf:
            return [-1]

        ans = []
        p = n
        while p != -1:
            ans.append(p)
            p = par[p]

        ans.append(dist[n])
        ans.reverse()

        return ans

#{ 
 # Driver Code Starts
from collections import defaultdict


def check(n, path, edges):
    gp = [{} for i in range(n + 1)]
    for u, v, w in edges:
        if v in gp[u]:
            gp[u][v] = min(gp[u][v], w)
        else:
            gp[u][v] = w

        if u in gp[v]:
            gp[v][u] = min(gp[v][u], w)
        else:
            gp[v][u] = w

    s = 0
    for i in range(2, len(path)):
        if path[i] not in gp[path[i - 1]]:
            return False
        s += gp[path[i - 1]][path[i]]

    return s == path[0]


if __name__ == "__main__":
    for _ in range(int(input())):
        n, m = map(int, input().split())
        edges = []
        for i in range(m):
            a, b, w = map(int, input().split())
            edges.append([a, b, w])

        obj = Solution()
        res = obj.shortestPath(n, m, edges)
        if res[0] == -1:
            print(-1)
        else:
            if check(n, res, edges):
                print(res[0])
            else:
                print(-2)

# } Driver Code Ends


================================================================================
Date: 2024-07-14
Problem: Segregate 0s and 1s
Filename: 2024-07-14_Segregate_0s_and_1s.py
================================================================================

#User function Template for python3

class Solution:
    def segregate0and1(self, arr):
        left, right = 0, 0
        n = len(arr)

        while right < n:
            if arr[right] == 0:
                arr[left], arr[right] = arr[right], arr[left]
                left += 1
            right += 1



#{ 
 # Driver Code Starts
class IntArray:

    def __init__(self) -> None:
        pass

    def Input(self, n):
        arr = [int(i) for i in input().strip().split()]  #array input
        return arr

    def Print(self, arr):
        for i in arr:
            print(i, end=" ")
        print()


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):

        arr = list(map(int, input().strip().split()))

        obj = Solution()
        obj.segregate0and1(arr)

        print(*arr)

# } Driver Code Ends


================================================================================
Date: 2024-07-15
Problem: Smallest number
Filename: 2024-07-15_Smallest_number.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3

# } Driver Code Ends
#User function Template for python3

class Solution:
    def smallestNumber(self, s, d):
        if s > 9 * d:
            return "-1"

        result = ['0'] * d
        s -= 1

        for i in range(d - 1, -1, -1):
            if s > 9:
                result[i] = '9'
                s -= 9
            else:
                result[i] = chr(ord('0') + s)
                s = 0

        result[0] = chr(ord(result[0]) + 1)  
        return ''.join(result)
#{ 
 # Driver Code Starts.
# Position this line where user code will be pasted.

import sys
import math
input = sys.stdin.read
data = input().split()

t = int(data[0])
index = 1

for _ in range(t):
    s = int(data[index])
    d = int(data[index + 1])
    index += 2
    ob = Solution()
    print(ob.smallestNumber(s, d))

# } Driver Code Ends


================================================================================
Date: 2024-07-16
Problem: Remaining String
Filename: 2024-07-16_Remaining_String.py
================================================================================

#User function Template for python3
class Solution:
    def printString(self, s, ch, count):
        occ = 0

        for i in range(len(s)):
            if s[i] == ch:
                occ += 1
            if occ == count:
                if i + 1 < len(s):
                    return s[i + 1:]
                else:
                    return ""
        return ""

#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    T = int(input())
    for i in range(T):
        s = input()
        ch = input()[0]
        count = int(input())
        ob = Solution()
        answer = ob.printString(s, ch, count)

        print(answer)

# } Driver Code Ends


================================================================================
Date: 2024-07-17
Problem: Construct Binary Tree from Parent Array
Filename: 2024-07-17_Construct_Binary_Tree_from_Parent_Array.py
================================================================================

#User function Template for python3


'''
# A node structure
class Node:
    # A utility function to create a new node
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
'''
class Node:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None

class Solution:
    def createTree(self, parent):
        n = len(parent)
        created = [None] * n
        root = None

        for i in range(n):
            if created[i] is None:
                self.createNode(parent, i, created)

        for i in range(n):
            if parent[i] == -1:
                root = created[i]
                break

        return root

    def createNode(self, parent, i, created):
        if created[i] is not None:
            return

        created[i] = Node(i)

        if parent[i] == -1:
            return

        if created[parent[i]] is None:
            self.createNode(parent, parent[i], created)

        p = created[parent[i]]
        if p.left is None:
            p.left = created[i]
        else:
            p.right = created[i]

#{ 
 # Driver Code Starts
#Initial Template for Python 3
import atexit
import io
import sys
from collections import defaultdict

#Contributed by : Nikhil Kumar Singh
'''
_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__
_OUTPUT_BUFFER = io.StringIO()
sys.stdout = _OUTPUT_BUFFER

@atexit.register

def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())
'''

# Python implementation to construct a Binary Tree from
# parent array


# A node structure
class Node:
    # A utility function to create a new node
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None


# Function should print the level order of the tree in sorted format
def traverse_level_order(root):
    # Code here
    if root is None:
        return
    que = []
    que.append(root)
    while 1:
        n = len(que)
        if n == 0:
            break
        sorted_nodes = [node.key for node in que]
        sorted_nodes.sort()
        print(*sorted_nodes, end=" ")
        while (n > 0):
            node = que.pop(0)
            if node.left != None:
                que.append(node.left)
            if node.right != None:
                que.append(node.right)
            n -= 1


if __name__ == '__main__':
    test_cases = int(input())
    for cases in range(test_cases):
        n = int(input())  # number of nodes in tree
        a = list(map(int,
                     input().strip().split()))  # parent child info in list
        ob = Solution()
        traverse_level_order(ob.createTree(a))
        print()

# } Driver Code Ends


================================================================================
Date: 2024-07-18
Problem: Longest alternating subsequence
Filename: 2024-07-18_Longest_alternating_subsequence.py
================================================================================

#User function Template for python3
class Solution:
    def alternatingMaxLength(self, arr):
        if len(arr) < 2:
            return len(arr)

        up = 1
        down = 1

        for i in range(1, len(arr)):
            if arr[i] > arr[i - 1]:
                up = down + 1
            elif arr[i] < arr[i - 1]:
                down = up + 1

        return max(up, down)



#{ 
 # Driver Code Starts
if __name__ == "__main__":
    import sys
    input = sys.stdin.read
    data = input().splitlines()

    tc = int(data[0])
    for i in range(1, tc + 1):
        s = data[i].strip().split()
        nums = list(map(int, s))
        obj = Solution()
        ans = obj.alternatingMaxLength(nums)
        print(ans)

# } Driver Code Ends


================================================================================
Date: 2024-07-19
Problem: Count Smaller elements
Filename: 2024-07-19_Count_Smaller_elements.py
================================================================================

#User function Template for python3
class Solution:
    def constructLowerArray(self, arr):
        n = len(arr)
        bit = [0] * (n + 1)
        ans = [0] * n

        def update(index, value):
            while index <= n:
                bit[index] += value
                index += index & -index

        def get(index):
            sum = 0
            while index > 0:
                sum += bit[index]
                index -= index & -index
            return sum

        value_index_pairs = [(arr[i], i) for i in range(n)]
        value_index_pairs.sort()

        rank = {value_index_pairs[i][0]: i + 1 for i in range(n)}

        for i in range(n - 1, -1, -1):
            index = rank[arr[i]]
            ans[i] = get(index - 1)
            update(index, 1)

        return ans


#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    tc = int(input())
    while tc > 0:
        arr = list(map(int, input().strip().split()))
        ob = Solution()
        ans = ob.constructLowerArray(arr)
        for x in ans:
            print(x, end=" ")
        print()
        tc -= 1

# } Driver Code Ends


================================================================================
Date: 2024-07-20
Problem: Remove Half Nodes
Filename: 2024-07-20_Remove_Half_Nodes.py
================================================================================

class Solution:
    def RemoveHalfNodes(self, node):
        if node is None:
            return None

        node.left = self.RemoveHalfNodes(node.left)
        node.right = self.RemoveHalfNodes(node.right)

        if node.left is None and node.right is None:
            return node

        if node.left is None:
            new_node = node.right
            node = None
            return new_node

        if node.right is None:
            new_node = node.left
            node = None
            return new_node

        return node



#{ 
 # Driver Code Starts
class Node:

    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None


def buildTree(s):
    if len(s) == 0 or s[0] == 'N':
        return None

    ip = s.split()
    root = Node(int(ip[0]))

    queue = []
    queue.append(root)

    i = 1
    while len(queue) > 0 and i < len(ip):
        currNode = queue.pop(0)
        currVal = ip[i]

        if currVal != 'N':
            currNode.left = Node(int(currVal))
            queue.append(currNode.left)

        i += 1
        if i >= len(ip):
            break

        currVal = ip[i]

        if currVal != 'N':
            currNode.right = Node(int(currVal))
            queue.append(currNode.right)

        i += 1

    return root


def printInorder(root):
    if root is None:
        return

    printInorder(root.left)
    print(root.data, end=' ')
    printInorder(root.right)


if __name__ == "__main__":
    import sys
    input = sys.stdin.read
    data = input().splitlines()

    t = int(data[0])
    index = 1

    while t > 0:
        s = data[index]
        root = buildTree(s)
        solution = Solution()
        fresh = solution.RemoveHalfNodes(root)
        printInorder(fresh)
        print()
        t -= 1
        index += 1

# } Driver Code Ends


================================================================================
Date: 2024-07-21
Problem: Maximum product subset of an array
Filename: 2024-07-21_Maximum_product_subset_of_an_array.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3

# } Driver Code Ends
#User function Template for python3
class Solution:
    def findMaxProduct(self, arr):
        mod = int(1e9 + 7)
        neg_count = 0
        max_neg = float('-inf')
        pos_product = 1
        neg_product = 1
        has_non_zero = False

        for num in arr:
            if num < 0:
                neg_count += 1
                max_neg = max(max_neg, num)

        skip_max_neg = (neg_count % 2 == 1)

        for num in arr:
            if num < 0:
                if skip_max_neg and num == max_neg:
                    skip_max_neg = False
                    continue
                neg_product = (neg_product * abs(num)) % mod
            elif num > 0:
                pos_product = (pos_product * num) % mod
                has_non_zero = True

        if not has_non_zero and neg_count <= 1:
            return 0
        return (neg_product * pos_product) % mod

#{ 
 # Driver Code Starts.
if __name__ == "__main__":
    import sys
    input = sys.stdin.read
    data = input().split()

    index = 0
    t = int(data[index])
    index += 1
    results = []
    
    for _ in range(t):
        n = int(data[index])
        index += 1
        arr = list(map(int, data[index:index + n]))
        index += n
        solution = Solution()
        ans = solution.findMaxProduct(arr)
        results.append(ans)
    
    for result in results:
        print(result)
# } Driver Code Ends


================================================================================
Date: 2024-07-22
Problem: Merge two BST s
Filename: 2024-07-22_Merge_two_BST_s.py
================================================================================

#User function Template for python3
class Info:
    def __init__(self, is_bst, size, min_val, max_val):
        self.is_bst = is_bst
        self.size = size
        self.min_val = min_val
        self.max_val = max_val

class Solution:
    def largestBSTHelper(self, root):
        if root is None:
            return Info(True, 0, float('inf'), float('-inf'))
        
        left_info = self.largestBSTHelper(root.left)
        right_info = self.largestBSTHelper(root.right)
        
        if left_info.is_bst and right_info.is_bst and root.data > left_info.max_val and root.data < right_info.min_val:
            return Info(True, 1 + left_info.size + right_info.size, min(root.data, left_info.min_val), max(root.data, right_info.max_val))
        else:
            return Info(False, max(left_info.size, right_info.size), float('inf'), float('-inf'))
    
    def largestBst(self, root):
        return self.largestBSTHelper(root).size


#{ 
 # Driver Code Starts
from collections import deque


# Tree Node
class Node:

    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None


# Function to Build Tree
def buildTree(s):
    # Corner Case
    if len(s) == 0 or s[0] == "N":
        return None

    # Creating list of strings from input string after splitting by space
    ip = list(map(str, s.split()))

    # Create the root of the tree
    root = Node(int(ip[0]))
    size = 0
    q = deque()

    # Push the root to the queue
    q.append(root)
    size += 1

    # Starting from the second element
    i = 1
    while size > 0 and i < len(ip):
        # Get and remove the front of the queue
        currNode = q.popleft()
        size -= 1

        # Get the current node's value from the string
        currVal = ip[i]

        # If the left child is not null
        if currVal != "N":
            # Create the left child for the current node
            currNode.left = Node(int(currVal))
            # Push it to the queue
            q.append(currNode.left)
            size += 1

        # Move to the next element
        i += 1
        if i >= len(ip):
            break

        currVal = ip[i]

        # If the right child is not null
        if currVal != "N":
            # Create the right child for the current node
            currNode.right = Node(int(currVal))
            # Push it to the queue
            q.append(currNode.right)
            size += 1

        # Move to the next element
        i += 1

    return root


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        s = input()
        root = buildTree(s)
        ob = Solution()
        result = ob.largestBst(root)
        print(result)

# } Driver Code Ends


================================================================================
Date: 2024-07-23
Problem: Problem 23
Filename: 2024-07-23_Problem_23.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3

# } Driver Code Ends

class Solution:

    def inorder(self, root, arr):
        if not root:
            return
        self.inorder(root.left, arr)
        arr.append(root.data)
        self.inorder(root.right, arr)

    def merge(self, root1, root2):
        arr = []
        self.inorder(root1, arr)
        self.inorder(root2, arr)
        arr.sort()
        return arr


#{ 
 # Driver Code Starts.
class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def buildTree(s):
    # Corner Case
    if len(s) == 0 or s[0] == 'N':
        return None
    
    # Creating list of strings from input string after splitting by space
    ip = s.split()
    
    # Create the root of the tree
    root = Node(int(ip[0]))
    
    # Push the root to the queue
    queue = [root]
    
    # Starting from the second element
    i = 1
    while queue and i < len(ip):
        # Get and remove the front of the queue
        currNode = queue.pop(0)
        
        # Get the current node's value from the string
        currVal = ip[i]
        
        # If the left child is not null
        if currVal != "N":
            # Create the left child for the current node
            currNode.left = Node(int(currVal))
            
            # Push it to the queue
            queue.append(currNode.left)
        
        # For the right child
        i += 1
        if i >= len(ip):
            break
        currVal = ip[i]
        
        # If the right child is not null
        if currVal != "N":
            # Create the right child for the current node
            currNode.right = Node(int(currVal))
            
            # Push it to the queue
            queue.append(currNode.right)
        i += 1
    
    return root



def main():
    t = int(input())
    for _ in range(t):
        s = input()
        root1 = buildTree(s)
        s = input()
        root2 = buildTree(s)
        obj = Solution()
        vec = obj.merge(root1, root2)
        print(" ".join(map(str, vec)))

if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2024-07-24
Problem: Check for BST
Filename: 2024-07-24_Check_for_BST.py
================================================================================

#User function Template for python3


class Solution:
    def isBST(self, node):
        return self.isBSTUtil(node, None, None)

    def isBSTUtil(self, node, minNode, maxNode):
        if not node:
            return True

        if (minNode and node.data <= minNode.data) or (maxNode and node.data >= maxNode.data):
            return False

        return self.isBSTUtil(node.left, minNode, node) and self.isBSTUtil(node.right, node, maxNode)

#{ 
 # Driver Code Starts
#Initial Template for Python 3
from collections import deque


# Tree Node
class Node:

    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None


# Function to Build Tree
def buildTree(s):
    #Corner Case
    if (len(s) == 0 or s[0] == "N"):
        return None

    # Creating list of strings from input
    # string after spliting by space
    ip = list(map(str, s.split()))

    # Create the root of the tree
    root = Node(int(ip[0]))
    size = 0
    q = deque()

    # Push the root to the queue
    q.append(root)
    size = size + 1

    # Starting from the second element
    i = 1
    while (size > 0 and i < len(ip)):
        # Get and remove the front of the queue
        currNode = q[0]
        q.popleft()
        size = size - 1

        # Get the current node's value from the string
        currVal = ip[i]

        # If the left child is not null
        if (currVal != "N"):

            # Create the left child for the current node
            currNode.left = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.left)
            size = size + 1
        # For the right child
        i = i + 1
        if (i >= len(ip)):
            break
        currVal = ip[i]

        # If the right child is not null
        if (currVal != "N"):

            # Create the right child for the current node
            currNode.right = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.right)
            size = size + 1
        i = i + 1
    return root


if __name__ == "__main__":
    t = int(input())
    for _ in range(0, t):
        s = input()
        root = buildTree(s)
        if Solution().isBST(root):
            print("true")
        else:
            print("false")

# } Driver Code Ends


================================================================================
Date: 2024-07-25
Problem: Array to BST
Filename: 2024-07-25_Array_to_BST.py
================================================================================

#User function Template for python3
class Solution:
    def sortedArrayToBST(self, nums):
        return self.sortedArrayToBSTUtil(nums, 0, len(nums) - 1)

    def sortedArrayToBSTUtil(self, nums, left, right):
        if left > right:
            return None

        mid = left + (right - left) // 2  

        node = Node(nums[mid])

        node.left = self.sortedArrayToBSTUtil(nums, left, mid - 1)
        node.right = self.sortedArrayToBSTUtil(nums, mid + 1, right)

        return node


#{ 
 # Driver Code Starts
from collections import deque


# Tree Node
class Node:

    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None


def help(root, up, l):
    if root.data >= up or root.data <= l:
        return False
    ans = True
    if root.left:
        ans = help(root.left, root.data, l)
    if ans and root.right:
        ans = help(root.right, up, root.data)
    return ans


def isValidBST(root):
    return help(root, 3147483648, -3147483649)


def height(root):
    if root is None:
        return 0
    leftHeight = height(root.left)
    rightHeight = height(root.right)
    if leftHeight == -1 or rightHeight == -1 or abs(leftHeight -
                                                    rightHeight) > 1:
        return -1
    return max(leftHeight, rightHeight) + 1


def isBalanced(root):
    if root is None:
        return True
    return height(root) != -1


def inorder(root, v):
    if root is None:
        return
    inorder(root.left, v)
    v.append(root.data)
    inorder(root.right, v)


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        arr = list(map(int, input().split()))

        solution = Solution()
        root = solution.sortedArrayToBST(arr)

        v = []
        inorder(root, v)

        if not isValidBST(root) or v != arr:
            print("false")
            continue

        if isBalanced(root):
            print("true")
        else:
            print("false")

# } Driver Code Ends


================================================================================
Date: 2024-07-26
Problem: K-Pangrams
Filename: 2024-07-26_K-Pangrams.py
================================================================================

#User function Template for python3
class Solution:
    def kPangram(self, string, k):
        frequency = {}
        for c in string:
            if c.isalpha():
                frequency[c] = frequency.get(c, 0) + 1

        cnt = 0
        uniq = 0
        for key, value in frequency.items():
            if key.isalpha():
                cnt += value
                uniq += 1

        return cnt >= 26 and (26 - uniq) <= k



#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    T = int(input())

    for tcs in range(T):
        string = input()
        K = int(input())
        ob = Solution()
        a = ob.kPangram(string, K)
        if a:
            print("true")
        else:
            print("false")

# } Driver Code Ends


================================================================================
Date: 2024-07-27
Problem: Form a palindrome
Filename: 2024-07-27_Form_a_palindrome.py
================================================================================

#User function Template for python3

class Solution:
    def countMin(self, str):
        n = len(str)
        table = [[0] * n for _ in range(n)]
        
        for gap in range(1, n):
            for l in range(n - gap):
                h = l + gap
                if str[l] == str[h]:
                    table[l][h] = table[l + 1][h - 1]
                else:
                    table[l][h] = min(table[l][h - 1], table[l + 1][h]) + 1
        
        return table[0][n - 1]
#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':

    t = int(input())

    for _ in range(t):
        Str = input()

        solObj = Solution()

        print(solObj.countMin(Str))

# } Driver Code Ends


================================================================================
Date: 2024-07-28
Problem: Remove Duplicates
Filename: 2024-07-28_Remove_Duplicates.py
================================================================================

#User function Template for python3
class Solution:
    def removeDups(self, str):
        fre = [0] * 26 
        result = [] 
        
        for c in str:
            if fre[ord(c) - ord('a')] == 0:
                result.append(c) 
                fre[ord(c) - ord('a')] = 1 
        
        return ''.join(result)


#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    T = int(input())
    for i in range(T):
        s = input()

        ob = Solution()
        answer = ob.removeDups(s)

        print(answer)

# } Driver Code Ends


================================================================================
Date: 2024-07-29
Problem: Row with max 1s
Filename: 2024-07-29_Row_with_max_1s.py
================================================================================

#User function Template for python3
class Solution:
    def rowWithMax1s(self, arr):
        n = len(arr)        
        m = len(arr[0])       
        max_row_index = -1    
        
        r = 0   
        c = m - 1 
        
        while r < n and c >= 0:
            if arr[r][c] == 1:
                max_row_index = r 
                c -= 1            
            else:
                r += 1            
        
        return max_row_index

#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    tc = int(input())
    while tc > 0:
        n, m = list(map(int, input().strip().split()))

        inputLine = list(map(int, input().strip().split()))
        arr = [[0 for j in range(m)] for i in range(n)]

        for i in range(n):
            for j in range(m):
                arr[i][j] = inputLine[i * m + j]
        ob = Solution()
        ans = ob.rowWithMax1s(arr)
        print(ans)
        tc -= 1

# } Driver Code Ends


================================================================================
Date: 2024-07-30
Problem: Rat in a Maze Problem - I
Filename: 2024-07-30_Rat_in_a_Maze_Problem_-_I.py
================================================================================

from typing import List

class Solution:
    def __init__(self):
        self.visited = []
        self.result = []

    def path(self, m: List[List[int]], x: int, y: int, dir: str, n: int):
        if x == n - 1 and y == n - 1:
            self.result.append(dir)
            return
        if m[x][y] == 0 or self.visited[x][y]:
            return
        
        self.visited[x][y] = True
        if x > 0:
            self.path(m, x - 1, y, dir + 'U', n)
        if y > 0:
            self.path(m, x, y - 1, dir + 'L', n)
        if x < n - 1:
            self.path(m, x + 1, y, dir + 'D', n)
        if y < n - 1:
            self.path(m, x, y + 1, dir + 'R', n)
        self.visited[x][y] = False

    def findPath(self, m: List[List[int]]) -> List[str]:
        n = len(m)
        self.visited = [[False for _ in range(n)] for _ in range(n)]
        self.result = []

        if m[0][0] == 0 or m[n - 1][n - 1] == 0:
            return self.result

        self.path(m, 0, 0, "", n)
        self.result.sort()
        return self.result




#{ 
 # Driver Code Starts
# Main function to read input and output the results
if __name__ == "__main__":
    t = int(input().strip())
    for _ in range(t):
        n = int(input().strip())
        m = []
        for i in range(n):
            m.append(list(map(int, input().strip().split())))
        obj = Solution()
        result = obj.findPath(m)
        result.sort()
        if len(result) == 0:
            print(-1)
        else:
            print(" ".join(result))

# } Driver Code Ends


================================================================================
Date: 2024-07-31
Problem: Longest Common Prefix of Strings
Filename: 2024-07-31_Longest_Common_Prefix_of_Strings.py
================================================================================

#User function Template for python3

class Solution:
    def longestCommonPrefix(self, arr):
        if not arr:
            return "-1"
        prefix = arr[0]

        for i in range(1, len(arr)):
            while not arr[i].startswith(prefix):
                prefix = prefix[:-1]
                if not prefix:
                    return "-1"
        return prefix if prefix else "-1"



#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    t = int(input())

    for _ in range(t):
        arr = [x for x in input().strip().split(" ")]

        ob = Solution()
        print(ob.longestCommonPrefix(arr))

# } Driver Code Ends


================================================================================
Date: 2024-08-01
Problem: Spirally traversing a matrix
Filename: 2024-08-01_Spirally_traversing_a_matrix.py
================================================================================

class Solution:
    def spirallyTraverse(self, matrix):
        output = []
        if not matrix or not matrix[0]:
            return output

        r = len(matrix)
        c = len(matrix[0])
        top, bottom = 0, r - 1
        left, right = 0, c - 1

        while top <= bottom and left <= right:
            for i in range(left, right + 1):
                output.append(matrix[top][i])
            top += 1

            for i in range(top, bottom + 1):
                output.append(matrix[i][right])
            right -= 1

            if top <= bottom:
                for i in range(right, left - 1, -1):
                    output.append(matrix[bottom][i])
                bottom -= 1

            if left <= right:
                for i in range(bottom, top - 1, -1):
                    output.append(matrix[i][left])
                left += 1

        return output
#{ 
 # Driver Code Starts
if __name__ == "__main__":
    import sys
    input = sys.stdin.read
    data = input().split()

    t = int(data[0])
    index = 1
    for _ in range(t):
        r = int(data[index])
        c = int(data[index + 1])
        index += 2
        matrix = []
        for i in range(r):
            row = list(map(int, data[index:index + c]))
            matrix.append(row)
            index += c

        solution = Solution()
        result = solution.spirallyTraverse(matrix)
        print(" ".join(map(str, result)))

# } Driver Code Ends


================================================================================
Date: 2024-08-02
Problem: Edit Distance
Filename: 2024-08-02_Edit_Distance.py
================================================================================

class Solution:
    def editDistance(self, s: str, t: str) -> int:
        m, n = len(s), len(t)
        dp = [[0] * (n + 1) for _ in range(m + 1)]

        for i in range(m + 1):
            for j in range(n + 1):
                if i == 0:
                    dp[i][j] = j
                elif j == 0:
                    dp[i][j] = i
                elif s[i - 1] == t[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1]
                else:
                    dp[i][j] = 1 + min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1])

        return dp[m][n]

#{ 
 # Driver Code Starts
if __name__ == '__main__':
    T = int(input())
    for i in range(T):
        s, t = input().split()
        ob = Solution()
        ans = ob.editDistance(s, t)
        print(ans)

# } Driver Code Ends


================================================================================
Date: 2024-08-03
Problem: The Celebrity Problem
Filename: 2024-08-03_The_Celebrity_Problem.py
================================================================================

class Solution:
    def celebrity(self, mat):
        n = len(mat)
        a = 0
        b = n - 1

        while a < b:
            if mat[a][b] == 1:
                a += 1
            else:
                b -= 1

        for i in range(n):
            if i != a and (mat[a][i] == 1 or mat[i][a] == 0):
                return -1

        return a
#{ 
 # Driver Code Starts
# Main function to handle input and output
if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        n = int(input())
        M = []
        for _ in range(n):
            M.append(list(map(int, input().split())))

        ob = Solution()
        print(ob.celebrity(M))

# } Driver Code Ends


================================================================================
Date: 2024-08-04
Problem: N meetings in one room
Filename: 2024-08-04_N_meetings_in_one_room.py
================================================================================

1)
class Solution:
    def maximumMeetings(self, n, start, end):
        meetings = list(zip(start, end))
        meetings.sort(key=lambda x: x[1])

        count = 0
        last_end_time = 0
        for s, e in meetings:
            if s > last_end_time:
                count += 1
                last_end_time = e

        return count

2)
class Solution:
    def maximumMeetings(self, n, start, end):
        meetings = [(start[i], end[i]) for i in range(n)]
        meetings.sort(key=lambda x: (x[1], x[0]))

        last_end_time = -1
        count = 0
            for meeting in meetings:
            if meeting[0] > last_end_time:
                count += 1
                last_end_time = meeting[1]

        return count

3)
class Solution:
    def maximumMeetings(self, n, start, end):
        meetings = [(start[i], end[i]) for i in range(n)]
        meetings.sort(key=lambda x: x[1])
        count = 0
        last_end_time = -1
        for meeting in meetings:
            if meeting[0] > last_end_time:
                count += 1
                last_end_time = meeting[1]

        return count




#{ 
 # Driver Code Starts
#Initial Template for Python 3
import atexit
import io
import sys

#Contributed by : Nagendra Jha

if __name__ == '__main__':
    test_cases = int(input())
    for cases in range(test_cases) :
        n = int(input())
        start = list(map(int,input().strip().split()))
        end = list(map(int,input().strip().split()))
        ob=Solution()
        print(ob.maximumMeetings(n,start,end))
# } Driver Code Ends


================================================================================
Date: 2024-08-05
Problem: Bottom View of Binary Tree
Filename: 2024-08-05_Bottom_View_of_Binary_Tree.py
================================================================================

#User function Template for python3

from collections import deque, defaultdict

class Solution:
    def bottomView(self, root):
        res = []
        if not root:
            return res
        
        bottom_view_map = defaultdict(int)
        q = deque([(root, 0)])
        
        while q:
            node, hd = q.popleft()
            bottom_view_map[hd] = node.data
            
            if node.left:
                q.append((node.left, hd - 1))
            if node.right:
                q.append((node.right, hd + 1))
        
        for key in sorted(bottom_view_map.keys()):
            res.append(bottom_view_map[key])
        
        return res

#{ 
 # Driver Code Starts
#Initial Template for Python 3

import sys
sys.setrecursionlimit(50000)
#Contributed by Sudarshan Sharma
from collections import deque
from collections import defaultdict
# Tree Node
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None

'''
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None
'''

# Function to Build Tree   
def buildTree(s):
    #Corner Case
    if(len(s)==0 or s[0]=="N"):           
        return None
        
    # Creating list of strings from input 
    # string after spliting by space
    ip=list(map(str,s.split()))
    
    # Create the root of the tree
    root=Node(int(ip[0]))                     
    size=0
    q=deque()
    
    # Push the root to the queue
    q.append(root)                            
    size=size+1 
    
    # Starting from the second element
    i=1                                       
    while(size>0 and i<len(ip)):
        # Get and remove the front of the queue
        currNode=q[0]
        q.popleft()
        size=size-1
        
        # Get the current node's value from the string
        currVal=ip[i]
        
        # If the left child is not null
        if(currVal!="N"):
            
            # Create the left child for the current node
            currNode.left=Node(int(currVal))
            
            # Push it to the queue
            q.append(currNode.left)
            size=size+1
        # For the right child
        i=i+1
        if(i>=len(ip)):
            break
        currVal=ip[i]
        
        # If the right child is not null
        if(currVal!="N"):
            
            # Create the right child for the current node
            currNode.right=Node(int(currVal))
            
            # Push it to the queue
            q.append(currNode.right)
            size=size+1
        i=i+1
    return root
    
    
if __name__=="__main__":
    t=int(input())
    for _ in range(0,t):
        s=input()
        root=buildTree(s)
        ob = Solution()
        res = ob.bottomView(root)
        for i in res:
            print (i, end = " ")
        print()


# } Driver Code Ends


================================================================================
Date: 2024-08-06
Problem: Validate an IP Address
Filename: 2024-08-06_Validate_an_IP_Address.py
================================================================================

#User function Template for python3
class Solution:
    def isValid(self, str):
        n = len(str)
        segments = 0
        num = 0
        length = 0

        for i in range(n):
            if str[i] == '.':
                if length == 0 or length > 3 or num > 255:
                    return False
                segments += 1
                num = 0
                length = 0
            elif str[i].isdigit():
                if length == 0 and str[i] == '0' and (i + 1 < n and str[i + 1] != '.'):
                    return False
                num = num * 10 + int(str[i])
                length += 1
            else:
                return False

        if length == 0 or length > 3 or num > 255:
            return False
        segments += 1

        return segments == 4




#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == "__main__":
    t = int(input())
    for _ in range(0, t):
        s = input()
        ob = Solution()
        if (ob.isValid(s)):
            print("true")
        else:
            print("false")

# } Driver Code Ends


================================================================================
Date: 2024-08-07
Problem: K-th element of two Arrays
Filename: 2024-08-07_K-th_element_of_two_Arrays.py
================================================================================

#User function Template for python3

class Solution:
    def kthElement(self, k, arr1, arr2):
        return self.kth(arr1, arr2, 0, len(arr1), 0, len(arr2), k - 1)

    def kth(self, arr1, arr2, s1, e1, s2, e2, k):
        if s1 >= e1:
            return arr2[s2 + k]
        if s2 >= e2:
            return arr1[s1 + k]
        
        mid1 = (e1 - s1) // 2
        mid2 = (e2 - s2) // 2
        
        if mid1 + mid2 < k:
            if arr1[s1 + mid1] > arr2[s2 + mid2]:
                return self.kth(arr1, arr2, s1, e1, s2 + mid2 + 1, e2, k - mid2 - 1)
            else:
                return self.kth(arr1, arr2, s1 + mid1 + 1, e1, s2, e2, k - mid1 - 1)
        else:
            if arr1[s1 + mid1] > arr2[s2 + mid2]:
                return self.kth(arr1, arr2, s1, s1 + mid1, s2, e2, k)
            else:
                return self.kth(arr1, arr2, s1, e1, s2, s2 + mid2, k)
#{ 
 # Driver Code Starts
#Initial Template for Python 3


def main():

    T = int(input())

    while (T > 0):

        k = int(input())
        a = [int(x) for x in input().strip().split()]
        b = [int(x) for x in input().strip().split()]
        ob = Solution()
        print(ob.kthElement(k, a, b))

        T -= 1


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2024-08-08
Problem: Sum Tree
Filename: 2024-08-08_Sum_Tree.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3
# 
# } Driver Code Ends
#User function Template for python3

'''
class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None
'''

class Solution:

    def is_leaf(self, node):
        if node is None:
            return True
        if node.left is None and node.right is None:
            return True
        return False

    def is_sum_tree(self, node):
        if node is None or self.is_leaf(node):
            return True

        if self.is_sum_tree(node.left) and self.is_sum_tree(node.right):
            ls = 0
            rs = 0

            if node.left is None:
                ls = 0
            elif self.is_leaf(node.left):
                ls = node.left.data
            else:
                ls = 2 * node.left.data

            if node.right is None:
                rs = 0
            elif self.is_leaf(node.right):
                rs = node.right.data
            else:
                rs = 2 * node.right.data

            return node.data == ls + rs

        return False



#{ 
 # Driver Code Starts.
class Node:

    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None


# Utility function to create a new Tree Node
def new_node(val):
    return Node(val)


# Function to Build Tree
def build_tree(s):
    # Corner Case
    if not s or s[0] == 'N':
        return None

    # Creating list of strings from input string after splitting by space
    ip = s.split()

    # Create the root of the tree
    root = new_node(int(ip[0]))

    # Push the root to the queue
    queue = []
    queue.append(root)

    # Starting from the second element
    i = 1
    while queue and i < len(ip):
        # Get and remove the front of the queue
        curr_node = queue.pop(0)

        # Get the current node's value from the string
        curr_val = ip[i]

        # If the left child is not null
        if curr_val != "N":
            # Create the left child for the current node
            curr_node.left = new_node(int(curr_val))

            # Push it to the queue
            queue.append(curr_node.left)

        # For the right child
        i += 1
        if i >= len(ip):
            break
        curr_val = ip[i]

        # If the right child is not null
        if curr_val != "N":
            # Create the right child for the current node
            curr_node.right = new_node(int(curr_val))

            # Push it to the queue
            queue.append(curr_node.right)
        i += 1

    return root


# Driver code
if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        s = input()
        root = build_tree(s)
        ob = Solution()
        if ob.is_sum_tree(root):
            print("true")
        else:
            print("false")

# } Driver Code Ends


================================================================================
Date: 2024-08-09
Problem: Maximize Array Value After Rearrangement
Filename: 2024-08-09_Maximize_Array_Value_After_Rearrangement.py
================================================================================

#User function Template for python3

class Solution:
    def Maximize(self, arr): 
        mod = 10**9 + 7
        arr.sort()  # Sort the array
        ans = 0
        n = len(arr)

        for i in range(n):
            ans = (ans + arr[i] * i) % mod

        return ans



#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    t = int(input())

    for _ in range(t):
        A = list(map(int, input().strip().split()))
        # k = int(input())
        ob = Solution()
        print(ob.Maximize(A))

# } Driver Code Ends


================================================================================
Date: 2024-08-10
Problem: Rotate a Linked List
Filename: 2024-08-10_Rotate_a_Linked_List.py
================================================================================

# Your task is to complete this function

'''

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

'''

class Solution:
    def rotate(self, head, k):
        if not head or not head.next or k == 0:
            return head
        p = head
        while p.next:
            p = p.next
        for i in range(k):
            t = head
            head = head.next
            t.next = None
            p.next = t
            p = t
        
        return head



#{ 
 # Driver Code Starts
#Initial Template for Python 3


# Define the Node class for the linked list
class Node:

    def __init__(self, x):
        self.data = x
        self.next = None


# Function to print the linked list
def printList(node):
    while node:
        print(node.data, end=" ")
        node = node.next
    print()


#Position this line where user code will be pasted.

# Main function
if __name__ == "__main__":
    import sys
    input = sys.stdin.read
    data = input().splitlines()

    t = int(data[0].strip())
    idx = 1

    while t > 0:
        arr = list(map(int, data[idx].strip().split()))

        head = None
        if arr:
            head = Node(arr[0])
            tail = head
            for num in arr[1:]:
                tail.next = Node(num)
                tail = tail.next

        k = int(data[idx + 1].strip())
        idx += 2
        head = Solution().rotate(head, k)
        printList(head)
        t -= 1

# } Driver Code Ends


================================================================================
Date: 2024-08-11
Problem: Job Sequencing Problem
Filename: 2024-08-11_Job_Sequencing_Problem.py
================================================================================

#User function Template for python3
'''
class Job:
    
    # Job class which stores profit and deadline.
    
    def __init__(self,profit=0,deadline=0):
        self.profit = profit
        self.deadline = deadline
        self.id = 0
'''        


class Solution:
    def JobScheduling(self, Jobs, n):
        Jobs.sort(key=lambda x: x.profit, reverse=True)
        maxDeadline = max(job.deadline for job in Jobs)
        slot = [-1] * (maxDeadline + 1)

        jobCount = 0
        totalProfit = 0

        for job in Jobs:
            for j in range(job.deadline, 0, -1):
                if slot[j] == -1:
                    slot[j] = job.id
                    jobCount += 1
                    totalProfit += job.profit
                    break
        return [jobCount, totalProfit]



 # Driver Code Starts
#Initial Template for Python 3
import atexit
import io
import sys


#Contributed by : Nagendra Jha
class Job:
    '''
    Job class which stores profit and deadline.
    '''

    def __init__(self, profit=0, deadline=0):
        self.profit = profit
        self.deadline = deadline
        self.id = 0


if __name__ == '__main__':
    test_cases = int(input())
    for cases in range(test_cases):
        n = int(input())
        info = list(map(int, input().strip().split()))
        Jobs = [Job() for i in range(n)]
        for i in range(n):
            Jobs[i].id = info[3 * i]
            Jobs[i].deadline = info[3 * i + 1]
            Jobs[i].profit = info[3 * i + 2]
        ob = Solution()
        res = ob.JobScheduling(Jobs, n)
        print(res[0], end=" ")
        print(res[1])

# } Driver Code Ends


================================================================================
Date: 2024-08-12
Problem: Median of two sorted arrays
Filename: 2024-08-12_Median_of_two_sorted_arrays.py
================================================================================

#User function Template for python3

class Solution:
    def sum_of_middle_elements(self, arr1, arr2):
        n = len(arr1)
        low, high = 0, n

        while low <= high:
            cut1 = low + (high - low) // 2
            cut2 = n - cut1

            l1 = float('-inf') if cut1 == 0 else arr1[cut1 - 1]
            l2 = float('-inf') if cut2 == 0 else arr2[cut2 - 1]
            r1 = float('inf') if cut1 == n else arr1[cut1]
            r2 = float('inf') if cut2 == n else arr2[cut2]

            if l1 <= r2 and l2 <= r1:
                return max(l1, l2) + min(r1, r2)
            elif l1 > r2:
                high = cut1 - 1
            else:
                low = cut1 + 1

        return 0  




#{ 
 # Driver Code Starts
#Initial Template for Python 3

import sys

input = sys.stdin.read


def main():
    input_lines = input().strip().split("\n")
    t = int(input_lines[0])

    index = 1
    results = []
    while t > 0:
        arr = list(map(int, input_lines[index].strip().split()))
        brr = list(map(int, input_lines[index + 1].strip().split()))
        index += 2

        solution = Solution()
        res = solution.sum_of_middle_elements(arr, brr)
        results.append(res)

        t -= 1

    for result in results:
        print(result)


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2024-08-13
Problem: Square root of a number
Filename: 2024-08-13_Square_root_of_a_number.py
================================================================================

#User function Template for python3


#Complete this function
class Solution:
    def floorSqrt(self, n): 
        if n == 0 or n == 1:
            return n

        start, end, ans = 1, n, 0
        while start <= end:
            mid = start + (end - start) // 2
            square = mid * mid

            if square == n:
                return mid
            if square < n:
                ans = mid
                start = mid + 1
            else:
                end = mid - 1

        return ans



#{ 
 # Driver Code Starts
#Initial Template for Python 3

import math


def main():
    T = int(input())
    while (T > 0):

        x = int(input())

        print(Solution().floorSqrt(x))

        T -= 1


if __name__ == "__main__":
    main()

# } Driver Code Ends

================================================================================
Date: 2024-08-14
Problem: Longest Common Substring
Filename: 2024-08-14_Longest_Common_Substring.py
================================================================================

# User function Template for python3

class Solution:
    def longestCommonSubstr(self, str1, str2):
        n, m = len(str1), len(str2)
        res = 0

        prev = [0] * (m + 1)
        curr = [0] * (m + 1)

        for i in range(1, n + 1):
            for j in range(1, m + 1):
                if str1[i - 1] == str2[j - 1]:
                    curr[j] = 1 + prev[j - 1]
                    res = max(res, curr[j])
                else:
                    curr[j] = 0
            prev = curr[:]
        
        return res

#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        S1 = input().strip()
        S2 = input().strip()
        ob = Solution()
        print(ob.longestCommonSubstr(S1, S2))

# } Driver Code Ends

================================================================================
Date: 2024-08-15
Problem: Add 1 to a Linked List Number
Filename: 2024-08-15_Add_1_to_a_Linked_List_Number.py
================================================================================

#User function Template for python3

'''

class Node:
    def __init__(self, data):   # data -> value stored in node
        self.data = data
        self.next = None
'''

class Solution:
    def reverse(self, head):
        prev = None
        curr = head

        while curr is not None:
            next_node = curr.next
            curr.next = prev
            prev = curr
            curr = next_node

        return prev

    def addOne(self, head):
        head = self.reverse(head)
        curr = head
        carry = 1

        while curr is not None:
            sum_val = curr.data + carry
            carry = sum_val // 10
            curr.data = sum_val % 10
            prev = curr
            curr = curr.next

        if carry > 0:
            prev.next = Node(carry)

        return self.reverse(head)

#{ 
 # Driver Code Starts
#Initial Template for Python 3


# Node Class
class Node:

    def __init__(self, data):  # data -> value stored in node
        self.data = data
        self.next = None


# Linked List Class
class LinkedList:

    def __init__(self):
        self.head = None
        self.tail = None

    # creates a new node with given value and appends it at the end of the linked list
    def insert(self, value):
        if self.head is None:
            self.head = Node(value)
            self.tail = self.head
        else:
            self.tail.next = Node(value)
            self.tail = self.tail.next


def PrintList(head):
    while head:
        print(head.data, end='')
        head = head.next


if __name__ == '__main__':
    t = int(input())
    for _ in range(t):

        list1 = LinkedList()
        arr = list(map(int, input().strip().split()))
        for i in arr:
            list1.insert(i)

        resHead = Solution().addOne(list1.head)
        PrintList(resHead)
        print()

# } Driver Code Ends


================================================================================
Date: 2024-08-16
Problem: Maximize The Cut Segments
Filename: 2024-08-16_Maximize_The_Cut_Segments.py
================================================================================

#User function Template for python3
class Solution:
    def maximizeTheCuts(self, n, x, y, z):
        dp = [-1] * (n + 1)
        dp[0] = 0

        cuts = [x, y, z]

        for i in range(1, n + 1):
            for cut in cuts:
                if i >= cut and dp[i - cut] != -1:
                    dp[i] = max(dp[i], dp[i - cut] + 1)

        return dp[n] if dp[n] != -1 else 0



#{ 
 # Driver Code Starts
#Initial Template for Python 3

#contributed by RavinderSinghPB
if __name__ == '__main__':
    t=int(input())
    for tcs in range(t):
        n=int(input())
        x,y,z=[int(x) for x in input().split()]
        
        print(Solution().maximizeTheCuts(n,x,y,z))
# } Driver Code Ends


================================================================================
Date: 2024-08-17
Problem: Product array puzzle
Filename: 2024-08-17_Product_array_puzzle.py
================================================================================

#User function Template for python3

class Solution:
    def productExceptSelf(self, nums):
        n = len(nums)
        left_product = [1] * n
        result = [1] * n
        for i in range(1, n):
            left_product[i] = left_product[i - 1] * nums[i - 1]
        right_product_acc = 1
        for i in range(n - 1, -1, -1):
            result[i] = left_product[i] * right_product_acc
            right_product_acc *= nums[i]

        return result


#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    t = int(input())

    for _ in range(t):
        n = int(input())
        arr = [int(x) for x in input().split()]

        ans = Solution().productExceptSelf(arr)
        print(*ans)

# } Driver Code Ends


================================================================================
Date: 2024-08-18
Problem: Split an array into two equal Sum subarrays
Filename: 2024-08-18_Split_an_array_into_two_equal_Sum_subarrays.py
================================================================================

class Solution:
    def canSplit(self, arr):
        total_sum = sum(arr)
        right_sum = 0
        for i in range(len(arr) - 1, -1, -1):
            right_sum += arr[i]
            if right_sum * 2 == total_sum:
                return True

        return False

#{ 
 # Driver Code Starts
if __name__ == "__main__":
    import sys
    input = sys.stdin.read
    data = input().splitlines()

    t = int(data[0])
    index = 1
    for _ in range(t):
        arr = list(map(int, data[index].split()))
        index += 1

        obj = Solution()
        res = obj.canSplit(arr)
        if (res):
            print("true")
        else:
            print("false")

# } Driver Code Ends


================================================================================
Date: 2024-08-19
Problem: Kth Smallest
Filename: 2024-08-19_Kth_Smallest.py
================================================================================

#User function Template for python3

class Solution:
    def kthSmallest(self, arr, k):
        min_element = min(arr)
        max_element = max(arr)
        range_size = max_element - min_element + 1
        
        freq = [0] * range_size
        
        for num in arr:
            freq[num - min_element] += 1
        
        count = 0
        for i in range(range_size):
            count += freq[i]
            if count >= k:
                return i + min_element
        
        return -1
#{ 
 # Driver Code Starts
#Initial Template for Python 3

#contributed by RavinderSinghPB
if __name__ == '__main__':
    import random
    t = int(input())
    for tcs in range(t):
        # n = int(input())
        arr = list(map(int, input().strip().split()))
        k = int(input())
        ob = Solution()
        print(ob.kthSmallest(arr, k))

# } Driver Code Ends


================================================================================
Date: 2024-08-20
Problem: Burning Tree
Filename: 2024-08-20_Burning_Tree.py
================================================================================

#User function Template for python3
class Solution:
    def minTime(self, root, target):
        def maxDepth(node):
            if not node:
                return 0
            return 1 + max(maxDepth(node.left), maxDepth(node.right))
        
        def traverse(node, target):
            if not node:
                return 0
            if node.data == target:
                ret[0] = max(ret[0], maxDepth(node.left))
                ret[0] = max(ret[0], maxDepth(node.right))
                return 1
            
            left = traverse(node.left, target)
            right = traverse(node.right, target)

            if left > 0:
                ret[0] = max(ret[0], left + maxDepth(node.right))
                return left + 1
            
            if right > 0:
                ret[0] = max(ret[0], right + maxDepth(node.left))
                return right + 1

            return 0

        ret = [0]
        traverse(root, target)
        return ret[0]


#{ 
 # Driver Code Starts
#Initial Template for Python 3

from collections import deque

# Tree Node
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None

# Function to Build Tree   
def buildTree(s):
    #Corner Case
    if(len(s)==0 or s[0]=="N"):           
        return None
        
    # Creating list of strings from input 
    # string after spliting by space
    ip=list(map(str,s.split()))
    
    # Create the root of the tree
    root=Node(int(ip[0]))                     
    size=0
    q=deque()
    
    # Push the root to the queue
    q.append(root)                            
    size=size+1 
    
    # Starting from the second element
    i=1                                       
    while(size>0 and i<len(ip)):
        # Get and remove the front of the queue
        currNode=q[0]
        q.popleft()
        size=size-1
        
        # Get the current node's value from the string
        currVal=ip[i]
        
        # If the left child is not null
        if(currVal!="N"):
            
            # Create the left child for the current node
            currNode.left=Node(int(currVal))
            
            # Push it to the queue
            q.append(currNode.left)
            size=size+1
        # For the right child
        i=i+1
        if(i>=len(ip)):
            break
        currVal=ip[i]
        
        # If the right child is not null
        if(currVal!="N"):
            
            # Create the right child for the current node
            currNode.right=Node(int(currVal))
            
            # Push it to the queue
            q.append(currNode.right)
            size=size+1
        i=i+1
    return root

if __name__=="__main__":
    t=int(input())
    for _ in range(t):
        line=input()
        target=int(input())
        root=buildTree(line)
        print(Solution().minTime(root,target))

# } Driver Code Ends


================================================================================
Date: 2024-08-21
Problem: Shortest path in Undirected Graph
Filename: 2024-08-21_Shortest_path_in_Undirected_Graph.py
================================================================================

#User function Template for python3
from collections import deque, defaultdict

class Solution:
    def shortestPath(self, edges, n, m, src):
        adj = defaultdict(list)
        for i in range(m):
            adj[edges[i][0]].append(edges[i][1])
            adj[edges[i][1]].append(edges[i][0])
        dist = [float('inf')] * n
        dist[src] = 0
        q = deque([src])
        while q:
            node = q.popleft()

            for neighbor in adj[node]:
                if dist[node] + 1 < dist[neighbor]:
                    dist[neighbor] = dist[node] + 1
                    q.append(neighbor)
        dist = [-1 if d == float('inf') else d for d in dist]

        return dist


#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    tc = int(input())
    while tc > 0:
        n, m = map(int, input().strip().split())
        edges=[]
        for i in range(m):
            li=list(map(int,input().split()))
            edges.append(li)
        src=int(input())
        ob = Solution()
        ans = ob.shortestPath(edges,n,m,src)
        for i in ans:
            print(i,end=" ")
        print()
        tc -= 1
# } Driver Code Ends


================================================================================
Date: 2024-08-22
Problem: Alien Dictionary
Filename: 2024-08-22_Alien_Dictionary.py
================================================================================

#User function Template for python3
from typing import List

class Solution:
    def findOrder(self, dict: List[str], n: int, k: int) -> str:
        adj = [[] for _ in range(k)]
        for i in range(1, n):
            self.buildGraph(adj, dict[i - 1], dict[i])
        
        visited = [False] * k
        st = []
        for i in range(k):
            if not visited[i]:
                self.topologicalSort(i, adj, visited, st)
        
        order = ""
        while st:
            order += chr(st.pop() + ord('a'))
        return order
    
    def buildGraph(self, adj: List[List[int]], str1: str, str2: str) -> None:
        len_ = min(len(str1), len(str2))
        for i in range(len_):
            if str1[i] != str2[i]:
                adj[ord(str1[i]) - ord('a')].append(ord(str2[i]) - ord('a'))
                break

    def topologicalSort(self, node: int, adj: List[List[int]], visited: List[bool], st: List[int]) -> None:
        visited[node] = True
        for neighbor in adj[node]:
            if not visited[neighbor]:
                self.topologicalSort(neighbor, adj, visited, st)
        st.append(node)
#{ 
 # Driver Code Starts
#Initial Template for Python 3


class sort_by_order:

    def __init__(self, s):
        self.priority = {}
        for i in range(len(s)):
            self.priority[s[i]] = i

    def transform(self, word):
        new_word = ''
        for c in word:
            new_word += chr(ord('a') + self.priority[c])
        return new_word

    def sort_this_list(self, lst):
        lst.sort(key=self.transform)


if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        line = input().strip().split()
        n = int(line[0])
        k = int(line[1])

        alien_dict = [x for x in input().strip().split()]
        duplicate_dict = alien_dict.copy()
        ob = Solution()
        order = ob.findOrder(alien_dict, n, k)
        s = ""
        for i in range(k):
            s += chr(97 + i)
        l = list(order)
        l.sort()
        l = "".join(l)
        if s != l:
            print(0)
        else:
            x = sort_by_order(order)
            x.sort_this_list(duplicate_dict)

            if duplicate_dict == alien_dict:
                print(1)
            else:
                print(0)

# } Driver Code Ends


================================================================================
Date: 2024-08-23
Problem: Left View of Binary Tree
Filename: 2024-08-23_Left_View_of_Binary_Tree.py
================================================================================

#User function Template for python3
class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None

def leftViewUtil(root, level, max_level, result):
    if root is None:
        return

    if max_level[0] < level:
        result.append(root.data)
        max_level[0] = level

    leftViewUtil(root.left, level + 1, max_level, result)
    leftViewUtil(root.right, level + 1, max_level, result)

def LeftView(root):
    result = []
    max_level = [0] 
    leftViewUtil(root, 1, max_level, result)
    return result


#{ 
 # Driver Code Starts
#Contributed by Sudarshan Sharma
from collections import deque
# Tree Node
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None

# Function to Build Tree   
def buildTree(s):
    #Corner Case
    if(len(s)==0 or s[0]=="N"):           
        return None
        
    # Creating list of strings from input 
    # string after spliting by space
    ip=list(map(str,s.split()))
    
    # Create the root of the tree
    root=Node(int(ip[0]))                     
    size=0
    q=deque()
    
    # Push the root to the queue
    q.append(root)                            
    size=size+1 
    
    # Starting from the second element
    i=1                                       
    while(size>0 and i<len(ip)):
        # Get and remove the front of the queue
        currNode=q[0]
        q.popleft()
        size=size-1
        
        # Get the current node's value from the string
        currVal=ip[i]
        
        # If the left child is not null
        if(currVal!="N"):
            
            # Create the left child for the current node
            currNode.left=Node(int(currVal))
            
            # Push it to the queue
            q.append(currNode.left)
            size=size+1
        # For the right child
        i=i+1
        if(i>=len(ip)):
            break
        currVal=ip[i]
        
        # If the right child is not null
        if(currVal!="N"):
            
            # Create the right child for the current node
            currNode.right=Node(int(currVal))
            
            # Push it to the queue
            q.append(currNode.right)
            size=size+1
        i=i+1
    return root
    
    
if __name__=="__main__":
    t=int(input())
    for _ in range(0,t):
        s=input()
        root=buildTree(s)
        result = LeftView(root)
        for value in result:
            print(value,end=" ")
        print()

# } Driver Code Ends


================================================================================
Date: 2024-08-24
Problem: 0 - 1 Knapsack Problem
Filename: 2024-08-24_0_-_1_Knapsack_Problem.py
================================================================================

#User function Template for python3
class Solution:
    def knapSack(self, W, wt, val):
        n = len(wt)
        K = [0] * (W + 1)
        
        for i in range(n):
            for w in range(W, wt[i] - 1, -1):
                K[w] = max(K[w], val[i] + K[w - wt[i]])
        
        return K[W]

#{ 
 # Driver Code Starts
#Initial Template for Python 3
import atexit
import io
import sys

if __name__ == '__main__':
    test_cases = int(input())
    for cases in range(test_cases):
        # n = int(input())
        W = int(input())
        val = list(map(int, input().strip().split()))
        wt = list(map(int, input().strip().split()))
        ob = Solution()
        print(ob.knapSack(W, wt, val))

# } Driver Code Ends


================================================================================
Date: 2024-08-25
Problem: Number of pairs
Filename: 2024-08-25_Number_of_pairs.py
================================================================================

#User function Template for python3

class Solution:
    def countPairs(self, arr, brr):
        N = len(brr)
        NoOfY = [0] * 5
        
        for y in brr:
            if y < 5:
                NoOfY[y] += 1
        
        brr.sort()
        total_pairs = 0
        
        for x in arr:
            if x == 0:
                continue
            if x == 1:
                total_pairs += NoOfY[0]
                continue
            
            idx = self.upper_bound(brr, x)
            count = N - idx
            count += (NoOfY[0] + NoOfY[1])
            
            if x == 2:
                count -= (NoOfY[3] + NoOfY[4])
            if x == 3:
                count += NoOfY[2]
            
            total_pairs += count
        
        return total_pairs
    
    def upper_bound(self, arr, x):
        lo, hi = 0, len(arr)
        while lo < hi:
            mid = (lo + hi) // 2
            if arr[mid] <= x:
                lo = mid + 1
            else:
                hi = mid
        return lo

#{ 
 # Driver Code Starts
#Initial Template for Python 3

#Initial Template for Python 3

import atexit
import io
import sys
import bisect

_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__
_OUTPUT_BUFFER = io.StringIO()
sys.stdout = _OUTPUT_BUFFER


@atexit.register
def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())


if __name__ == '__main__':
    t = int(input())
    for i in range(t):
        # M, N = map(int, input().strip().split())
        a = list(map(int, input().strip().split()))
        b = list(map(int, input().strip().split()))
        ob = Solution()
        print(ob.countPairs(a, b))
        #code here

# } Driver Code Ends


================================================================================
Date: 2024-08-26
Problem: Wildcard Pattern Matching
Filename: 2024-08-26_Wildcard_Pattern_Matching.py
================================================================================

# your task is to complete this function
# function should return True/False or 1/0
# str1: pattern
# str2: text
class Solution:
    def wildCard(self, pattern, string):
        m = len(string)
        n = len(pattern)
        dp = [0] * (n + 1)
        dp[0] = 1

        for j in range(1, n + 1):
            if pattern[j - 1] == '*':
                dp[j] = dp[j - 1]

        for i in range(1, m + 1):
            new_dp = [0] * (n + 1)
            for j in range(1, n + 1):
                if pattern[j - 1] == '?' or pattern[j - 1] == string[i - 1]:
                    new_dp[j] = dp[j - 1]
                elif pattern[j - 1] == '*':
                    new_dp[j] = dp[j] or new_dp[j - 1]
            dp = new_dp

        return dp[n]
#{ 
 # Driver Code Starts
if __name__ == '__main__':
    t = int(input())
    for i in range(t):
        pattern = input().strip()
        string = input().strip()
        if Solution().wildCard(pattern, string):
            print(1)
        else:
            print(0)

# } Driver Code Ends


================================================================================
Date: 2024-08-27
Problem: Maximum Difference
Filename: 2024-08-27_Maximum_Difference.py
================================================================================

class Solution:
    def findMaxDiff(self, arr):
        n = len(arr)
        s = []
        maxDiff = 0
        l = [0] * n
        r = [0] * n
        for i in range(n):
            while s and arr[s[-1]] >= arr[i]:
                s.pop()
            l[i] = 0 if not s else arr[s[-1]]
            s.append(i)
        s.clear()
        for i in range(n - 1, -1, -1):
            while s and arr[s[-1]] >= arr[i]:
                s.pop()
            r[i] = 0 if not s else arr[s[-1]]
            s.append(i)
        for i in range(n):
            maxDiff = max(maxDiff, abs(l[i] - r[i]))

        return maxDiff
#{ 
 # Driver Code Starts
if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        arr = list(map(int, input().split()))
        ob = Solution()
        print(ob.findMaxDiff(arr))

# } Driver Code Ends


================================================================================
Date: 2024-08-28
Problem: Sorting Elements of an Array by Frequency
Filename: 2024-08-28_Sorting_Elements_of_an_Array_by_Frequency.py
================================================================================

#User function Template for python3
class Solution:
    def sortByFreq(self, arr):
        freq_map = {}
        for num in arr:
            freq_map[num] = freq_map.get(num, 0) + 1
        sorted_items = sorted(freq_map.items(), key=lambda x: (-x[1], x[0]))
        result = []
        for num, freq in sorted_items:
            result.extend([num] * freq)

        return result



#{ 
 # Driver Code Starts
#Initial Template for Python 3

import atexit
import io
import sys

_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__
_OUTPUT_BUFFER = io.StringIO()
sys.stdout = _OUTPUT_BUFFER


@atexit.register
def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())


if __name__ == '__main__':
    t = int(input())
    for tt in range(t):

        arr = list(map(int, input().strip().split()))
        l = Solution().sortByFreq(arr)
        print(*l)

# } Driver Code Ends


================================================================================
Date: 2024-08-29
Problem: Find length of Loop
Filename: 2024-08-29_Find_length_of_Loop.py
================================================================================

#User function Template for python3

'''
Structure of node

# Node Class
class Node:
    def __init__(self, data):   # data -> value stored in node
        self.data = data
        self.next = None

'''
class Solution:
    def countNodesInLoop(self, head):
        if not head or not head.next:
            return 0
        
        slow = head
        fast = head
        
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            
            if slow == fast:  
                loop_size = 1
                current = slow
                while current.next != slow:
                    current = current.next
                    loop_size += 1
                return loop_size
        
        return 0  

#{ 
 # Driver Code Starts
class Node:

    def __init__(self, data):
        self.data = data
        self.next = None


def print_list(node):
    while node:
        print(node.data, end=' ')
        node = node.next
    print()


def loop_here(head, pos):
    if pos == 0:
        return

    walk = head
    for _ in range(1, pos):
        walk = walk.next

    tail = head
    while tail.next:
        tail = tail.next

    tail.next = walk


if __name__ == "__main__":
    import sys
    input = sys.stdin.read
    data = input().split('\n')
    t = int(data[0])
    index = 1
    for _ in range(t):
        arr = list(map(int, data[index].split()))
        k = int(data[index + 1])
        head = Node(arr[0])
        tail = head
        for value in arr[1:]:
            tail.next = Node(value)
            tail = tail.next
        loop_here(head, k)
        ob = Solution()
        res = ob.countNodesInLoop(head)
        print(res)
        index += 2

# } Driver Code Ends


================================================================================
Date: 2024-08-30
Problem: N-Queen Problem
Filename: 2024-08-30_N-Queen_Problem.py
================================================================================

#User function Template for python3

class Solution:
    def __init__(self):
        self.result = []
        self.row = [0] * 10
    
    def place(self, r, c):
        for prev in range(c):
            if self.row[prev] == r or abs(self.row[prev] - r) == abs(prev - c):
                return False
        return True

    def bt(self, c, n):
        if c == n:
            self.result.append([self.row[i] + 1 for i in range(n)])
            return
        for i in range(n):
            if self.place(i, c):
                self.row[c] = i
                self.bt(c + 1, n)

    def nQueen(self, n):
        self.result = []
        self.bt(0, n)
        return self.result


#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        n = int(input())
        
        ob = Solution()
        ans = ob.nQueen(n)
        if(len(ans) == 0):
            print("-1")
        else:
            for i in range(len(ans)):
                print("[",end="")
                for j in range(len(ans[i])):
                    print(ans[i][j],end = " ")
                print("]",end = " ")
            print()
                
# } Driver Code Ends


================================================================================
Date: 2024-08-31
Problem: Sorted subsequence of size 3
Filename: 2024-08-31_Sorted_subsequence_of_size_3.py
================================================================================

#User function Template for python3



class Solution:
    def find3Numbers(self, arr):
        n = len(arr)
        if n < 3:
            return []

        smaller = [-1] * n
        greater = [-1] * n

        min_index = 0
        for i in range(1, n):
            if arr[i] <= arr[min_index]:
                min_index = i
            else:
                smaller[i] = min_index

        max_index = n - 1
        for i in range(n - 2, -1, -1):
            if arr[i] >= arr[max_index]:
                max_index = i
            else:
                greater[i] = max_index

        for i in range(n):
            if smaller[i] != -1 and greater[i] != -1:
                return [arr[smaller[i]], arr[i], arr[greater[i]]]

        return []


#{ 
 # Driver Code Starts
#Initial Template for Python 3


def isSubSequence(v1, v2):
    m = len(v2)
    n = len(v1)
    j = 0  # For index of v2
    # Traverse v1 and v2
    for i in range(n):
        if j < m and v1[i] == v2[j]:
            j += 1
    return j == m


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        arr = list(map(int, input().split()))
        n = len(arr)
        obj = Solution()
        res = obj.find3Numbers(arr)
        if len(res) != 0 and len(res) != 3:
            print(-1)
        else:
            if not res:
                print(0)
            elif res[0] < res[1] < res[2] and isSubSequence(arr, res):
                print(1)
            else:
                print(-1)

# } Driver Code Ends


================================================================================
Date: 2024-09-01
Problem: Max sum path in two arrays
Filename: 2024-09-01_Max_sum_path_in_two_arrays.py
================================================================================

#Your task is to complete this function
class Solution:
    def maxPathSum(self, arr1, arr2):
        i, j = 0, 0
        result, sum1, sum2 = 0, 0, 0
        m, n = len(arr1), len(arr2)
        
        while i < m and j < n:
            if arr1[i] < arr2[j]:
                sum1 += arr1[i]
                i += 1
            elif arr1[i] > arr2[j]:
                sum2 += arr2[j]
                j += 1
            else:
                result += max(sum1, sum2) + arr1[i]
                sum1 = sum2 = 0
                i += 1
                j += 1

        while i < m:
            sum1 += arr1[i]
            i += 1

        while j < n:
            sum2 += arr2[j]
            j += 1

        result += max(sum1, sum2)

        return result
#{ 
 # Driver Code Starts
if __name__ == "__main__":
    t = int(input().strip())
    for _ in range(t):
        arr1 = list(map(int, input().strip().split()))
        arr2 = list(map(int, input().strip().split()))
        ob = Solution()
        ans = ob.maxPathSum(arr1, arr2)
        print(ans)

# } Driver Code Ends


================================================================================
Date: 2024-09-02
Problem: Minimum Cost Path
Filename: 2024-09-02_Minimum_Cost_Path.py
================================================================================

import heapq

class Solution:
    def minimumCostPath(self, grid):
        n = len(grid)
        m = len(grid[0])
        dp = [[float('inf')] * m for _ in range(n)]
        pq = []
        dx = [-1, 1, 0, 0]
        dy = [0, 0, -1, 1]
        
        dp[0][0] = grid[0][0]
        heapq.heappush(pq, (dp[0][0], 0, 0))
        
        while pq:
            dist, x, y = heapq.heappop(pq)
            
            if dist > dp[x][y]:
                continue
                
            for i in range(4):
                nx = x + dx[i]
                ny = y + dy[i]
                
                if 0 <= nx < n and 0 <= ny < m:
                    newDist = dp[x][y] + grid[nx][ny]
                    if newDist < dp[nx][ny]:
                        dp[nx][ny] = newDist
                        heapq.heappush(pq, (newDist, nx, ny))
        
        return dp[n-1][m-1]

#{ 
 # Driver Code Starts

T=int(input())
for i in range(T):
	n = int(input())
	grid = []
	for _ in range(n):
		a = list(map(int, input().split()))
		grid.append(a)
	obj = Solution()
	ans = obj.minimumCostPath(grid)
	print(ans)

# } Driver Code Ends


================================================================================
Date: 2024-09-03
Problem: Minimum number of deletions and insertions
Filename: 2024-09-03_Minimum_number_of_deletions_and_insertions.py
================================================================================

#User function Template for python3
class Solution:
    def minOperations(self, str1: str, str2: str) -> int:
        m, n = len(str1), len(str2)

        dp = [0] * (n + 1)

        for i in range(1, m + 1):
            prev = 0
            for j in range(1, n + 1):
                temp = dp[j]
                if str1[i - 1] == str2[j - 1]:
                    dp[j] = prev + 1
                else:
                    dp[j] = max(dp[j], dp[j - 1])
                prev = temp

        return m + n - 2 * dp[n]


#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    T = int(input())
    for i in range(T):
        s1, s2 = input().split()
        ob = Solution()
        ans = ob.minOperations(s1, s2)
        print(ans)

# } Driver Code Ends


================================================================================
Date: 2024-09-04
Problem: Count ways to Nth StairOrder does not matter
Filename: 2024-09-04_Count_ways_to_Nth_StairOrder_does_not_matter.py
================================================================================

#User function Template for python3

class Solution:
    def nthStair(self, n):
        if n == 0:
            return 1
        if n == 1:
            return 1
        
        prev2 = 1
        prev1 = 1
        current = 1
        
        for i in range(2, n + 1):
            current = prev2 + 1
            prev2 = prev1
            prev1 = current
        
        return current

#{ 
 # Driver Code Starts
#Initial Template for Python 3

import sys
sys.setrecursionlimit(10**6)

if __name__ == '__main__':
	T=int(input())
	for i in range(T):
		n = int(input())
		ob = Solution();
		ans = ob.nthStair(n)
		print(ans)
# } Driver Code Ends


================================================================================
Date: 2024-09-05
Problem: Missing in Array
Filename: 2024-09-05_Missing_in_Array.py
================================================================================

#User function Template for python3
class Solution:
    def missingNumber(self, n, arr):
        xor_total = 0
        for i in range(1, n + 1):
            xor_total ^= i
        xor_array = 0
        for num in arr:
            xor_array ^= num
        return xor_total ^ xor_array


#{ 
 # Driver Code Starts
#Initial Template for Python 3

t = int(input())
for _ in range(0, t):
    n = int(input())
    arr = list(map(int, input().split()))
    s = Solution().missingNumber(n, arr)
    print(s)

# } Driver Code Ends


================================================================================
Date: 2024-09-06
Problem: Kadanes Algorithm
Filename: 2024-09-06_Kadanes_Algorithm.py
================================================================================

#User function Template for python3

class Solution:
    def maxSubArraySum(self, arr):
        maxh = 0
        maxf = float('-inf')

        for num in arr:
            maxh = max(num, maxh + num)
            maxf = max(maxf, maxh)
        
        return maxf


#{ 
 # Driver Code Starts
#Initial Template for Python 3

import math


def main():
    T = int(input())
    while (T > 0):

        arr = [int(x) for x in input().strip().split()]

        ob = Solution()

        print(ob.maxSubArraySum(arr))

        T -= 1


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2024-09-07
Problem: Nth Natural Number
Filename: 2024-09-07_Nth_Natural_Number.py
================================================================================

#User function Template for python3

class Solution:
    def findNth(self, n):
        base9num = 0
        pos = 1
        
        while n > 0:
            base9num += (n % 9) * pos
            n //= 9
            pos *= 10
        
        return base9num

#{ 
 # Driver Code Starts
#Initial Template for Python 3

t = int(input())
for i in range(0, t):
    n = int(input())
    obj = Solution()
    s = obj.findNth(n)
    print(s)

# } Driver Code Ends


================================================================================
Date: 2024-09-08
Problem: Minimum Jumps
Filename: 2024-09-08_Minimum_Jumps.py
================================================================================

#User function Template for python3
class Solution:
    def minJumps(self, arr):
        n = len(arr)
        if n <= 1:
            return 0
        if arr[0] == 0:
            return -1
        
        maxReach = arr[0]
        steps = arr[0]
        jumps = 1

        for i in range(1, n):
            if i == n - 1:
                return jumps

            maxReach = max(maxReach, i + arr[i])
            steps -= 1

            if steps == 0:
                jumps += 1
                if i >= maxReach:
                    return -1

                steps = maxReach - i
        
        return -1


#{ 
 # Driver Code Starts
#Initial Template for Python 3
if __name__ == '__main__':
    T = int(input())
    for i in range(T):
        # n = int(input())
        Arr = [int(x) for x in input().split()]
        ob = Solution()
        ans = ob.minJumps(Arr)
        print(ans)

# } Driver Code Ends


================================================================================
Date: 2024-09-09
Problem: Sort 0s 1s and 2s
Filename: 2024-09-09_Sort_0s_1s_and_2s.py
================================================================================

class Solution:
    def sort012(self, arr):
        low, mid, high = 0, 0, len(arr) - 1

        while mid <= high:
            if arr[mid] == 0:
                arr[low], arr[mid] = arr[mid], arr[low]
                low += 1
                mid += 1
            elif arr[mid] == 1:
                mid += 1
            else:
                arr[mid], arr[high] = arr[high], arr[mid]
                high -= 1

#{ 
 # Driver Code Starts
def main():
    t = int(input().strip())  # Read the number of test cases
    ob = Solution()

    while t > 0:
        t -= 1
        arr = list(map(int,
                       input().strip().split())
                   )  # Read the array as space-separated integers
        ob.sort012(arr)  # Sort the array

        print(' '.join(map(str, arr)))  # Print the sorted array


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2024-09-10
Problem: Circle of strings
Filename: 2024-09-10_Circle_of_strings.py
================================================================================

#User function Template for python3
class Solution:
    def dfs(self, node, adj, visited):
        visited[node] = True
        for u in adj[node]:
            if not visited[u]:
                self.dfs(u, adj, visited)

    def isConnected(self, adj, indegree):
        visited = [False] * 26
        start = -1
        
        for i in range(26):
            if indegree[i] > 0:
                start = i
                break
        
        if start == -1:
            return True
        
        self.dfs(start, adj, visited)
        
        for i in range(26):
            if indegree[i] > 0 and not visited[i]:
                return False
        
        return True

    def isCircle(self, arr):
        N = len(arr)
        adj = [[] for _ in range(26)]
        adjr = [[] for _ in range(26)]
        indegree = [0] * 26
        outdegree = [0] * 26
        
        for word in arr:
            u = ord(word[0]) - ord('a')
            v = ord(word[-1]) - ord('a')
            adj[u].append(v)
            adjr[v].append(u)
            outdegree[u] += 1
            indegree[v] += 1

        for i in range(26):
            if indegree[i] != outdegree[i]:
                return 0

        if not self.isConnected(adj, indegree):
            return 0

        if not self.isConnected(adjr, outdegree):
            return 0
        
        return 1



#{ 
 # Driver Code Starts
#Initial Template for Python 3

import sys

sys.setrecursionlimit(10**6)
if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        N = int(input())
        A = input().split()

        ob = Solution()
        print(ob.isCircle(A))

# } Driver Code Ends


================================================================================
Date: 2024-09-11
Problem: Minimum Cost of ropes
Filename: 2024-09-11_Minimum_Cost_of_ropes.py
================================================================================

#User function Template for python3
import heapq

class Solution:
    def minCost(self, arr):
        heapq.heapify(arr)
        totalCost = 0
        while len(arr) > 1:
            first = heapq.heappop(arr)
            second = heapq.heappop(arr)
            cost = first + second
            totalCost += cost
            heapq.heappush(arr, cost)

        return totalCost


#{ 
 # Driver Code Starts
#Initial Template for Python 3
import atexit
import io
import sys
import heapq
from collections import defaultdict
# Contributed by : Nagendra Jha

_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__
_OUTPUT_BUFFER = io.StringIO()
sys.stdout = _OUTPUT_BUFFER


@atexit.register
def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())


if __name__ == '__main__':
    test_cases = int(input())
    for cases in range(test_cases):
        a = list(map(int, input().strip().split()))
        ob = Solution()
        print(ob.minCost(a))

# } Driver Code Ends


================================================================================
Date: 2024-09-12
Problem: Middle of a Linked List
Filename: 2024-09-12_Middle_of_a_Linked_List.py
================================================================================

# your task is to complete this function

'''
class node:
    def __init__(data):
        self.data = data
        self.next = None
'''
class Solution:
    def findMid(self, head):
        if head is None:
            return -1
        
        slow = head
        fast = head

        while fast is not None and fast.next is not None:
            slow = slow.next
            fast = fast.next.next

        return slow.data  

#{ 
 # Driver Code Starts
# Initial Template for Python3


# Node Class
class node:

    def __init__(self):
        self.data = None
        self.next = None


# Linked List Class
class Linked_List:

    def __init__(self):
        self.head = None
        self.tail = None

    def insert(self, data):
        if self.head == None:
            self.head = node()
            self.tail = self.head
            self.head.data = data
        else:
            new_node = node()
            new_node.data = data
            new_node.next = None
            self.tail.next = new_node
            self.tail = self.tail.next


def printlist(head):
    temp = head
    while temp is not None:
        print(temp.data, end=" ")
        temp = temp.next
    print('')


# Driver Program
if __name__ == '__main__':
    t = int(input())
    for i in range(t):
        list1 = Linked_List()
        arr = list(map(int, input().strip().split()))
        for i in arr:
            list1.insert(i)
        ob = Solution()
        print(ob.findMid(list1.head))

# } Driver Code Ends


================================================================================
Date: 2024-09-13
Problem: Mirror Tree
Filename: 2024-09-13_Mirror_Tree.py
================================================================================

#User function Template for python3

'''
class Node:
    def _init_(self, val):
        self.right = None
        self.data = val
        self.left = None
'''
# your task is to complete this function

class Solution:
    def mirror(self, root):
        if root is None:
            return
        root.left, root.right = root.right, root.left
        self.mirror(root.left)
        self.mirror(root.right)
#{ 
 # Driver Code Starts
#Initial Template for Python 3



#Contributed by Sudarshan Sharma
from collections import deque
# Tree Node
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None


def inorderTraversalUtil(root):
    # Code here
    if root is None:
        return
    inorderTraversalUtil(root.left)
    print(root.data, end=' ')    
    inorderTraversalUtil(root.right)

def inorderTraversal(root):
    # Code here
    inorderTraversalUtil(root)
    print()
    
# Function to Build Tree   
def buildTree(s):
    #Corner Case
    if(len(s)==0 or s[0]=="N"):           
        return None
        
    # Creating list of strings from input 
    # string after spliting by space
    ip=list(map(str,s.split()))
    
    # Create the root of the tree
    root=Node(int(ip[0]))                     
    size=0
    q=deque()
    
    # Push the root to the queue
    q.append(root)                            
    size=size+1 
    
    # Starting from the second element
    i=1                                       
    while(size>0 and i<len(ip)):
        # Get and remove the front of the queue
        currNode=q[0]
        q.popleft()
        size=size-1
        
        # Get the current node's value from the string
        currVal=ip[i]
        
        # If the left child is not null
        if(currVal!="N"):
            
            # Create the left child for the current node
            currNode.left=Node(int(currVal))
            
            # Push it to the queue
            q.append(currNode.left)
            size=size+1
        # For the right child
        i=i+1
        if(i>=len(ip)):
            break
        currVal=ip[i]
        
        # If the right child is not null
        if(currVal!="N"):
            
            # Create the right child for the current node
            currNode.right=Node(int(currVal))
            
            # Push it to the queue
            q.append(currNode.right)
            size=size+1
        i=i+1
    return root
    
    
if __name__=="__main__":
    t=int(input())
    for _ in range(0,t):
        s=input()
        root=buildTree(s)
        Solution().mirror(root)
        inorderTraversal(root)
        
        

# } Driver Code Ends


================================================================================
Date: 2024-09-14
Problem: Alternate positive and negative numbers
Filename: 2024-09-14_Alternate_positive_and_negative_numbers.py
================================================================================

#User function Template for python3
class Solution:
    def rearrange(self, arr):
        n = len(arr)
        pos = []
        neg = []
        for i in range(n):
            if arr[i] >= 0:
                pos.append(arr[i])
            else:
                neg.append(arr[i])
        i = j = k = 0
        toggle = True
        while i < len(pos) and j < len(neg):
            if toggle:
                arr[k] = pos[i]
                i += 1
            else:
                arr[k] = neg[j]
                j += 1
            k += 1
            toggle = not toggle
        while i < len(pos):
            arr[k] = pos[i]
            i += 1
            k += 1
        while j < len(neg):
            arr[k] = neg[j]
            j += 1
            k += 1




#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    tc = int(input())
    while tc > 0:
        arr = list(map(int, input().strip().split()))
        ob = Solution()
        ob.rearrange(arr)
        for x in arr:
            print(x, end=" ")
        print()
        tc -= 1

# } Driver Code Ends


================================================================================
Date: 2024-09-15
Problem: Binary Tree to DLL
Filename: 2024-09-15_Binary_Tree_to_DLL.py
================================================================================

#User function Template for python3

'''
class Node:
    """ Class Node """
    def __init__(self, value):
        self.left = None
        self.data = value
        self.right = None
'''

class Solution:
    def __init__(self):
        self.prev = None
    def bToDLL(self, root):
        if root is None:
            return None
        head = self.bToDLL(root.left)
        if self.prev is None:
            head = root
        else:
            root.left = self.prev
            self.prev.right = root
        
        self.prev = root  
        self.bToDLL(root.right)
        
        return head



#{ 
 # Driver Code Starts
#Initial template for Python

from collections import deque
class Node:
    """ Class Node """
    def __init__(self, value):
        self.left = None
        self.data = value
        self.right = None

# Function to Build Tree   
def buildTree(s):
    #Corner Case
    if(len(s)==0 or s[0]=="N"):           
        return None
        
    # Creating list of strings from input 
    # string after spliting by space
    ip=list(map(str,s.split()))
    
    # Create the root of the tree
    root=Node(int(ip[0]))                     
    size=0
    q=deque()
    
    # Push the root to the queue
    q.append(root)                            
    size=size+1 
    
    # Starting from the second element
    i=1                                       
    while(size>0 and i<len(ip)):
        # Get and remove the front of the queue
        currNode=q[0]
        q.popleft()
        size=size-1
        
        # Get the current node's value from the string
        currVal=ip[i]
        
        # If the left child is not null
        if(currVal!="N"):
            
            # Create the left child for the current node
            currNode.left=Node(int(currVal))
            
            # Push it to the queue
            q.append(currNode.left)
            size=size+1
        # For the right child
        i=i+1
        if(i>=len(ip)):
            break
        currVal=ip[i]
        
        # If the right child is not null
        if(currVal!="N"):
            
            # Create the right child for the current node
            currNode.right=Node(int(currVal))
            
            # Push it to the queue
            q.append(currNode.right)
            size=size+1
        i=i+1
    return root


import sys            
def printDLL(head): #Print util function to print Linked List
    prev = None
    sys.stdout.flush()
    while(head != None):
        print(head.data, end=" ")
        prev=head
        head=head.right
    print('')
    while(prev != None):
        print(prev.data, end=" ")
        prev=prev.left
    print('')
    
if __name__=='__main__':
    t=int(input())
    for _ in range(0,t):
        s=input()
        root=buildTree(s)
        ob = Solution()
        head = ob.bToDLL(root)
        printDLL(head)
# } Driver Code Ends


================================================================================
Date: 2024-09-16
Problem: Longest valid Parentheses
Filename: 2024-09-16_Longest_valid_Parentheses.py
================================================================================

# User function Template for Python3
class Solution:
    def maxLength(self, s):
        left, right, maxi = 0, 0, 0
        for char in s:
            if char == '(':
                left += 1
            else:
                right += 1
            
            if left == right:
                maxi = max(maxi, 2 * right)
            elif right > left:
                left = right = 0
        left = right = 0 
        for char in reversed(s):
            if char == '(':
                left += 1
            else:
                right += 1
            
            if left == right:
                maxi = max(maxi, 2 * left)
            elif left > right:
                left = right = 0

        return maxi

#{ 
 # Driver Code Starts
# Initial Template for Python3

if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        S = input()

        ob = Solution()
        print(ob.maxLength(S))

# } Driver Code Ends


================================================================================
Date: 2024-09-17
Problem: Minimize the Heights II
Filename: 2024-09-17_Minimize_the_Heights_II.py
================================================================================

#User function Template for python3
class Solution:
    def getMinDiff(self, arr, k):
        n = len(arr)
        if n == 1:
            return 0
        arr.sort()
        ans = arr[-1] - arr[0]
        smallest = arr[0] + k
        largest = arr[-1] - k
        for i in range(n - 1):
            minVal = min(smallest, arr[i + 1] - k)
            maxVal = max(largest, arr[i] + k)
            if minVal < 0:
                continue
            ans = min(ans, maxVal - minVal)

        return ans


#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    tc = int(input())
    while tc > 0:
        k = int(input())
        # n = int(input())
        arr = list(map(int, input().strip().split()))
        ob = Solution()
        ans = ob.getMinDiff(arr, k)
        print(ans)
        tc -= 1

# } Driver Code Ends


================================================================================
Date: 2024-09-18
Problem: Parenthesis Checker
Filename: 2024-09-18_Parenthesis_Checker.py
================================================================================

#User function Template for python3

class Solution:
    def ispar(self, x):
        stack = []
        
        for c in x:
            if c in "({[":
                stack.append(c)
            elif c == ')':
                if not stack or stack.pop() != '(':
                    return False
            elif c == '}':
                if not stack or stack.pop() != '{':
                    return False
            elif c == ']':
                if not stack or stack.pop() != '[':
                    return False

        return not stack

#{ 
 # Driver Code Starts
#Initial Template for Python 3

import atexit
import io
import sys

#Contributed by : Nagendra Jha

_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__
_OUTPUT_BUFFER = io.StringIO()
sys.stdout = _OUTPUT_BUFFER


@atexit.register
def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())


if __name__ == '__main__':
    test_cases = int(input())
    for cases in range(test_cases):
        #n = int(input())
        #n,k = map(int,imput().strip().split())
        #a = list(map(int,input().strip().split()))
        s = str(input())
        obj = Solution()
        if obj.ispar(s):
            print("balanced")
        else:
            print("not balanced")

# } Driver Code Ends


================================================================================
Date: 2024-09-19
Problem: Reverse Words
Filename: 2024-09-19_Reverse_Words.py
================================================================================

# User function Template for python3

class Solution:
    def reverseWords(self, str):
        result = []
        n = len(str)
        end = n - 1

        for i in range(n - 1, -1, -1):
            if str[i] == '.':
                result.append(str[i+1:end+1])
                result.append('.')
                end = i - 1
        result.append(str[:end+1])

        return ''.join(result)


#{ 
 # Driver Code Starts
# Initial Template for Python 3

if __name__ == '__main__':
    t = int(input())
    for i in range(t):
        s = str(input())
        obj = Solution()
        print(obj.reverseWords(s))

# } Driver Code Ends


================================================================================
Date: 2024-09-20
Problem: Facing the sun
Filename: 2024-09-20_Facing_the_sun.py
================================================================================

#User function Template for python3
class Solution:
    def countBuildings(self, height):
        count = 0
        max_height = float('-inf')

        for h in height:
            if h > max_height:
                count += 1
                max_height = h 
        
        return count


#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == "__main__":
    t = int(input().strip())
    for _ in range(t):
        height = list(map(int, input().strip().split()))
        ob = Solution()
        ans = ob.countBuildings(height)
        print(ans)

# } Driver Code Ends


================================================================================
Date: 2024-09-21
Problem: Clone a linked list with next and random pointer
Filename: 2024-09-21_Clone_a_linked_list_with_next_and_random_pointer.py
================================================================================

#User function Template for python3

'''
class Node:
    def __init__(self, data):   # data -> value stored in node
        self.data = data
        self.next = None
        self.random=None
        
param: head:  head of linkedList to copy
return: the head of the copied linked list the #output will be 1 if successfully copied
'''
class Solution:
    def copyList(self, head):
        if head is None:
            return None

        t = head
        while t is not None:
            clone = Node(t.data)  
            clone.next = t.next   
            t.next = clone        
            t = clone.next        

        t = head
        while t is not None:
            if t.random is not None:
                t.next.random = t.random.next  
            t = t.next.next  

        t = head
        head2 = head.next  
        clone = head2

        while t is not None:
            t.next = t.next.next  
            if clone.next is not None:
                clone.next = clone.next.next  
            t = t.next  
            clone = clone.next  

        return head2      

#{ 
 # Driver Code Starts
class Node:

    def __init__(self, data):  # data -> value stored in node
        self.data = data
        self.next = None
        self.random = None


class LinkedList:

    def __init__(self):
        self.head = None


def insert(tail, data):
    tail.next = Node(data)
    return tail.next


def setrandom(head, a, b):
    h = head
    i = 1
    while i < a and h:
        h = h.next
        i += 1
    an = h

    h = head
    i = 1
    while i < b and h:
        h = h.next
        i += 1

    if an:
        an.random = h


def validation(head, res):

    headp = head
    resp = res

    d = {}

    while head and res:
        if head == res:
            return
        if head.data != res.data:
            return

        if head.random:
            if not res.random:
                return

            if head.random.data != res.random.data:
                return

        elif res.random:
            return
        if head not in d:
            d[head] = res
        head = head.next
        res = res.next

    if not head and res:
        return
    elif head and not res:
        return

    head = headp
    res = resp
    while head:
        if head == res:
            return
        if head.random:
            if head.random not in d:
                return
            if d[head.random] != res.random:
                return
        head = head.next
        res = res.next

    return True


if __name__ == '__main__':
    t = int(input())
    for cases in range(t):
        # __n,__m = list(map(int, input().strip().split()))
        __nodes = list(map(int, input().strip().split()))
        __arandom = list(map(int, input().strip().split()))
        __n = len(__nodes)
        __m = len(__arandom)
        __ll = LinkedList()
        __ll2 = LinkedList()
        __ll.head = Node(__nodes[0])
        __ll2.head = Node(__nodes[0])
        __tail = __ll.head
        __tail2 = __ll2.head

        for x in __nodes[1:]:
            __tail = insert(__tail, x)
            __tail2 = insert(__tail2, x)

        for i in range(0, len(__arandom), 2):
            setrandom(__ll.head, __arandom[i], __arandom[i + 1])
            setrandom(__ll2.head, __arandom[i], __arandom[i + 1])

        obj = Solution()
        __res = obj.copyList(__ll.head)
        if validation(__ll.head, __res) and validation(__ll2.head, __res):
            print("true")
        else:
            print("false")

# } Driver Code Ends


================================================================================
Date: 2024-09-22
Problem: Longest Prefix Suffix
Filename: 2024-09-22_Longest_Prefix_Suffix.py
================================================================================

#User function Template for python3

class Solution:
    def lps(self, s: str) -> int:
        n = len(s)
        if n == 0:
            return 0

        lpsArr = [0] * n
        j = 0

        for i in range(1, n):
            while j > 0 and s[i] != s[j]:
                j = lpsArr[j - 1]
            if s[i] == s[j]:
                j += 1
            lpsArr[i] = j

        return lpsArr[n - 1]

#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    T = int(input())
    for i in range(T):
        s = input()

        ob = Solution()
        answer = ob.lps(s)
        print(answer)

# } Driver Code Ends


================================================================================
Date: 2024-09-23
Problem: Missing And Repeating
Filename: 2024-09-23_Missing_And_Repeating.py
================================================================================

#User function Template for python3
class Solution:
    def findTwoElement(self, arr): 
        n = len(arr)
        xor_all = 0
        xor1 = 0
        xor2 = 0

        for i in range(n):
            xor_all ^= arr[i]     
            xor_all ^= (i + 1)    

        set_bit = xor_all & ~(xor_all - 1)

        for i in range(n):
            if (arr[i] & set_bit) != 0:  
                xor1 ^= arr[i]
            else:                        
                xor2 ^= arr[i]

            if ((i + 1) & set_bit) != 0:  
                xor1 ^= (i + 1)
            else:                         
                xor2 ^= (i + 1)

        repeating, missing = 0, 0
        for i in range(n):
            if arr[i] == xor1:
                repeating = xor1
                missing = xor2
                break
            elif arr[i] == xor2:
                repeating = xor2
                missing = xor1
                break

        return [repeating, missing]

#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':

    tc = int(input())
    while tc > 0:
        n = int(input())
        arr = list(map(int, input().strip().split()))
        ob = Solution()
        ans = ob.findTwoElement(arr)
        print(str(ans[0]) + " " + str(ans[1]))
        tc = tc - 1

# } Driver Code Ends


================================================================================
Date: 2024-09-24
Problem: Smallest window in a string containing all the characters of another string
Filename: 2024-09-24_Smallest_window_in_a_string_containing_all_the_characters_of_another_string.py
================================================================================

#User function Template for python3


class Solution:
    def smallestWindow(self, s, p):
        if len(p) > len(s):
            return "-1"

        phash = [0] * 256
        for ch in p:
            phash[ord(ch)] += 1

        shash = [0] * 256
        minLength = float('inf')
        startIndex = -1
        count = 0
        left = 0

        for right in range(len(s)):
            ch = s[right]
            shash[ord(ch)] += 1

            if phash[ord(ch)] != 0 and shash[ord(ch)] <= phash[ord(ch)]:
                count += 1

            while count == len(p):
                if right - left + 1 < minLength:
                    minLength = right - left + 1
                    startIndex = left
                
                leftChar = s[left]
                shash[ord(leftChar)] -= 1

                if phash[ord(leftChar)] != 0 and shash[ord(leftChar)] < phash[ord(leftChar)]:
                    count -= 1
                
                left += 1  

        if startIndex == -1:
            return "-1"
        return s[startIndex:startIndex + minLength]
#{ 
 # Driver Code Starts
#Initial Template for Python 3

import atexit
import io
import sys

_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__
_OUTPUT_BUFFER = io.StringIO()
sys.stdout = _OUTPUT_BUFFER

@atexit.register

def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())

if __name__=='__main__':
    t = int(input())
    for i in range(t):
        s=str(input())
        p=str(input())
        ob = Solution()
        print(ob.smallestWindow(s,p))
# } Driver Code Ends


================================================================================
Date: 2024-09-25
Problem: Palindrome Linked List
Filename: 2024-09-25_Palindrome_Linked_List.py
================================================================================

#User function Template for python3
'''
	Your task is to check if given linkedlist
	is a pallindrome or not.
	
	Function Arguments: head (reference to head of the linked list)
	Return Type: boolean , no need to print just return True or False.

	{
		# Node Class
		class Node:
		    def __init__(self, data):   # data -> value stored in node
		        self.data = data
		        self.next = None
	}

	Contributed By: Nagendra Jha
'''
class Solution:
    def isPalindrome(self, head):
        if not head or not head.next:
            return True

        slow = head
        fast = head
        prev = None

        while fast and fast.next:
            fast = fast.next.next

            next_node = slow.next
            slow.next = prev
            prev = slow
            slow = next_node

        second_half = slow
        if fast:
            second_half = slow.next  

        first_half = prev
        while second_half:
            if first_half.data != second_half.data:
                return False
            first_half = first_half.next
            second_half = second_half.next

        return True
#{ 
 # Driver Code Starts
#main


class Node:
    # Constructor to initialize the node object
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    # Function to initialize head
    def __init__(self):
        self.head = None

    # Function to insert a new node at the beginning
    def push(self, new_data):
        new_node = Node(new_data)
        new_node.next = self.head
        self.head = new_node

    # Utility function to prit the linked LinkedList
    def printList(self):
        temp = self.head
        while (temp):
            print(temp.data, end=" ")
            temp = temp.next
        print("")


if __name__ == '__main__':
    t = int(input())
    while (t > 0):
        llist = LinkedList()
        values = input().strip().split()
        for i in reversed(values):
            llist.push(i)
        flag = Solution().isPalindrome(llist.head)
        if flag:
            print("true")
        else:
            print("false")
        t -= 1
# Contributed by: Harshit Sidhwa

# } Driver Code Ends


================================================================================
Date: 2024-09-26
Problem: Roof Top
Filename: 2024-09-26_Roof_Top.py
================================================================================

#User function Template for python3
class Solution:
    def maxStep(self, arr):
        c = 0  
        m = 0  
        for i in range(1, len(arr)):
            if arr[i] > arr[i - 1]:
                c += 1  
            else:
                m = max(m, c)  
                c = 0  
        return max(m, c)  


#{ 
 # Driver Code Starts
#Initial Template for Python 3

import math


def main():
    T = int(input())
    while (T > 0):

        arr = [int(x) for x in input().strip().split()]
        ob = Solution()
        print(ob.maxStep(arr))

        T -= 1


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2024-09-27
Problem: K Sized Subarray Maximum
Filename: 2024-09-27_K_Sized_Subarray_Maximum.py
================================================================================

#User function Template for python3
import heapq

class Solution:
    def max_of_subarrays(self, k, arr):
        res = []
        maxHeap = []  

        for i in range(len(arr)):
            heapq.heappush(maxHeap, (-arr[i], i))
            while maxHeap[0][1] <= i - k:
                heapq.heappop(maxHeap)
            if i >= k - 1:
                res.append(-maxHeap[0][0])

        return res


#{ 
 # Driver Code Starts
#Initial Template for Python 3

import atexit
import io
import sys
from collections import deque

#Contributed by : Nagendra Jha

_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__
_OUTPUT_BUFFER = io.StringIO()
sys.stdout = _OUTPUT_BUFFER


@atexit.register
def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())


if __name__ == '__main__':
    test_cases = int(input())
    for cases in range(test_cases):
        k = int(input())
        arr = list(map(int, input().strip().split()))
        ob = Solution()
        res = ob.max_of_subarrays(k, arr)
        for i in range(len(res)):
            print(res[i], end=" ")
        print()

# } Driver Code Ends


================================================================================
Date: 2024-09-28
Problem: Minimal Cost
Filename: 2024-09-28_Minimal_Cost.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3

# } Driver Code Ends
#User function Template for python3
class Solution:
    def minimizeCost(self, k, arr):
        n = len(arr)
        dp = [-1] * n
        dp[0] = 0
        
        for i in range(1, n):
            min_v = float('inf')
            for j in range(1, k+1):
                if i - j >= 0:
                    curr = dp[i - j] + abs(arr[i] - arr[i - j])
                    min_v = min(curr, min_v)
            dp[i] = min_v
            
        return dp[n - 1]

#{ 
 # Driver Code Starts.
#Initial Template for Python 3

if __name__ == "__main__":
    t = int(input())
    while t > 0:
        k= int(input())
        arr = list(map(int, input().split()))
        ob = Solution()
        res = ob.minimizeCost(k,arr)
        print(res)
        t -= 1


# } Driver Code Ends


================================================================================
Date: 2024-09-29
Problem: Total count
Filename: 2024-09-29_Total_count.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3

# } Driver Code Ends
#User function Template for python3

class Solution:
    def totalCount(self, k, arr):
        count = 0
        for num in arr:
            count += (num + k - 1) // k  
        return count

#{ 
 # Driver Code Starts.
#Initial Template for Python 3

if __name__ == "__main__":
    t = int(input())
    while t > 0:
        k= int(input())
        arr = list(map(int, input().split()))
        ob = Solution()
        res = ob.totalCount(k,arr)
        print(res)
        t -= 1


# } Driver Code Ends


================================================================================
Date: 2024-09-30
Problem: Merge two BST s
Filename: 2024-09-30_Merge_two_BST_s.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3

# } Driver Code Ends
#User function Template for python3
class Solution:
    def pushLeft(self, root, stack):
        while root:
            stack.append(root)
            root = root.left

    def merge(self, root1, root2):
        result = []
        s1, s2 = [], []
        self.pushLeft(root1, s1)
        self.pushLeft(root2, s2)
        while s1 or s2:
            if not s2 or (s1 and s1[-1].data <= s2[-1].data):
                node = s1.pop()
                result.append(node.data)
                self.pushLeft(node.right, s1)
            else:
                node = s2.pop()
                result.append(node.data)
                self.pushLeft(node.right, s2)

        return result
#{ 
 # Driver Code Starts.
class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def buildTree(s):
    # Corner Case
    if len(s) == 0 or s[0] == 'N':
        return None
    
    # Creating list of strings from input string after splitting by space
    ip = s.split()
    
    # Create the root of the tree
    root = Node(int(ip[0]))
    
    # Push the root to the queue
    queue = [root]
    
    # Starting from the second element
    i = 1
    while queue and i < len(ip):
        # Get and remove the front of the queue
        currNode = queue.pop(0)
        
        # Get the current node's value from the string
        currVal = ip[i]
        
        # If the left child is not null
        if currVal != "N":
            # Create the left child for the current node
            currNode.left = Node(int(currVal))
            
            # Push it to the queue
            queue.append(currNode.left)
        
        # For the right child
        i += 1
        if i >= len(ip):
            break
        currVal = ip[i]
        
        # If the right child is not null
        if currVal != "N":
            # Create the right child for the current node
            currNode.right = Node(int(currVal))
            
            # Push it to the queue
            queue.append(currNode.right)
        i += 1
    
    return root



def main():
    t = int(input())
    for _ in range(t):
        s = input()
        root1 = buildTree(s)
        s = input()
        root2 = buildTree(s)
        obj = Solution()
        vec = obj.merge(root1, root2)
        print(" ".join(map(str, vec)))

if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2024-10-01
Problem: Multiply two linked lists
Filename: 2024-10-01_Multiply_two_linked_lists.py
================================================================================

# your task is to complete this function
# Function should return an integer value
# head1 denotes head node of 1st list
# head2 denotes head node of 2nd list

'''
class node:
    def __init__(self):
        self.data = None
        self.next = None
'''

class Solution:
    def multiply_two_lists(self, first, second):
        num1 = 0
        num2 = 0
        MOD = 1000000007
        while first is not None:
            num1 = (num1 * 10 + first.data) % MOD
            first = first.next
        while second is not None:
            num2 = (num2 * 10 + second.data) % MOD
            second = second.next
        return (num1 * num2) % MOD





#{ 
 # Driver Code Starts
class Node:

    def __init__(self, data):
        self.data = data
        self.next = None


def new_node(data):
    return Node(data)


def push(head_ref, new_data):
    new_Node = new_node(new_data)
    new_Node.next = head_ref[0]
    head_ref[0] = new_Node


def reverse(r):
    prev = None
    cur = r[0]
    while cur is not None:
        nxt = cur.next
        cur.next = prev
        prev = cur
        cur = nxt
    r[0] = prev


def free_list(Node):
    while Node:
        temp = Node
        Node = Node.next
        del temp


def print_list(Node):
    while Node:
        print(Node.data, end=" ")
        Node = Node.next
    print()


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        first, second = [None], [None]
        arr = list(map(int, input().split()))
        for num in arr:
            push(first, num)

        brr = list(map(int, input().split()))
        for num in brr:
            push(second, num)

        reverse(first)
        reverse(second)

        ob = Solution()
        res = ob.multiply_two_lists(first[0], second[0])
        print(res)

# } Driver Code Ends


================================================================================
Date: 2024-10-02
Problem: Rotate and delete
Filename: 2024-10-02_Rotate_and_delete.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3

# } Driver Code Ends

# from typing import List
class Solution:
    def rotateDelete(self, arr):
        n = len(arr)
        k = 1
        while n > 1:
            arr.insert(0, arr.pop())
            id = n - k
            if id < 0:
                id = 0
            arr.pop(id)
            k += 1
            n -= 1
        
        return arr[0]

        


#{ 
 # Driver Code Starts.
#Initial Template for Python 3

if __name__ == "__main__":
    t = int(input())
    while t > 0:
        arr = list(map(int, input().split()))
        ob = Solution()
        res = ob.rotateDelete(arr)
        print(res)
        t -= 1


# } Driver Code Ends


================================================================================
Date: 2024-10-03
Problem: Majority Vote
Filename: 2024-10-03_Majority_Vote.py
================================================================================

class Solution:
    def findMajority(self, nums):
        n = len(nums)
        if n == 0:
            return [-1]  

        num1, num2 = -1, -1
        c1, c2 = 0, 0
        
        for x in nums:
            if x == num1:
                c1 += 1
            elif x == num2:
                c2 += 1
            elif c1 == 0:
                num1 = x
                c1 = 1
            elif c2 == 0:
                num2 = x
                c2 = 1
            else:
                c1 -= 1
                c2 -= 1
        
        c1, c2 = 0, 0
        for x in nums:
            if x == num1:
                c1 += 1
            elif x == num2:
                c2 += 1
        
        res = []
        if c1 > n // 3:
            res.append(num1)
        if c2 > n // 3:
            res.append(num2)
        
        if not res:
            res.append(-1)  
        
        return res

#{ 
 # Driver Code Starts
#Initial Template for Python 3


def main():
    t = int(input().strip())
    for _ in range(t):
        s = input().strip()
        nums = list(map(int, s.split()))
        ob = Solution()
        ans = ob.findMajority(nums)
        print(" ".join(map(str, ans)))


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2024-10-04
Problem: Deletion and Reverse in Circular Linked List
Filename: 2024-10-04_Deletion_and_Reverse_in_Circular_Linked_List.py
================================================================================

#User function Template for python3
'''
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

'''
class Solution:

    def reverse(self, head):
        if head is None or head.next == head:
            return head

        prev = head
        current = head.next
        nextNode = None

        while current != head:
            nextNode = current.next
            current.next = prev
            prev = current
            current = nextNode

        head.next = prev  
        return prev  

    def deleteNode(self, head, key):
        if head is None:
            return head

        current = head
        prev = None

        while True:
            if current.data == key:
                if current == head and current.next == head:
                    return None  

                if current == head:

                    tail = head
                    while tail.next != head:
                        tail = tail.next
                    head = current.next  
                    tail.next = head  
                else:
                    prev.next = current.next  
                return head

            prev = current
            current = current.next

            if current == head:
                break  

        return head  

#{ 
 # Driver Code Starts
class Node:

    def __init__(self, data):
        self.data = data
        self.next = None


def printList(head):
    if head is None:
        print("empty")
        return

    temp = head
    while True:
        print(temp.data, end=" ")
        temp = temp.next
        if temp == head:
            break
    print()


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        arr = list(map(int, input().split()))
        key = int(input())

        head = Node(arr[0])
        tail = head
        for i in range(1, len(arr)):
            tail.next = Node(arr[i])
            tail = tail.next
        tail.next = head  # Make the list circular

        ob = Solution()
        head = ob.deleteNode(head, key)
        head = ob.reverse(head)
        printList(head)

# } Driver Code Ends


================================================================================
Date: 2024-10-05
Problem: Not a subset sum
Filename: 2024-10-05_Not_a_subset_sum.py
================================================================================

#User function Template for python3
class Solution:
    def findSmallest(self, arr):
        res = 1
        for i in range(len(arr)):
            if arr[i] <= res:
                res += arr[i]
            else:
                break
        return res

#{ 
 # Driver Code Starts
#Initial Template for Python 3


def main():
    t = int(input())
    for _ in range(t):
        arr = list(map(int, input().split()))
        ob = Solution()
        ans = ob.findSmallest(arr)
        print(ans)


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2024-10-06
Problem: Find the number of islands
Filename: 2024-10-06_Find_the_number_of_islands.py
================================================================================

#User function Template for python3
class Solution:
    def numIslands(self, grid):
        n = len(grid)
        m = len(grid[0])
        ans = 0

        dx = [-1, 0, 1, 0, 1, -1, -1, 1]
        dy = [0, -1, 0, 1, 1, 1, -1, -1]

        def dfs(x, y):
            grid[x][y] = 0  
            for k in range(8):
                newX = x + dx[k]
                newY = y + dy[k]
                if is_valid(newX, newY) and grid[newX][newY] == 1:
                    dfs(newX, newY)

        def is_valid(x, y):
            return 0 <= x < n and 0 <= y < m

        for i in range(n):
            for j in range(m):
                if grid[i][j] == 1:
                    ans += 1
                    dfs(i, j)  

        return ans

#{ 
 # Driver Code Starts
# Driver code
if __name__ == "__main__":
    for _ in range(int(input())):
        n, m = map(int, input().strip().split())
        grid = []
        for i in range(n):
            grid.append([int(i) for i in input().strip().split()])
        obj = Solution()
        print(obj.numIslands(grid))

# } Driver Code Ends


================================================================================
Date: 2024-10-07
Problem: XOR Linked List
Filename: 2024-10-07_XOR_Linked_List.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3

# } Driver Code Ends
#User function Template for python3
def insert(head, data):
    new_node = Node(data)
    new_node.npx = head
    return new_node


def getList(head):
    result = []
    current = head
    while current is not None:
        result.append(current.data)
        current = current.npx
    return result


#{ 
 # Driver Code Starts.
#Back-end complete function Template for Python 3
class Node:
    def __init__(self, x):
        self.data = x
        self.npx = None

def XOR(a, b):
    return id(a) ^ id(b)


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        head = None
        data_list = list(map(int, input().split()))
        for data in data_list:
            head = insert(head, data)
        
        vec = getList(head)
        print(*vec)
        print(*reversed(vec))

# } Driver Code Ends


================================================================================
Date: 2024-10-08
Problem: Largest Pair Sum
Filename: 2024-10-08_Largest_Pair_Sum.py
================================================================================


from typing import List

class Solution:
    def pairsum(self, arr: List[int]) -> int:
        n = len(arr)
        if n < 2:
            return -1  

        first, second = float('-inf'), float('-inf')

        for num in arr:
            if num > first:
                second = first
                first = num
            elif num > second:
                second = num

        return first + second
#{ 
 # Driver Code Starts
class IntArray:

    def __init__(self) -> None:
        pass

    def Input(self, n):
        arr = [int(i) for i in input().strip().split()]  #array input
        return arr

    def Print(self, arr):
        for i in arr:
            print(i, end=" ")
        print()


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):

        arr = list(map(int, input().strip().split()))

        obj = Solution()
        res = obj.pairsum(arr)

        print(res)

# } Driver Code Ends


================================================================================
Date: 2024-10-09
Problem: Linked List Matrix
Filename: 2024-10-09_Linked_List_Matrix.py
================================================================================

#User function Template for python3

'''

class Node():
    def __init__(self,x):
        self.data = x
        self.right = None
        self.down=None

'''
class Solution:
    def constructLinkedMatrix(self, mat):
        m = len(mat)
        n = len(mat[0])
        nodeMatrix = [[None for _ in range(n)] for _ in range(m)]

        for i in range(m):
            for j in range(n):
                nodeMatrix[i][j] = Node(mat[i][j])

        for i in range(m):
            for j in range(n):
                if j < n - 1:
                    nodeMatrix[i][j].right = nodeMatrix[i][j + 1]  
                if i < m - 1:
                    nodeMatrix[i][j].down = nodeMatrix[i + 1][j]  

        return nodeMatrix[0][0]
#{ 
 # Driver Code Starts
class Node():

    def __init__(self, x):
        self.data = x
        self.right = None
        self.down = None


def display(head):
    Dp = head
    while Dp:
        Rp = Dp
        while Rp:
            print(Rp.data, end=" ")
            if Rp.right:
                print(Rp.right.data, end=" ")
            else:
                print("null", end=" ")
            if Rp.down:
                print(Rp.down.data, end=" ")
            else:
                print("null", end=" ")
            Rp = Rp.right
        Dp = Dp.down


if __name__ == "__main__":
    for _ in range(int(input())):
        # First row input
        a = list(map(int, input().strip().split()))
        n = len(a)

        # Input the matrix
        mat = [a]
        for i in range(1, n):
            row = list(map(int, input().strip().split()))
            mat.append(row)

        # Create a Solution object and construct the linked matrix
        obj = Solution()
        head = obj.constructLinkedMatrix(mat)
        if head is None:
            print(-1)
            continue
        display(head)
        print()

# } Driver Code Ends


================================================================================
Date: 2024-10-10
Problem: Max distance between same elements
Filename: 2024-10-10_Max_distance_between_same_elements.py
================================================================================

class Solution:
    def maxDistance(self, arr):
        mp = {}
        max_dist = 0
        for i in range(len(arr)):
            if arr[i] not in mp:
                mp[arr[i]] = i
            else:
                max_dist = max(max_dist, i - mp[arr[i]])

        return max_dist

#{ 
 # Driver Code Starts
if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        arr = list(map(int, input().split()))
        ob = Solution()
        print(ob.maxDistance(arr))

# } Driver Code Ends


================================================================================
Date: 2024-10-11
Problem: Reorganize The Array
Filename: 2024-10-11_Reorganize_The_Array.py
================================================================================

#{ 
 # Driver Code Starts

# } Driver Code Ends

class Solution:
    def rearrange(self, arr):
        n = len(arr)
        result = [-1] * n  
        for i in range(n):
            if 0 <= arr[i] < n:
                result[arr[i]] = arr[i]
        
        return result

#{ 
 # Driver Code Starts.
def main():
    t = int(input())
    for _ in range(t):
        input_str = input()
        arr = list(map(int, input_str.split()))
        solution = Solution()
        ans = solution.rearrange(arr)
        print(" ".join(map(str, ans)))

if __name__ == "__main__":
    main()
# } Driver Code Ends


================================================================================
Date: 2024-10-12
Problem: Two Smallests in Every Subarray
Filename: 2024-10-12_Two_Smallests_in_Every_Subarray.py
================================================================================

1)
class Solution:
    def pairWithMaxSum(self, arr):
        n = len(arr)

        if n < 2:
            return -1

        max_sum = arr[0] + arr[1]  

        for i in range(1, n - 1):
            max_sum = max(max_sum, arr[i] + arr[i + 1])

        return max_sum

2)
class Solution:
    def pairWithMaxSum(self, arr):
        n = len(arr)
        if n < 2:
            return -1  

        max_sum = arr[0] + arr[1] 
        for i in range(1, n - 1):
            current_sum = arr[i] + arr[i + 1] 
            max_sum = max(max_sum, current_sum) 

        return max_sum

3)
class Solution:
    def pairWithMaxSum(self, arr):
        if len(arr) < 2:
            return -1 
        
        return max(arr[i] + arr[i + 1] for i in range(len(arr) - 1))

#{ 
 # Driver Code Starts
if __name__ == "__main__":
    import sys
    input = sys.stdin.read
    data = input().strip().split("\n")

    t = int(data[0])
    lines = data[1:]

    for line in lines:
        s = list(map(int, line.strip().split()))
        solution = Solution()
        res = solution.pairWithMaxSum(s)
        print(res)

# } Driver Code Ends


================================================================================
Date: 2024-10-13
Problem: Delete Alternate Nodes
Filename: 2024-10-13_Delete_Alternate_Nodes.py
================================================================================

#User function Template for python3

'''class Node: 
   
    # Function to initialize the node object 
    def __init__(self, data): 
        self.data = data  
        self.next = None'''
class Solution:
    def deleteAlt(self, head):
        if not head:  
            return

        current = head
        while current and current.next:
            temp = current.next  
            current.next = current.next.next  
            current = current.next  


 # Driver Code Starts
#Initial Template for Python 3


class Node:

    def __init__(self, data):
        self.data = data
        self.next = None


def printList(node):
    while node:
        print(node.data, end=" ")
        node = node.next
    print()


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        arr = list(map(int, input().strip().split()))
        head = Node(arr[0])
        tail = head
        for i in range(1, len(arr)):
            tail.next = Node(arr[i])
            tail = tail.next
        ob = Solution()
        ob.deleteAlt(head)
        printList(head)

# } Driver Code Ends


================================================================================
Date: 2024-10-14
Problem: Count Linked List Nodes
Filename: 2024-10-14_Count_Linked_List_Nodes.py
================================================================================

#User function Template for python3

'''

#Linked list class
class LinkedList:
    def __init__(self):
        self.head=None
        self.tail=None
        '''
class Solution:
    def getCount(self, head):
        if head is None:
            return 0
        return 1 + self.getCount(head.next)

#{ 
 # Driver Code Starts
#Initial Template for Python 3


class Node:

    def __init__(self, data):
        self.data = data
        self.next = None


if __name__ == "__main__":
    import sys
    input = sys.stdin.read
    data = input().split('\n')

    t = int(data[0])
    for i in range(1, t + 1):
        arr = list(map(int, data[i].split()))
        head = Node(arr[0])
        tail = head
        for value in arr[1:]:
            tail.next = Node(value)
            tail = tail.next
        ob = Solution()
        print(ob.getCount(head))

# } Driver Code Ends


================================================================================
Date: 2024-10-15
Problem: Subarray range with given sum
Filename: 2024-10-15_Subarray_range_with_given_sum.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3

# } Driver Code Ends
#User function Template for python3

class Solution:
    def subArraySum(self, arr, target):
        prefixSumMap = {0: 1}  
        curr_sum = 0
        count = 0
        
        for num in arr:
            curr_sum += num
            if (curr_sum - target) in prefixSumMap:
                count += prefixSumMap[curr_sum - target]
            prefixSumMap[curr_sum] = prefixSumMap.get(curr_sum, 0) + 1
        
        return count


#{ 
 # Driver Code Starts.
#Initial Template for Python 3

if __name__ == "__main__":
    t = int(input())
    while t > 0:
        arr = list(map(int, input().split()))
        tar= int(input())
        ob = Solution()
        res = ob.subArraySum(arr,tar)
        print(res)
        # print("~")
        t -= 1


# } Driver Code Ends


================================================================================
Date: 2024-10-16
Problem: Two Swaps
Filename: 2024-10-16_Two_Swaps.py
================================================================================

class Solution:
    def checkSorted(self, arr):
        n = len(arr)
        swapCnt = 0

        for i in range(n):
            if arr[i] == i + 1:
                continue
            while arr[i] != i + 1:
                arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1]
                swapCnt += 1

        return swapCnt == 2 or swapCnt == 0


#{ 
 # Driver Code Starts
if __name__ == "__main__":
    t = int(input().strip())

    for _ in range(t):
        arr = list(map(int, input().split()))

        sol = Solution()
        result = sol.checkSorted(arr)
        if result:
            print("true")
        else:
            print("false")

# } Driver Code Ends


================================================================================
Date: 2024-10-17
Problem: Split Linked List Alternatingly
Filename: 2024-10-17_Split_Linked_List_Alternatingly.py
================================================================================

#User function Template for python3
'''
class Node:
    def _init_(self, data):
        self.data = data
        self.next = None

'''

class Solution:
    def alternatingSplitList(self, head):
        if head is None:
            return None, None

        a_head = None
        b_head = None
        a_tail = None
        b_tail = None
        current = head

        while current is not None:
            if a_head is None:
                a_head = Node(current.data)
                a_tail = a_head
            else:
                a_tail.next = Node(current.data)
                a_tail = a_tail.next
            
            current = current.next
            if current is not None:
                if b_head is None:
                    b_head = Node(current.data)
                    b_tail = b_head
                else:
                    b_tail.next = Node(current.data)
                    b_tail = b_tail.next
                
                current = current.next
        
        return a_head, b_head
#{ 
 # Driver Code Starts
class Node:

    def __init__(self, x):
        self.data = x
        self.next = None


def printList(node):
    while node is not None:
        print(node.data, end=" ")
        node = node.next
    print()


if __name__ == "__main__":
    t = int(input().strip())

    for _ in range(t):
        arr = list(map(int, input().strip().split()))

        head = Node(arr[0])
        tail = head

        for i in range(1, len(arr)):
            tail.next = Node(arr[i])
            tail = tail.next

        ob = Solution()
        result = ob.alternatingSplitList(head)
        printList(result[0])
        printList(result[1])

# } Driver Code Ends


================================================================================
Date: 2024-10-18
Problem: Single Number
Filename: 2024-10-18_Single_Number.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3

# } Driver Code Ends
#User function Template for python3

class Solution:
    def getSingle(self, arr):
        xr = 0
        for num in arr:
            xr ^= num
        return xr


#{ 
 # Driver Code Starts.
#Initial Template for Python 3

if __name__ == "__main__":
    t = int(input())
    while t > 0:
        # k= int(input())
        arr = list(map(int, input().split()))
        ob = Solution()
        res = ob.getSingle(arr)
        print(res)
        t -= 1


# } Driver Code Ends

================================================================================
Date: 2024-10-19
Problem: Nearest multiple of 10
Filename: 2024-10-19_Nearest_multiple_of_10.py
================================================================================

#User function Template for python3
class Solution:
    def roundToNearest(self, num_str: str) -> str:
        n = len(num_str)
        if n == 0:
            return num_str  

        last_digit = int(num_str[-1])  

        if last_digit <= 5:
            return num_str[:-1] + '0'  
        else:
            num_str = num_str[:-1] + '0'  
            i = n - 2

            while i >= 0:
                if num_str[i] != '9':
                    return num_str[:i] + chr(ord(num_str[i]) + 1) + num_str[i + 1:]  
                num_str = num_str[:i] + '0' + num_str[i + 1:]  
                i -= 1

            return '1' + num_str  
            
#{ 
 # Driver Code Starts
#Initial Template for Python 3
for _ in range(0, int(input())):
    num_str = input()
    ob = Solution()
    res = ob.roundToNearest(num_str)
    print(res)

# } Driver Code Ends


================================================================================
Date: 2024-10-20
Problem: Sort a k sorted doubly linked list
Filename: 2024-10-20_Sort_a_k_sorted_doubly_linked_list.py
================================================================================

#User function Template for python3
'''
class DLLNode:
    def __init__(self,val) -> None:
        self.data = val
        self.prev = None
        self.next = None
'''
import heapq

class Solution:
    def sortAKSortedDLL(self, head, k):
        if not head:
            return None

        pq = []
        newHead = None
        last = None
        counter = 0

        for i in range(k + 1):
            if not head:
                break
            heapq.heappush(pq, (head.data, counter, head))
            head = head.next
            counter += 1

        while pq:
            data, _, min_node = heapq.heappop(pq)
            if not newHead:
                newHead = min_node
                newHead.prev = None
                last = newHead
            else:
                last.next = min_node
                min_node.prev = last
                last = min_node

            if head:
                heapq.heappush(pq, (head.data, counter, head))
                head = head.next
                counter += 1

        last.next = None
        return newHead



#{ 
 # Driver Code Starts
import heapq


# A node of the doubly linked list
class DLLNode:

    def __init__(self, val):
        self.data = val
        self.next = None
        self.prev = None


# Function to insert a node at the end of the doubly linked list
def push(tail, new_data):
    new_node = DLLNode(new_data)
    new_node.next = None
    new_node.prev = tail

    if tail is not None:
        tail.next = new_node

    return new_node


# Function to print nodes in a given doubly linked list
def printList(head):
    while head is not None:
        print(head.data, end=" ")
        head = head.next
    print()


# Driver code
if __name__ == "__main__":
    t = int(input())  # Number of test cases
    for _ in range(t):
        arr = list(map(int, input().split()))  # Read the input array
        k = int(input())  # Read the value of k

        head = DLLNode(arr[0])
        tail = head

        for i in range(1, len(arr)):
            tail = push(tail, arr[i])

        solution = Solution()
        sorted_head = solution.sortAKSortedDLL(head, k)
        printList(sorted_head)

# } Driver Code Ends


================================================================================
Date: 2024-10-21
Problem: Split the Array
Filename: 2024-10-21_Split_the_Array.py
================================================================================

#User function Template for python3
class Solution:
    def power(self, x, y, p):
        result = 1
        x = x % p
        while y > 0:
            if y & 1:
                result = (result * x) % p
            y >>= 1
            x = (x * x) % p
        return result

    def countgroup(self, arr): 
        mod = 1000000007
        n = len(arr)
        xs = 0
        for num in arr:
            xs ^= num
        if xs == 0:
            return (self.power(2, n - 1, mod) - 1 + mod) % mod
        return 0



#{ 
 # Driver Code Starts
if __name__ == "__main__":
    t = int(input())
    while t > 0:
        arr = list(map(int, input().split()))
        ob = Solution()
        res = ob.countgroup(arr)
        print(res)
        t -= 1

# } Driver Code Ends


================================================================================
Date: 2024-10-22
Problem: Sub-arrays with equal number of occurences
Filename: 2024-10-22_Sub-arrays_with_equal_number_of_occurences.py
================================================================================

#User function Template for python3
class Solution:
    def sameOccurrence(self, arr, x, y):
        diffCount = {}  
        diff = 0        
        result = 0

        diffCount[0] = 1

        for i in arr:
            if i == x:
                diff += 1  
            elif i == y:
                diff -= 1  

            result += diffCount.get(diff, 0)

            diffCount[diff] = diffCount.get(diff, 0) + 1

        return result
#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    tc = int(input())
    while tc > 0:
        arr = list(map(int, input().strip().split()))
        x = int(input().strip())
        y = int(input().strip())
        ob = Solution()
        ans = ob.sameOccurrence(arr, x, y)
        print(ans)
        tc -= 1

# } Driver Code Ends


================================================================================
Date: 2024-10-23
Problem: Find the Sum of Last N nodes of the Linked List
Filename: 2024-10-23_Find_the_Sum_of_Last_N_nodes_of_the_Linked_List.py
================================================================================

#User function Template for python3

'''
# Node Class
class Node:
    def __init__(self, data):   # data -> value stored in node
        self.data = data
        self.next = None
'''
class Solution:
    def sumOfLastN_Nodes(self, head, n):
        if n <= 0 or head is None:
            return 0

        fast = head
        slow = head

        for _ in range(n):
            if fast is None:
                return 0
            fast = fast.next

        sum_last_n = 0

        while fast is not None:
            fast = fast.next
            slow = slow.next

        while slow is not None:
            sum_last_n += slow.data
            slow = slow.next

        return sum_last_n

#{ 
 # Driver Code Starts
#Initial Template for Python 3


class Node:

    def __init__(self, data):
        self.data = data
        self.next = None


if __name__ == "__main__":
    import sys
    input = sys.stdin.read
    data = input().split('\n')

    t = int(data[0])
    for i in range(1, t + 1):
        arr = list(map(int, data[2 * i - 1].split()))
        n = int(data[2 * i])
        head = Node(arr[0])
        tail = head
        for value in arr[1:]:
            tail.next = Node(value)
            tail = tail.next
        ob = Solution()
        print(ob.sumOfLastN_Nodes(head, n))

# } Driver Code Ends


================================================================================
Date: 2024-10-24
Problem: Modify the Array
Filename: 2024-10-24_Modify_the_Array.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3

# } Driver Code Ends
#User function Template for python3

class Solution:
    def modifyAndRearrangeArr(self, arr):
        n = len(arr)

        for i in range(n - 1):
            if arr[i] != 0 and arr[i] == arr[i + 1]:
                arr[i] = 2 * arr[i]
                arr[i + 1] = 0

        nonZeroIndex = 0
        for i in range(n):
            if arr[i] != 0:
                arr[nonZeroIndex] = arr[i]
                nonZeroIndex += 1

        while nonZeroIndex < n:
            arr[nonZeroIndex] = 0
            nonZeroIndex += 1

        return arr

#{ 
 # Driver Code Starts.
#Initial Template for Python 3

if __name__ == "__main__":
    t = int(input())
    while t > 0:
        arr = list(map(int, input().split()))
        ob = Solution()
        ans = ob.modifyAndRearrangeArr(arr)
        print(*ans)
        t -= 1


# } Driver Code Ends


================================================================================
Date: 2024-10-25
Problem: Alternative Sorting
Filename: 2024-10-25_Alternative_Sorting.py
================================================================================

class Solution:
    def alternateSort(self, arr):
        arr.sort()  
        n = len(arr)
        ans = []
        
        left, right = 0, n - 1
        highTurn = True
        
        for _ in range(n):
            if highTurn:
                ans.append(arr[right])
                right -= 1
            else:
                ans.append(arr[left])
                left += 1
            highTurn = not highTurn
        
        return ans


#{ 
 # Driver Code Starts
#Initial Template for Python 3
#Position this line where user code will be pasted.
#Initial Template for Python 3

if __name__ == "__main__":
    t = int(input())
    while t > 0:
        arr = list(map(int, input().split()))
        ob = Solution()
        ans = ob.alternateSort(arr)
        print(*ans)
        print("~")
        t -= 1

# } Driver Code Ends

================================================================================
Date: 2024-10-26
Problem: Occurence of an integer in a Linked List
Filename: 2024-10-26_Occurence_of_an_integer_in_a_Linked_List.py
================================================================================

"""  
class Node:
    def __init__(self, data):
		self.data = data
		self.next = None
  This is method only submission.
  You only need to complete the method.
"""
class Solution:
    def count(self, head, key):
        count = 0
        current = head
        while current:
            count += 1 if current.data == key else 0
            current = current.next
        return count

#{ 
 # Driver Code Starts
#Initial Template for Python 3


class Node:

    def __init__(self, data):
        self.data = data
        self.next = None


if __name__ == "__main__":
    import sys
    input = sys.stdin.read
    data = input().split('\n')

    t = int(data[0])
    for i in range(1, t + 1):
        arr = list(map(int, data[2 * i - 1].split()))
        head = Node(arr[0])
        tail = head
        for value in arr[1:]:
            tail.next = Node(value)
            tail = tail.next
        key = int(data[2 * i])
        ob = Solution()
        print(ob.count(head, key))
        print("~")

# } Driver Code Ends


================================================================================
Date: 2024-10-27
Problem: Triplet Family
Filename: 2024-10-27_Triplet_Family.py
================================================================================

class Solution:
    def findTriplet(self, arr):
        n = len(arr)
        if n < 3:
            return False

        arr.sort()  # Sort array

        for i in range(n - 1, 1, -1):
            target = arr[i]
            left, right = 0, i - 1

            while left < right:
                sum_ = arr[left] + arr[right]

                if sum_ == target:
                    return True
                elif sum_ < target:
                    left += 1  
                else:
                    right -= 1 

        return False  


#{ 
 # Driver Code Starts
#Initial Template for Python 3
# Position this line where user code will be pasted.
#Initial Template for Python 3

if __name__ == "__main__":
    t = int(input())
    while t > 0:
        arr = list(map(int, input().split()))
        ob = Solution()
        res = ob.findTriplet(arr)
        if (res):
            print("true")
        else:
            print("false")
        # print(res)
        print("~")
        t -= 1

# } Driver Code Ends


================================================================================
Date: 2024-10-28
Problem: Remove duplicates in array
Filename: 2024-10-28_Remove_duplicates_in_array.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3

# } Driver Code Ends

class Solution:
    def removeDuplicates(self, arr):
        seen = set()
        result = []
        for num in arr:
            if num not in seen:
                result.append(num)
                seen.add(num)
        return result
    

#{ 
 # Driver Code Starts.
#Initial Template for Python 3

if __name__ == "__main__":
    t = int(input())
    while t > 0:
        arr = list(map(int, input().split()))
        ob = Solution()
        ans = ob.removeDuplicates(arr)
        print(*ans)
        print("~")
        t -= 1


# } Driver Code Ends


================================================================================
Date: 2024-10-29
Problem: Quick Sort on Linked List
Filename: 2024-10-29_Quick_Sort_on_Linked_List.py
================================================================================

#User function Template for python3

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class Llist:
    def __init__(self):
        self.head = None

    def insert(self, data, tail):
        node = Node(data)
        if not self.head:
            self.head = node
            return node
        tail.next = node
        return node

def split(head):
    slow = head
    fast = head
    prev = None
    while fast and fast.next:
        prev = slow
        slow = slow.next
        fast = fast.next.next
    if prev:
        prev.next = None
    return slow

def merge(left, right):
    if not left:
        return right
    if not right:
        return left
    if left.data < right.data:
        left.next = merge(left.next, right)
        return left
    else:
        right.next = merge(left, right.next)
        return right

def mergeSort(head):
    if not head or not head.next:
        return head
    mid = split(head)
    left = mergeSort(head)
    right = mergeSort(mid)
    return merge(left, right)

def quickSort(head):
    return mergeSort(head)

#{ 
 # Driver Code Starts
#Initial Template for Python 3

#contributed by RavinderSinghPB
from collections import defaultdict


class Node:

    def __init__(self, data):
        self.data = data
        self.next = None


class Llist:

    def __init__(self):
        self.head = None

    def insert(self, data, tail):
        node = Node(data)

        if not self.head:
            self.head = node
            return node

        tail.next = node
        return node


def nodeID(head, dic):
    while head:
        dic[head.data].append(id(head))
        head = head.next


def printList(head, dic):
    while head:
        if id(head) not in dic[head.data]:
            print("Do'nt swap data, swap pointer/node")
            return
        print(head.data, end=' ')
        head = head.next


if __name__ == '__main__':
    t = int(input())

    for tcs in range(t):

        arr = [int(x) for x in input().split()]

        ll = Llist()
        tail = None

        for nodeData in arr:
            tail = ll.insert(nodeData, tail)

        dic = defaultdict(list)  # dictonary to keep data and id of node
        nodeID(ll.head, dic)  # putting data and its id

        resHead = quickSort(ll.head)
        printList(resHead, dic)  #verifying and printing
        print()

        print("~")

# } Driver Code Ends


================================================================================
Date: 2024-10-30
Problem: Pairs with difference k
Filename: 2024-10-30_Pairs_with_difference_k.py
================================================================================

#User function Template for python3
class Solution:
    def countPairsWithDiffK(self, arr, k):
        num_set = set(arr)
        count = 0

        for x in num_set:
            if (x + k) in num_set:
                count += arr.count(x) * arr.count(x + k)
                
        return count




#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    tc = int(input())
    while tc > 0:
        arr = list(map(int, input().strip().split()))
        k = int(input().strip())
        ob = Solution()
        ans = ob.countPairsWithDiffK(arr, k)
        print(ans)
        print("~")
        tc -= 1

# } Driver Code Ends


================================================================================
Date: 2024-11-01
Problem: Swap and Maximize
Filename: 2024-11-01_Swap_and_Maximize.py
================================================================================

#User function Template for python3

class Solution:
    def maxSum(self, arr):

        arr.sort()

        totalSum = 0
        n = len(arr)

        for i in range(n // 2):
            totalSum += abs(arr[n - i - 1] - arr[i])
            totalSum += abs(arr[i] - arr[n - i - 1])

        return totalSum

#{ 
 # Driver Code Starts
#Initial Template for Python 3


def main():
    t = int(input())
    for _ in range(t):
        arr = list(map(int, input().split()))
        ob = Solution()
        ans = ob.maxSum(arr)  # Call maxSum method and store result in ans
        print(ans)  # Print the result
        print("~")


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2024-11-02
Problem: Kth distance
Filename: 2024-11-02_Kth_distance.py
================================================================================

#User function Template for python3
class Solution:
    def checkDuplicatesWithinK(self, arr, k):
        mp = {}

        for i in range(len(arr)):
            if arr[i] in mp and i - mp[arr[i]] <= k:
                return True
            mp[arr[i]] = i

        return False
#{ 
 # Driver Code Starts
# Initial Template for Python 3
# Position this line where user code will be pasted.
# Initial Template for Python 3

if __name__ == "__main__":
    t = int(input())
    while t > 0:
        arr = list(map(int, input().split()))
        k = int(input())
        ob = Solution()
        res = ob.checkDuplicatesWithinK(arr, k)
        if res:
            print("true")
        else:
            print("false")
        # print(res)
        print("~")
        t -= 1
# } Driver Code Ends


================================================================================
Date: 2024-11-03
Problem: Is Linked List Length Even
Filename: 2024-11-03_Is_Linked_List_Length_Even.py
================================================================================

class Solution:

    def isLengthEven(self, head):
        fast = head

        while fast is not None and fast.next is not None:
            fast = fast.next.next

        return fast is None

#{ 
 # Driver Code Starts
#main


class Node:
    # Constructor to initialize the node object
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    # Function to initialize head
    def __init__(self):
        self.head = None

    # Function to insert a new node at the beginning
    def push(self, new_data):
        new_node = Node(new_data)
        new_node.next = self.head
        self.head = new_node

    # Utility function to prit the linked LinkedList
    def printList(self):
        temp = self.head
        while (temp):
            print(temp.data, end=" ")
            temp = temp.next
        print("")


if __name__ == '__main__':
    t = int(input())
    while (t > 0):
        llist = LinkedList()
        values = input().strip().split()
        for i in reversed(values):
            llist.push(i)
        flag = Solution().isLengthEven(llist.head)
        if flag:
            print("true")
        else:
            print("false")
        print("~")
        t -= 1
# Contributed by: Harshit Sidhwa

# } Driver Code Ends


================================================================================
Date: 2024-11-04
Problem: Find All Triplets with Zero Sum
Filename: 2024-11-04_Find_All_Triplets_with_Zero_Sum.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3

import math


# } Driver Code Ends
#User function Template for python3
class Solution:
    def findTriplets(self, arr):
        n = len(arr)
        mp = {}
        ans = []

        for i in range(n):
            if arr[i] not in mp:
                mp[arr[i]] = []
            mp[arr[i]].append(i)

        for i in range(n):
            for j in range(i + 1, n):
                num = -(arr[i] + arr[j])
                if num in mp:
                    for index in mp[num]:
                        if index > j:
                            ans.append([i, j, index])

        return ans

#{ 
 # Driver Code Starts.

def main():
    T = int(input())
    while (T > 0):

        A = [int(x) for x in input().strip().split()]

        ob = Solution()
        res = ob.findTriplets(A)
        res = sorted(res)
        if len(res) == 0:
            print('[]')
        for i in range(len(res)):
            for j in range(len(res[i])):
                print(res[i][j], end=" ")
            print("")
        print('~')
        T -= 1


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2024-11-05
Problem: Rotate by 90 degree
Filename: 2024-11-05_Rotate_by_90_degree.py
================================================================================

#User function Template for python3
def rotate(mat):
    n = len(mat)
    for i in range(n // 2):
        for j in range(i, n - i - 1):
            temp = mat[i][j]
            mat[i][j] = mat[n - j - 1][i]
            mat[n - j - 1][i] = mat[n - i - 1][n - j - 1]
            mat[n - i - 1][n - j - 1] = mat[j][n - i - 1]
            mat[j][n - i - 1] = temp


#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        N = int(input())
        matrix = []
        for i in range(N):
            arr = [int(x) for x in input().strip().split()]
            matrix.append(arr)

        rotate(matrix)
        for i in range(N):
            for j in range(N):
                print(matrix[i][j], end=' ')
            print()
        print("~")

# } Driver Code Ends


================================================================================
Date: 2024-11-06
Problem: Root to leaf paths sum
Filename: 2024-11-06_Root_to_leaf_paths_sum.py
================================================================================

# Your task is to complete this function
# function should return max sum level in the tree
class Solution:
    def treePathSum(self, root):
        return self.calculateSum(root, 0)

    def calculateSum(self, node, currentValue):
        if not node:
            return 0
        currentValue = currentValue * 10 + node.data
        if not node.left and not node.right:
            return currentValue
        return (self.calculateSum(node.left, currentValue) +
                self.calculateSum(node.right, currentValue))




#{ 
 # Driver Code Starts
#Contributed by Sudarshan Sharma
from collections import deque


# Tree Node
class Node:

    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None


# Function to Build Tree
def buildTree(s):
    #Corner Case
    if (len(s) == 0 or s[0] == "N"):
        return None

    # Creating list of strings from input
    # string after spliting by space
    ip = list(map(str, s.split()))

    # Create the root of the tree
    #   print(ip)
    root = Node(int(ip[0]))
    size = 0
    q = deque()

    # Push the root to the queue
    q.append(root)
    size = size + 1

    # Starting from the second element
    i = 1
    while (size > 0 and i < len(ip)):
        # Get and remove the front of the queue
        currNode = q[0]
        q.popleft()
        size = size - 1

        # Get the current node's value from the string
        currVal = ip[i]

        # If the left child is not null
        if (currVal != "N"):

            # Create the left child for the current node
            currNode.left = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.left)
            size = size + 1
        # For the right child
        i = i + 1
        if (i >= len(ip)):
            break
        currVal = ip[i]

        # If the right child is not null
        if (currVal != "N"):

            # Create the right child for the current node
            currNode.right = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.right)
            size = size + 1
        i = i + 1
    return root


if __name__ == "__main__":
    t = int(input())
    for _ in range(0, t):
        s = input()
        root = buildTree(s)
        print(Solution().treePathSum(root))
        #   print()

        print("~")

# } Driver Code Ends


================================================================================
Date: 2024-11-07
Problem: Split array in three equal sum subarrays
Filename: 2024-11-07_Split_array_in_three_equal_sum_subarrays.py
================================================================================

#User function Template for python3
class Solution:
    
    def findSplit(self, arr):
        total_sum = sum(arr)
        if total_sum % 3 != 0:
            return [-1, -1]

        target_sum = total_sum // 3
        current_sum = 0
        first_index, second_index = -1, -1

        for i in range(len(arr)):
            current_sum += arr[i]

            if current_sum == target_sum and first_index == -1:
                first_index = i
            elif current_sum == 2 * target_sum and first_index != -1:
                second_index = i
                break

        if first_index != -1 and second_index != -1:
            last_part_sum = sum(arr[second_index + 1:])
            if last_part_sum == target_sum:
                return [first_index, second_index]

        return [-1, -1]
#{ 
 # Driver Code Starts
# Initial Template for Python 3

# Main
if __name__ == '__main__':
    t = int(input())
    while t:
        t -= 1
        arr = [int(x) for x in input().strip().split()]

        ob = Solution()
        result = ob.findSplit(arr)

        if (result == [-1, -1]) or len(result) != 2:
            print("false")
        else:
            sum1 = sum2 = sum3 = 0
            for i in range(len(arr)):
                if i <= result[0]:
                    sum1 += arr[i]
                elif i <= result[1]:
                    sum2 += arr[i]
                else:
                    sum3 += arr[i]

            if sum1 == sum2 == sum3:
                print("true")
            else:
                print("false")
        print("~")

# } Driver Code Ends


================================================================================
Date: 2024-11-08
Problem: Minimum repeat to make substring
Filename: 2024-11-08_Minimum_repeat_to_make_substring.py
================================================================================

class Solution:
    def computeLPSArray(self, s):
        lps = [0] * len(s)
        len_ = 0
        idx = 1

        while idx < len(s):
            if s[idx] == s[len_]:
                len_ += 1
                lps[idx] = len_
                idx += 1
            else:

                if len_ == 0:
                    lps[idx] = 0
                    idx += 1
                else:

                    len_ = lps[len_ - 1]
        return lps

    def KMPSearch(self, txt, pat, lps, rep):
        n, m = len(txt), len(pat)
        i = j = 0

        while i < n * rep:

            if txt[i % n] == pat[j]:
                i += 1
                j += 1

                if j == m:
                    return True

                    j = lps[j - 1]
            else:

                if j != 0:
                    j = lps[j - 1]
                else:
                    i += 1
        return False

    def minRepeats(self, s1, s2):

        n, m = len(s1), len(s2)

        lps = self.computeLPSArray(s2)

        x = (m + n - 1) // n

        if self.KMPSearch(s1, s2, lps, x):
            return x

        if self.KMPSearch(s1, s2, lps, x + 1):
            return x + 1

        return -1
#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        A = input()
        B = input()

        ob = Solution()
        print(ob.minRepeats(A, B))

# } Driver Code Ends


================================================================================
Date: 2024-11-09
Problem: Minimum sum
Filename: 2024-11-09_Minimum_sum.py
================================================================================

#User function Template for python3
class Solution:
    def minSum(self, arr):
        arr.sort()
        num1, num2 = "", ""
        toggle = True

        for num in arr:
            if toggle:
                if not (num == 0 and not num1):
                    num1 += str(num)
            else:
                if not (num == 0 and not num2):
                    num2 += str(num)
            toggle = not toggle

        if not num1:
            num1 = "0"
        if not num2:
            num2 = "0"

        return self.findSum(num1, num2)

    def findSum(self, str1, str2):
        n1, n2 = len(str1), len(str2)
        carry = 0
        result = []

        for i in range(max(n1, n2)):
            digit1 = int(str1[n1 - i - 1]) if i < n1 else 0
            digit2 = int(str2[n2 - i - 1]) if i < n2 else 0
            total = digit1 + digit2 + carry
            result.append(str(total % 10))
            carry = total // 10

        if carry:
            result.append(str(carry))

        return ''.join(result[::-1])


#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    tc = int(input())
    while tc > 0:
        arr = list(map(int, input().strip().split()))
        ob = Solution()
        ans = ob.minSum(arr)
        print(ans)
        tc -= 1

        print("~")

# } Driver Code Ends


================================================================================
Date: 2024-11-10
Problem: Union of Two Sorted Arrays with Distinct Elements
Filename: 2024-11-10_Union_of_Two_Sorted_Arrays_with_Distinct_Elements.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3

# } Driver Code Ends
#User function Template for python3
class Solution:
    def findUnion(self, a, b):
        res = []
        i, j = 0, 0
        n, m = len(a), len(b)

        while i < n and j < m:
            if a[i] < b[j]:
                res.append(a[i])
                i += 1
            elif a[i] > b[j]:
                res.append(b[j])
                j += 1
            else:
                res.append(a[i])
                i += 1
                j += 1
        while i < n:
            res.append(a[i])
            i += 1
        while j < m:
            res.append(b[j])
            j += 1

        return res
#{ 
 # Driver Code Starts.
if __name__ == '__main__':
    test_cases = int(input())
    for cases in range(test_cases):
        a = list(map(int, input().strip().split()))
        b = list(map(int, input().strip().split()))
        ob = Solution()
        li = ob.findUnion(a, b)
        for val in li:
            print(val, end=' ')
        print()
        print("~")
# } Driver Code Ends


================================================================================
Date: 2024-11-11
Problem: Make array elements unique
Filename: 2024-11-11_Make_array_elements_unique.py
================================================================================

#User function Template for python3

class Solution:
    def minIncrements(self, arr): 
        if not arr:
            return 0

        arr.sort()
        ans = 0

        for i in range(1, len(arr)):
            if arr[i] <= arr[i - 1]:
                ans += arr[i - 1] - arr[i] + 1
                arr[i] = arr[i - 1] + 1

        return ans


#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':

    T = int(input())
    while T > 0:
        arr = [int(i) for i in input().split()]
        ob = Solution()
        print(ob.minIncrements(arr))

        T -= 1

# } Driver Code Ends


================================================================================
Date: 2024-11-12
Problem: Meeting Rooms
Filename: 2024-11-12_Meeting_Rooms.py
================================================================================

#User function Template for python3
class Solution:
    def canAttend(self, arr):
        arr.sort(key=lambda x: x[0])  
        for i in range(len(arr) - 1):
            if arr[i][1] > arr[i + 1][0]:  
                return False
        return True  


#{ 
 # Driver Code Starts
if __name__ == '__main__':
    T = int(input())
    for i in range(T):
        n = int(input())
        # a = list(map(int, input().strip().split()))
        arr = []
        # j = 0
        for i in range(n):
            a = list(map(int, input().strip().split()))
            x = a[0]
            # j += 1
            y = a[1]
            # j += 1
            arr.append([x, y])
        obj = Solution()
        ans = obj.canAttend(arr)
        if ans:
            print("true")
        else:
            print("false")

# } Driver Code Ends


================================================================================
Date: 2024-11-13
Problem: Intersection Point in Y Shaped Linked Lists
Filename: 2024-11-13_Intersection_Point_in_Y_Shaped_Linked_Lists.py
================================================================================

#User function Template for python3
'''
	Function to return the value at point of intersection
	in two linked list, connected in y shaped form.
	
	Function Arguments: head_a, head_b (heads of both the lists)
	
	Return Type: value in NODE present at the point of intersection
	             or -1 if no common point.

	Contributed By: Nagendra Jha

	{
		# Node Class
		class Node:
		    def __init__(self, data):   # data -> value stored in node
		        self.data = data
		        self.next = None
	}
'''

def intersetPoint(head1, head2):
    if not head1 or not head2:
        return -1

    ptr1 = head1
    ptr2 = head2

    while ptr1 != ptr2:
        ptr1 = ptr1.next if ptr1 else head2
        ptr2 = ptr2.next if ptr2 else head1

    return ptr1.data if ptr1 else -1

#{ 
 # Driver Code Starts
#Initial Template for Python 3

#Contributed by : Nagendra Jha

import atexit
import io
import sys

_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__
_OUTPUT_BUFFER = io.StringIO()
sys.stdout = _OUTPUT_BUFFER


@atexit.register
def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())


# Node Class
class Node:

    def __init__(self, data):  # data -> value stored in node
        self.data = data
        self.next = None


class LinkedList:

    def __init__(self):
        self.head = None
        temp = None

    # creates a new node with given value and appends it at the end of the linked list
    def append(self, new_node):
        if self.head is None:
            self.head = new_node
            self.temp = self.head
            return
        else:
            self.temp.next = new_node
            self.temp = self.temp.next


if __name__ == '__main__':
    t = int(input())
    for cases in range(t):

        a = LinkedList()  # create a new linked list 'a'.
        b = LinkedList()  # create a new linked list 'b'.
        nodes_a = list(map(int, input().strip().split()))
        nodes_b = list(map(int, input().strip().split()))
        nodes_common = list(map(int, input().strip().split()))

        for x in nodes_a:
            node = Node(x)
            a.append(node)  # add to the end of the list

        for x in nodes_b:
            node = Node(x)
            b.append(node)  # add to the end of the list

        for i in range(len(nodes_common)):
            node = Node(nodes_common[i])
            a.append(node)  # add to the end of the list a
            if i == 0:
                b.append(
                    node
                )  # add to the end of the list b, only the intersection

        print(intersetPoint(a.head, b.head))

        print("~")

# } Driver Code Ends


================================================================================
Date: 2024-11-14
Problem: Nearly sorted
Filename: 2024-11-14_Nearly_sorted.py
================================================================================

#User function Template for python3
import heapq

class Solution:
    def nearlySorted(self, arr, k):
        if k == 0:
            return 
        minHeap = []
        for i in range(min(k + 1, len(arr))):
            heapq.heappush(minHeap, arr[i])

        index = 0
        for i in range(k + 1, len(arr)):
            arr[index] = heapq.heappop(minHeap)
            index += 1
            heapq.heappush(minHeap, arr[i])
        while minHeap:
            arr[index] = heapq.heappop(minHeap)
            index += 1


#{ 
 # Driver Code Starts
# Initial Template for Python 3
# Position this line where user code will be pasted.
# Initial Template for Python 3

if __name__ == "__main__":
    t = int(input())
    while t > 0:
        arr = list(map(int, input().split()))
        k = int(input())
        ob = Solution()
        ob.nearlySorted(arr, k)
        print(*arr)
        # print("~")
        t -= 1
# } Driver Code Ends


================================================================================
Date: 2024-11-15
Problem: Second Largest
Filename: 2024-11-15_Second_Largest.py
================================================================================

# User function Template for python3

class Solution:
    def getSecondLargest(self, arr):
        first = float('-inf')
        second = float('-inf')

        for num in arr:
            if num > first:
                second = first
                first = num
            elif num > second and num < first:
                second = num

        return -1 if second == float('-inf') else second

#{ 
 # Driver Code Starts
# Initial Template for Python 3

if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        arr = list(map(int, input().split()))
        ob = Solution()
        ans = ob.getSecondLargest(arr)
        print(ans)
        print("~")
# } Driver Code Ends


================================================================================
Date: 2024-11-16
Problem: Move All Zeroes to End
Filename: 2024-11-16_Move_All_Zeroes_to_End.py
================================================================================

#User function Template for python3
class Solution:
    def pushZerosToEnd(self, arr):
        n = len(arr)
        nonZeroIndex = 0

        for i in range(n):
            if arr[i] != 0:
                arr[nonZeroIndex], arr[i] = arr[i], arr[nonZeroIndex]
                nonZeroIndex += 1


#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    tc = int(input())
    while tc > 0:
        arr = list(map(int, input().strip().split()))
        ob = Solution()
        ob.pushZerosToEnd(arr)
        for x in arr:
            print(x, end=" ")
        print()
        tc -= 1
# } Driver Code Ends


================================================================================
Date: 2024-11-17
Problem: Reverse an Array
Filename: 2024-11-17_Reverse_an_Array.py
================================================================================

1)
class Solution:
    def reverseArray(self, arr):
        left, right = 0, len(arr) - 1

        while left < right:
            arr[left], arr[right] = arr[right], arr[left]
            left += 1
            right -= 1

2)
class Solution:
    def reverseArray(self, arr):
        arr.reverse()


#{ 
 # Driver Code Starts
import sys


def main():
    # Read the number of test cases
    tc = int(sys.stdin.readline())

    while tc > 0:
        # Read the array elements as a string
        str_arr = sys.stdin.readline().split()

        # Convert the string array to an integer array
        arr = [int(x) for x in str_arr]

        # Create a Solution object
        obj = Solution()

        # Reverse the array
        obj.reverseArray(arr)

        # Print the reversed array
        for i in range(0, len(arr)):
            print(arr[i], end=" ")
        print()

        # Decrement the test case count
        tc -= 1


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2024-11-18
Problem: Rotate Array
Filename: 2024-11-18_Rotate_Array.py
================================================================================

#User function Template for python3
class Solution:
    def rotateArr(self, arr, d):
        n = len(arr)
        d %= n
        arr[0:d] = reversed(arr[0:d])
        arr[d:n] = reversed(arr[d:n])
        arr[0:n] = reversed(arr[0:n])#{ 
 # Driver Code Starts
#Initial Template for Python 3

import math


def main():
    T = int(input())

    while (T > 0):
        A = [int(x) for x in input().strip().split()]
        nd = [int(x) for x in input().strip().split()]
        D = nd[0]
        ob = Solution()
        ob.rotateArr(A, D)

        for i in A:
            print(i, end=" ")

        print()

        T -= 1

        print("~")


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2024-11-19
Problem: Next Permutation
Filename: 2024-11-19_Next_Permutation.py
================================================================================

#User function Template for python3
class Solution:
    def nextPermutation(self, arr):
        n = len(arr)
        i = n - 2

        while i >= 0 and arr[i] >= arr[i + 1]:
            i -= 1

        if i >= 0:
            j = n - 1

            while arr[j] <= arr[i]:
                j -= 1

            arr[i], arr[j] = arr[j], arr[i]

        arr[i + 1:] = reversed(arr[i + 1:])
#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        arr = input().split()
        N = len(arr)
        for i in range(N):
            arr[i] = int(arr[i])

        ob = Solution()
        ob.nextPermutation(arr)
        for i in range(N):
            print(arr[i], end=" ")
        print()

# } Driver Code Ends


================================================================================
Date: 2024-11-20
Problem: Majority Element II
Filename: 2024-11-20_Majority_Element_II.py
================================================================================

class Solution:
    def findMajority(self, arr):
        num1, num2, c1, c2 = None, None, 0, 0
        n = len(arr)
        for x in arr:
            if x == num1:
                c1 += 1
            elif x == num2:
                c2 += 1
            elif c1 == 0:
                num1 = x
                c1 = 1
            elif c2 == 0:
                num2 = x
                c2 = 1
            else:
                c1 -= 1
                c2 -= 1
        c1, c2 = 0, 0
        for x in arr:
            if x == num1:
                c1 += 1
            elif x == num2:
                c2 += 1
        res = []
        if c1 > n // 3:
            res.append(num1)
        if c2 > n // 3:
            res.append(num2)
        res.sort()
        return res


#{ 
 # Driver Code Starts
#Initial Template for Python 3


def main():
    t = int(input().strip())
    for _ in range(t):
        s = input().strip()
        nums = list(map(int, s.split()))
        ob = Solution()
        ans = ob.findMajority(nums)
        if not ans:
            print("[]")
        else:
            print(" ".join(map(str, ans)))


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2024-11-21
Problem: Stock Buy and Sell  Multiple Transaction Allowed
Filename: 2024-11-21_Stock_Buy_and_Sell__Multiple_Transaction_Allowed.py
================================================================================

from typing import List

class Solution:
    def maximumProfit(self, prices: List[int]) -> int:
        profit = 0
        for i in range(1, len(prices)):
            if prices[i] > prices[i - 1]:
                profit += prices[i] - prices[i - 1]
        return profit




#{ 
 # Driver Code Starts
#Initial Template for Python 3
if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        arr = list(map(int, input().strip().split()))
        solution = Solution()
        res = solution.maximumProfit(arr)
        print(res)

# } Driver Code Ends


================================================================================
Date: 2024-11-22
Problem: Stock Buy and Sell  Max one Transaction Allowed
Filename: 2024-11-22_Stock_Buy_and_Sell__Max_one_Transaction_Allowed.py
================================================================================

class Solution:
    def maximumProfit(self, prices):
        buyPrice = prices[0]
        maxProfit = 0

        for i in range(1, len(prices)):
            if prices[i] > buyPrice:
                maxProfit = max(maxProfit, prices[i] - buyPrice)
            else:
                buyPrice = prices[i]

        return maxProfit



#{ 
 # Driver Code Starts
if __name__ == "__main__":
    t = int(input())  # Read number of test cases
    for _ in range(t):
        # Read input and split it into a list of integers
        prices = list(map(int, input().split()))
        # Create a Solution object and calculate the result
        obj = Solution()
        result = obj.maximumProfit(prices)
        # Print the result
        print(result)

# } Driver Code Ends


================================================================================
Date: 2024-11-23
Problem: Minimize the Heights I
Filename: 2024-11-23_Minimize_the_Heights_I.py
================================================================================

#User function Template for python3
class Solution:
    def getMinDiff(self, k: int, arr: list) -> int:
        n = len(arr)
        modified = []
        count = [0] * n

        for i in range(n):
            modified.append((arr[i] - k, i))
            modified.append((arr[i] + k, i))

        modified.sort()

        left = 0
        elements_in_range = 0
        ans = float('inf')

        for right in range(len(modified)):
            if count[modified[right][1]] == 0:
                elements_in_range += 1
            count[modified[right][1]] += 1

            while elements_in_range == n:
                ans = min(ans, modified[right][0] - modified[left][0])

                if count[modified[left][1]] == 1:
                    elements_in_range -= 1
                count[modified[left][1]] -= 1
                left += 1

        return ans

#{ 
 # Driver Code Starts
#Initial Template for Python 3
if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        k = int(input())
        arr = list(map(int, input().strip().split()))
        solution = Solution()
        res = solution.getMinDiff(k, arr)
        print(res)
        print("~")

# } Driver Code Ends


================================================================================
Date: 2024-11-24
Problem: Kadanes Algorithm
Filename: 2024-11-24_Kadanes_Algorithm.py
================================================================================

#User function Template for python3
class Solution:
    def maxSubArraySum(self, arr):
        maxh = 0
        maxf = float('-inf')  

        for num in arr:
            maxh = max(num, maxh + num)
            maxf = max(maxf, maxh)

        return maxf
#{ 
 # Driver Code Starts
#Initial Template for Python 3

import math


def main():
    T = int(input())
    while (T > 0):

        arr = [int(x) for x in input().strip().split()]

        ob = Solution()

        print(ob.maxSubArraySum(arr))

        T -= 1


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2024-11-25
Problem: Maximum Product Subarray
Filename: 2024-11-25_Maximum_Product_Subarray.py
================================================================================

#User function Template for python3
class Solution:

    def maxProduct(self, arr):
        max_product = arr[0]
        max_val = arr[0]
        min_val = arr[0]

        for i in range(1, len(arr)):
            if arr[i] < 0:
                max_val, min_val = min_val, max_val

            max_val = max(arr[i], max_val * arr[i])
            min_val = min(arr[i], min_val * arr[i])

            max_product = max(max_product, max_val)

        return max_product

#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    tc = int(input())
    while tc > 0:
        arr = list(map(int, input().strip().split()))
        ob = Solution()
        ans = ob.maxProduct(arr)
        print(ans)
        tc -= 1

# } Driver Code Ends


================================================================================
Date: 2024-11-26
Problem: Max Circular Subarray Sum
Filename: 2024-11-26_Max_Circular_Subarray_Sum.py
================================================================================

#User function Template for python3

#Complete this function
#Function to find maximum circular subarray sum.
def circularSubarraySum(arr):
    total_sum = 0
    max_sum = float('-inf')
    min_sum = float('inf')
    curr_max = 0
    curr_min = 0
    all_negative = True

    for num in arr:
        total_sum += num

        curr_max = max(num, curr_max + num)
        max_sum = max(max_sum, curr_max)

        curr_min = min(num, curr_min + num)
        min_sum = min(min_sum, curr_min)

        if num > 0:
            all_negative = False

    if all_negative:
        return max_sum

    return max(max_sum, total_sum - min_sum)

#{ 
 # Driver Code Starts
#Initial Template for Python 3

import math
import sys

if __name__ == "__main__":
    T = int(input())
    while (T > 0):

        arr = [int(x) for x in input().strip().split()]

        print(circularSubarraySum(arr))

        T -= 1

# } Driver Code Ends


================================================================================
Date: 2024-11-27
Problem: Smallest Positive Missing Number
Filename: 2024-11-27_Smallest_Positive_Missing_Number.py
================================================================================

#User function Template for python3
class Solution:
    def missingNumber(self, arr):
        n = len(arr)
        for i in range(n):
            while arr[i] > 0 and arr[i] <= n and arr[i] != arr[arr[i] - 1]:
                arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1]
        for i in range(n):
            if arr[i] != i + 1:
                return i + 1
        return n + 1


#{ 
 # Driver Code Starts
#Initial Template for Python 3

import math


def main():
    T = int(input())
    while (T > 0):
        arr = [int(x) for x in input().strip().split()]
        ob = Solution()
        print(ob.missingNumber(arr))
        T -= 1


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2024-11-28
Problem: Implement Atoi
Filename: 2024-11-28_Implement_Atoi.py
================================================================================

#User function template for Python
class Solution:
    def myAtoi(self, s: str) -> int:
        idx, sign, res = 0, 1, 0

        while idx < len(s) and s[idx] == ' ':
            idx += 1

        if idx < len(s) and (s[idx] == '-' or s[idx] == '+'):
            sign = -1 if s[idx] == '-' else 1
            idx += 1

        while idx < len(s) and '0' <= s[idx] <= '9':
            res = res * 10 + (ord(s[idx]) - ord('0'))
            idx += 1

            if res * sign > 2**31 - 1:
                return 2**31 - 1
            if res * sign < -2**31:
                return -2**31

        return sign * res


#{ 
 # Driver Code Starts
#Initial template for Python

if __name__ == '__main__':
    t = int(input())
    for i in range(t):
        s = input()
        ob = Solution()
        print(ob.myAtoi(s))
        print("~")

# } Driver Code Ends


================================================================================
Date: 2024-11-29
Problem: Add Binary Strings
Filename: 2024-11-29_Add_Binary_Strings.py
================================================================================

#User function Template for python3
class Solution:
    def addBinary(self, s1, s2):
        i, j = len(s1) - 1, len(s2) - 1
        carry = 0
        result = []

        while i >= 0 or j >= 0 or carry > 0:
            sum_ = carry
            if i >= 0:
                sum_ += int(s1[i])
                i -= 1
            if j >= 0:
                sum_ += int(s2[j])
                j -= 1
            result.append(str(sum_ % 2))
            carry = sum_ // 2

        result.reverse()
        result_str = ''.join(result)
        first_non_zero = result_str.find('1')
        return result_str[first_non_zero:] if first_non_zero != -1 else "0"
        
        #{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    T = int(input())
    for i in range(T):
        a = input().strip()
        b = input().strip()
        ob = Solution()
        answer = ob.addBinary(a, b)

        print(answer)
        print("~")

# } Driver Code Ends


================================================================================
Date: 2024-11-30
Problem: Anagram
Filename: 2024-11-30_Anagram.py
================================================================================

#User function Template for python3


class Solution:
    def areAnagrams(self, s1, s2):
        if len(s1) != len(s2):
            return False

        counts = [0] * 26
        for i in range(len(s1)):
            counts[ord(s1[i]) - ord('a')] += 1
            counts[ord(s2[i]) - ord('a')] -= 1

        for count in counts:
            if count != 0:
                return False

        return True



#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    t = int(input())
    for i in range(t):
        a = input().strip()
        b = input().strip()
        if (Solution().areAnagrams(a, b)):
            print("true")
        else:
            print("false")
        print("~")

# } Driver Code Ends


================================================================================
Date: 2024-12-01
Problem: Non Repeating Character
Filename: 2024-12-01_Non_Repeating_Character.py
================================================================================

#User function Template for python3

class Solution:
    def nonRepeatingChar(self, s):
        freq = [0] * 26  
        for c in s:
            freq[ord(c) - ord('a')] += 1
        for c in s:
            if freq[ord(c) - ord('a')] == 1:
                return c
        
        return '$'
    
    


#{ 
 # Driver Code Starts
#Initial Template for Python 3

import atexit
import io
import sys

_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__
_OUTPUT_BUFFER = io.StringIO()
sys.stdout = _OUTPUT_BUFFER


@atexit.register
def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())


if __name__ == '__main__':
    t = int(input())
    for i in range(t):
        s = str(input())
        obj = Solution()
        ans = obj.nonRepeatingChar(s)
        if (ans != '$'):
            print(ans)
        else:
            print(-1)

        print("~")

# } Driver Code Ends


================================================================================
Date: 2024-12-02
Problem: Search Pattern KMP-Algorithm
Filename: 2024-12-02_Search_Pattern_KMP-Algorithm.py
================================================================================

#User function Template for python3
class Solution:
    def computeLPSArray(self, pat, m, lps):
        len = 0
        i = 1
        while i < m:
            if pat[i] == pat[len]:
                len += 1
                lps[i] = len
                i += 1
            else:
                if len != 0:
                    len = lps[len - 1]
                else:
                    lps[i] = 0
                    i += 1

    def search(self, pat, txt):
        result = []
        m = len(pat)
        n = len(txt)
        lps = [0] * m

        self.computeLPSArray(pat, m, lps)

        i = 0
        j = 0
        while i < n:
            if txt[i] == pat[j]:
                i += 1
                j += 1

            if j == m:
                result.append(i - j)
                j = lps[j - 1]
            elif i < n and txt[i] != pat[j]:
                if j != 0:
                    j = lps[j - 1]
                else:
                    i += 1
        return result
#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        s = input().strip()
        patt = input().strip()
        ob = Solution()
        ans = ob.search(patt, s)
        if len(ans) == 0:
            print("[]", end="")
        for value in ans:
            print(value, end=' ')
        print()

# } Driver Code Ends


================================================================================
Date: 2024-12-03
Problem: Min Chars to Add for Palindrome
Filename: 2024-12-03_Min_Chars_to_Add_for_Palindrome.py
================================================================================

class Solution:
    def minChar(self, s):
        n = len(s)

        rev_str = s[::-1]

        combined = s + "$" + rev_str

        lps = [0] * len(combined)
        for i in range(1, len(combined)):
            j = lps[i - 1]
            while j > 0 and combined[i] != combined[j]:
                j = lps[j - 1]
            if combined[i] == combined[j]:
                j += 1
            lps[i] = j

        return n - lps[-1]
#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == "__main__":
    for _ in range(int(input())):
        s = input()
        obj = Solution()
        ans = obj.minChar(s)
        print(ans)
        print("~")

# } Driver Code Ends


================================================================================
Date: 2024-12-04
Problem: Strings Rotations of Each Other
Filename: 2024-12-04_Strings_Rotations_of_Each_Other.py
================================================================================

#User function Template for python3
class Solution:
    def areRotations(self, s1, s2):
        if len(s1) != len(s2):
            return False
        temp = s1 + s1
        return s2 in temp#{ 
 # Driver Code Starts
#Initial Template for Python 3
import atexit
import io
import sys

_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__
_OUTPUT_BUFFER = io.StringIO()
sys.stdout = _OUTPUT_BUFFER


@atexit.register
def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())


if __name__ == '__main__':
    t = int(input())
    for i in range(t):
        s1 = str(input())
        s2 = str(input())
        if (Solution().areRotations(s1, s2)):
            print("true")
        else:
            print("false")

# } Driver Code Ends


================================================================================
Date: 2024-12-05
Problem: Sort 0s 1s and 2s
Filename: 2024-12-05_Sort_0s_1s_and_2s.py
================================================================================

#{ 
 # Driver Code Starts

# } Driver Code Ends

# User function Template for Python
class Solution:
    def sort012(self, arr):
        low, mid, high = 0, 0, len(arr) - 1

        while mid <= high:
            if arr[mid] == 0:
                arr[low], arr[mid] = arr[mid], arr[low]
                low += 1
                mid += 1
            elif arr[mid] == 1:
                mid += 1
            else:
                arr[mid], arr[high] = arr[high], arr[mid]
                high -= 1
        

#{ 
 # Driver Code Starts.
def main():
    t = int(input().strip())  # Read the number of test cases
    ob = Solution()

    while t > 0:
        t -= 1
        arr = list(map(int,
                       input().strip().split())
                   )  # Read the array as space-separated integers
        ob.sort012(arr)  # Sort the array

        print(' '.join(map(str, arr)))  # Print the sorted array
        print("~")
        
if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2024-12-06
Problem: Find H-Index
Filename: 2024-12-06_Find_H-Index.py
================================================================================

#User function Template for python3
class Solution:
    def hIndex(self, citations):
        n = len(citations)
        buckets = [0] * (n + 1)

        for c in citations:
            if c >= n:
                buckets[n] += 1
            else:
                buckets[c] += 1

        cumulative = 0
        for i in range(n, -1, -1):
            cumulative += buckets[i]
            if cumulative >= i:
                return i
        return 0


#{ 
 # Driver Code Starts
# Initial Template for Python 3

# Main
if __name__ == '__main__':
    t = int(input())
    while t > 0:
        t -= 1
        arr = [int(x) for x in input().strip().split()]

        ob = Solution()
        result = ob.hIndex(arr)

        print(result)
        print("~")

# } Driver Code Ends


================================================================================
Date: 2024-12-07
Problem: Count Inversions
Filename: 2024-12-07_Count_Inversions.py
================================================================================

class Solution:
    def mergeAndCount(self, arr, temp, left, mid, right):
        i, j, k = left, mid + 1, left
        inversions = 0

        while i <= mid and j <= right:
            if arr[i] <= arr[j]:
                temp[k] = arr[i]
                i += 1
            else:
                temp[k] = arr[j]
                j += 1
                inversions += (mid - i + 1)
            k += 1

        while i <= mid:
            temp[k] = arr[i]
            i += 1
            k += 1

        while j <= right:
            temp[k] = arr[j]
            j += 1
            k += 1

        for i in range(left, right + 1):
            arr[i] = temp[i]

        return inversions

    def mergeSortAndCount(self, arr, temp, left, right):
        inversions = 0
        if left < right:
            mid = left + (right - left) // 2

            inversions += self.mergeSortAndCount(arr, temp, left, mid)
            inversions += self.mergeSortAndCount(arr, temp, mid + 1, right)
            inversions += self.mergeAndCount(arr, temp, left, mid, right)
        return inversions

    def inversionCount(self, arr):
        n = len(arr)
        temp = [0] * n
        return self.mergeSortAndCount(arr, temp, 0, n - 1)
        
#{ 
 # Driver Code Starts
#Initial Template for Python 3

import atexit
import io
import sys

_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__
_OUTPUT_BUFFER = io.StringIO()
sys.stdout = _OUTPUT_BUFFER


@atexit.register
def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())


if __name__ == '__main__':
    t = int(input())
    for tt in range(t):
        a = list(map(int, input().strip().split()))
        obj = Solution()
        print(obj.inversionCount(a))
        print("~")

# } Driver Code Ends


================================================================================
Date: 2024-12-08
Problem: Overlapping Intervals
Filename: 2024-12-08_Overlapping_Intervals.py
================================================================================

class Solution:
    def mergeOverlap(self, intervals):
        if not intervals:
            return []

        intervals.sort(key=lambda x: x[0])
        merged = [intervals[0]]

        for interval in intervals[1:]:
            last = merged[-1]
            if interval[0] <= last[1]:
                last[1] = max(last[1], interval[1])
            else:
                merged.append(interval)

        return merged
#{ 
 # Driver Code Starts
if __name__ == '__main__':
    T = int(input())
    for i in range(T):
        n = int(input())
        # a = list(map(int, input().strip().split()))
        arr = []
        # j = 0
        for i in range(n):
            a = list(map(int, input().strip().split()))
            x = a[0]
            # j += 1
            y = a[1]
            # j += 1
            arr.append([x, y])
        obj = Solution()
        ans = obj.mergeOverlap(arr)
        for i in ans:
            for j in i:
                print(j, end=" ")
        print()

# } Driver Code Ends


================================================================================
Date: 2024-12-09
Problem: Insert Interval
Filename: 2024-12-09_Insert_Interval.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3

# } Driver Code Ends
#User function Template for python3
class Solution:
    def insertInterval(self, intervals, newInterval):
        result = []
        for interval in intervals:
            if interval[1] < newInterval[0]:
                result.append(interval)
            elif interval[0] > newInterval[1]:
                result.append(newInterval)
                newInterval = interval
            else:
                newInterval[0] = min(newInterval[0], interval[0])
                newInterval[1] = max(newInterval[1], interval[1])
        result.append(newInterval)
        return result
#{ 
 # Driver Code Starts.
if __name__ == '__main__': 
    t = int(input ())
    for _ in range (t):
        N = int(input())
        intervals = [list(map(int, input().split())) for i in range(N)]
        newEvent = list(map(int, input().split()))
        ob = Solution()
        res = ob.insertInterval(intervals, newEvent)
        print('[', end = '')
        for i in range(len(res)):
            print('[', end = '')
            print(str(res[i][0])+','+str(res[i][1]), end = '')
            print(']', end = '')
            if i < len(res)-1:
                print(',', end='')
        print(']')
        print("~")
# } Driver Code Ends


================================================================================
Date: 2024-12-10
Problem: Non-overlapping Intervals
Filename: 2024-12-10_Non-overlapping_Intervals.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3

# } Driver Code Ends
#User function Template for python3
class Solution:
    def minRemoval(self, intervals):
        intervals.sort(key=lambda x: x[0])
        count, prevEnd = 0, intervals[0][1]
        
        for i in range(1, len(intervals)):
            if intervals[i][0] < prevEnd:
                count += 1
                prevEnd = min(prevEnd, intervals[i][1])
            else:
                prevEnd = intervals[i][1]
        
        return count


#{ 
 # Driver Code Starts.
if __name__ == '__main__': 
    t = int(input ())
    for _ in range (t):
        N = int(input())
        intervals = [list(map(int, input().split())) for i in range(N)]
        ob = Solution()
        res = ob.minRemoval(intervals)
        print(res)
        print("~")
# } Driver Code Ends


================================================================================
Date: 2024-12-11
Problem: Merge Without Extra Space
Filename: 2024-12-11_Merge_Without_Extra_Space.py
================================================================================

class Solution:
    def nextGap(self, gap):
        return 0 if gap <= 1 else (gap // 2) + (gap % 2)

    def mergeArrays(self, a, b):
        n, m = len(a), len(b)
        gap = n + m

        while gap > 0:
            gap = self.nextGap(gap)
            i, j = 0, 0

            while i + gap < n:
                if a[i] > a[i + gap]:
                    a[i], a[i + gap] = a[i + gap], a[i]
                i += 1

            j = max(gap - n, 0)
            i = 0 if gap > n else n - gap
            while i < n and j < m:
                if a[i] > b[j]:
                    a[i], b[j] = b[j], a[i]
                i += 1
                j += 1
            j = 0
            while j + gap < m:
                if b[j] > b[j + gap]:
                    b[j], b[j + gap] = b[j + gap], b[j]
                j += 1
#{ 
 # Driver Code Starts
# Input handling and main function
if __name__ == "__main__":
    # Number of test cases
    t = int(input().strip())

    for _ in range(t):
        # Input first array
        a = list(map(int, input().strip().split()))
        # Input second array
        b = list(map(int, input().strip().split()))

        # Create solution object and merge the arrays
        solution = Solution()
        solution.mergeArrays(a, b)

        # Output both arrays in the same line space-separated
        print(" ".join(map(str, a)))
        print(" ".join(map(str, b)))

# } Driver Code Ends


================================================================================
Date: 2024-12-12
Problem: Number of occurrence
Filename: 2024-12-12_Number_of_occurrence.py
================================================================================

class Solution:
    def countFreq(self, arr, target):
        import bisect
        lower = bisect.bisect_left(arr, target)
        upper = bisect.bisect_right(arr, target)
        return (upper - lower) if lower < len(arr) and arr[lower] == target else 0


#{ 
 # Driver Code Starts
#Initial Template for Python 3
import bisect
#Main
if __name__ == '__main__':
    t = int(input())
    while t:
        t -= 1
        A = [int(x) for x in input().strip().split()]
        nd = [int(x) for x in input().strip().split()]
        D = nd[0]
        ob = Solution()
        ans = ob.countFreq(A, D)
        print(ans)
        print("~")

# } Driver Code Ends


================================================================================
Date: 2024-12-13
Problem: Sorted and Rotated Minimum
Filename: 2024-12-13_Sorted_and_Rotated_Minimum.py
================================================================================

#User function Template for python3
class Solution:
    def findMin(self, arr):
        lo, hi = 0, len(arr) - 1
        while lo < hi:
            if arr[lo] < arr[hi]:
                return arr[lo]
            mid = lo + ((hi - lo) // 2)
            if arr[mid] > arr[hi]:
                lo = mid + 1
            else:
                hi = mid
        return arr[lo]


#{ 
 # Driver Code Starts
def main():
    T = int(input())

    while T > 0:
        a = list(map(
            int,
            input().strip().split()))  # Convert input to list of integers
        print(Solution().findMin(a))  # Call findMin with the array 'a'
        T -= 1
        print("~")


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2024-12-14
Problem: Search in Rotated Sorted Array
Filename: 2024-12-14_Search_in_Rotated_Sorted_Array.py
================================================================================

#User function Template for python3
class Solution:
    def search(self, arr, key):
        n = len(arr)
        for i in range(n):
            if arr[i] == key:
                return i
        return -1

#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    t = int(input())

    for _ in range(t):
        A = list(map(int, input().strip().split()))
        k = int(input())
        ob = Solution()
        print(ob.search(A, k))
        print("~")

# } Driver Code Ends


================================================================================
Date: 2024-12-15
Problem: Peak element
Filename: 2024-12-15_Peak_element.py
================================================================================


class Solution:
    def peakElement(self, arr):
        low, high = 0, len(arr) - 1

        while low < high:
            mid = low + (high - low) // 2
            if arr[mid] > arr[mid + 1]:
                high = mid
            else:
                low = mid + 1
        
        return low  


#{ 
 # Driver Code Starts
if __name__ == "__main__":
    t = int(input())  # Read number of test cases
    for _ in range(t):
        # Read input and split it into a list of integers
        arr = list(map(int, input().split()))
        # Create a Solution object and calculate the result

        index = Solution().peakElement(arr)
        n = len(arr)
        flag = False
        if index < 0 or index >= n:
            flag = False
        else:
            if index == 0 and n == 1:
                flag = True
            elif index == 0 and arr[index] > arr[index + 1]:
                flag = True
            elif index == n - 1 and arr[index] > arr[index - 1]:
                flag = True
            elif index > 0 and index < n - 1 and arr[
                    index - 1] < arr[index] and arr[index] > arr[index + 1]:
                flag = True
            else:
                flag = False

        if flag:
            print("true")
        else:
            print("false")
        print("~")

# } Driver Code Ends


================================================================================
Date: 2024-12-16
Problem: K-th element of two Arrays
Filename: 2024-12-16_K-th_element_of_two_Arrays.py
================================================================================

#User function Template for python3


class Solution:

    def kthElement(self, a, b, k):
        if len(a) > len(b):
            return self.kthElement(b, a, k)

        n, m = len(a), len(b)
        low, high = max(0, k - m), min(k, n)

        while low <= high:
            cut1 = (low + high) // 2
            cut2 = k - cut1

            l1 = a[cut1 - 1] if cut1 > 0 else float('-inf')
            l2 = b[cut2 - 1] if cut2 > 0 else float('-inf')
            r1 = a[cut1] if cut1 < n else float('inf')
            r2 = b[cut2] if cut2 < m else float('inf')

            if l1 <= r2 and l2 <= r1:
                return max(l1, l2)
            elif l1 > r2:
                high = cut1 - 1
            else:
                low = cut1 + 1

        return -1



#{ 
 # Driver Code Starts
#Initial Template for Python 3


def main():

    T = int(input())

    while (T > 0):

        k = int(input())
        a = [int(x) for x in input().strip().split()]
        b = [int(x) for x in input().strip().split()]
        ob = Solution()
        print(ob.kthElement(a, b, k))
        print("~")
        T -= 1


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2024-12-17
Problem: Aggressive Cows
Filename: 2024-12-17_Aggressive_Cows.py
================================================================================

#User function Template for python3


class Solution:
    def aggressiveCows(self, stalls, k):
        stalls.sort()
        low, high = 1, stalls[-1] - stalls[0]

        while low <= high:
            mid = (low + high) // 2
            count, last_placed = 1, stalls[0]
            for i in range(1, len(stalls)):
                if stalls[i] - last_placed >= mid:
                    count += 1
                    last_placed = stalls[i]
            if count >= k:
                low = mid + 1
            else:
                high = mid - 1
        return high



#{ 
 # Driver Code Starts
#Initial Template for Python 3
import bisect
#Main
if __name__ == '__main__':
    t = int(input())
    while t:
        t -= 1
        A = [int(x) for x in input().strip().split()]
        nd = [int(x) for x in input().strip().split()]
        D = nd[0]
        ob = Solution()
        ans = ob.aggressiveCows(A, D)
        print(ans)
        print("~")
# } Driver Code Ends


================================================================================
Date: 2024-12-18
Problem: Allocate Minimum Pages
Filename: 2024-12-18_Allocate_Minimum_Pages.py
================================================================================

class Solution:
    def findPages(self, arr, k):
        n = len(arr)
        if k > n:
            return -1  

        low, high = max(arr), sum(arr)  

        while low < high:
            mid = (low + high) // 2
            students, current_sum = 1, 0

            for pages in arr:
                if current_sum + pages > mid:
                    students += 1
                    current_sum = pages
                else:
                    current_sum += pages

            if students > k:
                low = mid + 1
            else:
                high = mid

        return low
#{ 
 # Driver Code Starts
#Initial Template for Python 3
import bisect
#Main
if __name__ == '__main__':
    t = int(input())
    while t:
        t -= 1
        A = [int(x) for x in input().strip().split()]
        nd = [int(x) for x in input().strip().split()]
        D = nd[0]
        ob = Solution()
        ans = ob.findPages(A, D)
        print(ans)
        print("~")

# } Driver Code Ends


================================================================================
Date: 2024-12-19
Problem: Kth Missing Positive Number in a Sorted Array
Filename: 2024-12-19_Kth_Missing_Positive_Number_in_a_Sorted_Array.py
================================================================================

#User function Template for python3
class Solution:
    def kthMissing(self, arr, k):
        lo, hi = 0, len(arr)
        while lo < hi:
            mid = lo + (hi - lo) // 2
            if arr[mid] - (mid + 1) < k:
                lo = mid + 1
            else:
                hi = mid
        return lo + k




#{ 
 # Driver Code Starts
#Initial Template for Python 3

#Main
if __name__ == '__main__':
    t = int(input())
    while t:
        t -= 1
        A = [int(x) for x in input().strip().split()]
        nd = [int(x) for x in input().strip().split()]
        D = nd[0]
        ob = Solution()
        ans = ob.kthMissing(A, D)
        print(ans)
        print("~")

# } Driver Code Ends


================================================================================
Date: 2024-12-20
Problem: Spirally traversing a matrix
Filename: 2024-12-20_Spirally_traversing_a_matrix.py
================================================================================

class Solution:
    def spirallyTraverse(self, mat):
        result = []
        top, left, bottom, right = 0, 0, len(mat) - 1, len(mat[0]) - 1

        while top <= bottom and left <= right:
            for i in range(left, right + 1):
                result.append(mat[top][i])
            top += 1
            for i in range(top, bottom + 1):
                result.append(mat[i][right])
            right -= 1
            if top <= bottom:
                for i in range(right, left - 1, -1):
                    result.append(mat[bottom][i])
                bottom -= 1
            if left <= right:
                for i in range(bottom, top - 1, -1):
                    result.append(mat[i][left])
                left += 1

        return result

#{ 
 # Driver Code Starts
if __name__ == "__main__":
    import sys
    input = sys.stdin.read
    data = input().split()

    t = int(data[0])
    index = 1
    for _ in range(t):
        r = int(data[index])
        c = int(data[index + 1])
        index += 2
        matrix = []
        for i in range(r):
            row = list(map(int, data[index:index + c]))
            matrix.append(row)
            index += c

        solution = Solution()
        result = solution.spirallyTraverse(matrix)
        print(" ".join(map(str, result)))
        print("~")

# } Driver Code Ends


================================================================================
Date: 2024-12-21
Problem: Rotate by 90 degree
Filename: 2024-12-21_Rotate_by_90_degree.py
================================================================================

#User function Template for python3

class Solution:
    def rotateby90(self, mat): 
        n = len(mat)
        for i in range(n):
            for j in range(i, n):
                mat[i][j], mat[j][i] = mat[j][i], mat[i][j]
        for j in range(n):
            i, k = 0, n - 1
            while i < k:
                mat[i][j], mat[k][j] = mat[k][j], mat[i][j]
                i += 1
                k -= 1
#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    import sys
    input = sys.stdin.read
    data = input().split()

    t = int(data[0])
    index = 1

    for _ in range(t):
        n = int(data[index])
        index += 1
        matrix = []
        for i in range(n):
            row = list(map(int, data[index:index + n]))
            matrix.append(row)
            index += n
        obj = Solution()
        obj.rotateby90(matrix)
        for i in range(n):
            for j in range(n):
                print(matrix[i][j], end=" ")
            print()

        print("~")

# } Driver Code Ends


================================================================================
Date: 2024-12-22
Problem: Search in a Row-Column sorted matrix
Filename: 2024-12-22_Search_in_a_Row-Column_sorted_matrix.py
================================================================================

#User function Template for python3

class Solution:
    def matSearch(self, mat, x):
        r, c = 0, len(mat[0]) - 1
        while r < len(mat) and c >= 0:
            if mat[r][c] == x: return True
            elif mat[r][c] > x: c -= 1
            else: r += 1
        return False


#{ 
 # Driver Code Starts
# Initial Template for Python 3

if __name__ == "__main__":
    import sys
    input = sys.stdin.read
    data = input().split()

    t = int(data[0])
    index = 1
    for _ in range(t):
        r = int(data[index])
        c = int(data[index + 1])
        index += 2
        matrix = []
        for i in range(r):
            row = list(map(int, data[index:index + c]))
            matrix.append(row)
            index += c
        x = int(data[index])
        index += 1
        ob = Solution()
        if ob.matSearch(matrix, x):
            print("true")
        else:
            print("false")
        print("~")
# } Driver Code Ends


================================================================================
Date: 2024-12-23
Problem: Search in a row-wise sorted matrix
Filename: 2024-12-23_Search_in_a_row-wise_sorted_matrix.py
================================================================================


#User function Template for python3

class Solution:
    def searchRowMatrix(self, mat, x):
        for row in mat:
            if x in row: 
                return True
        return False
    	



#{ 
 # Driver Code Starts
# Initial Template for Python 3

if __name__ == "__main__":
    import sys
    input = sys.stdin.read
    data = input().split()

    t = int(data[0])
    index = 1
    for _ in range(t):
        r = int(data[index])
        c = int(data[index + 1])
        index += 2
        matrix = []
        for i in range(r):
            row = list(map(int, data[index:index + c]))
            matrix.append(row)
            index += c
        x = int(data[index])
        index += 1
        ob = Solution()
        if ob.searchRowMatrix(matrix, x):
            print("true")
        else:
            print("false")
        print("~")
# } Driver Code Ends


================================================================================
Date: 2024-12-24
Problem: Search in a sorted Matrix
Filename: 2024-12-24_Search_in_a_sorted_Matrix.py
================================================================================


#User function Template for python3

class Solution:
    def searchMatrix(self, mat, x):
        n, m = len(mat), len(mat[0])
        l, r = 0, n * m - 1
        while l <= r:
            mid = (l + r) // 2
            val = mat[mid // m][mid % m]
            if val == x:
                return True
            if val < x:
                l = mid + 1
            else:
                r = mid - 1
        return False


#{ 
 # Driver Code Starts
# Initial Template for Python 3

if __name__ == "__main__":
    import sys
    input = sys.stdin.read
    data = input().split()

    t = int(data[0])
    index = 1
    for _ in range(t):
        r = int(data[index])
        c = int(data[index + 1])
        index += 2
        matrix = []
        for i in range(r):
            row = list(map(int, data[index:index + c]))
            matrix.append(row)
            index += c
        x = int(data[index])
        index += 1
        ob = Solution()
        if ob.searchMatrix(matrix, x):
            print("true")
        else:
            print("false")
        print("~")
# } Driver Code Ends


================================================================================
Date: 2024-12-25
Problem: Set Matrix Zeroes
Filename: 2024-12-25_Set_Matrix_Zeroes.py
================================================================================

#User function Template for python3
class Solution:
    def setMatrixZeroes(self, mat):
        n, m, col0 = len(mat), len(mat[0]), 1
        for i in range(n):
            if mat[i][0] == 0: col0 = 0
            for j in range(1, m):
                if mat[i][j] == 0:
                    mat[i][0] = mat[0][j] = 0
        for i in range(n - 1, -1, -1):
            for j in range(m - 1, 0, -1):
                if mat[i][0] == 0 or mat[0][j] == 0:
                    mat[i][j] = 0
            if col0 == 0: mat[i][0] = 0

#{ 
 # Driver Code Starts
import sys

# Position this line where user code will be pasted.
if __name__ == "__main__":
    input = sys.stdin.read
    data = input().split()

    idx = 0
    t = int(data[idx])
    idx += 1
    results = []

    for _ in range(t):
        n, m = map(int, data[idx:idx + 2])
        idx += 2
        arr = []
        for i in range(n):
            arr.append(list(map(int, data[idx:idx + m])))
            idx += m

        sol = Solution()
        sol.setMatrixZeroes(arr)

        for row in arr:
            results.append(" ".join(map(str, row)))

        results.append("~")

    sys.stdout.write("\n".join(results) + "\n")

# } Driver Code Ends


================================================================================
Date: 2024-12-26
Problem: Two Sum - Pair with Given Sum
Filename: 2024-12-26_Two_Sum_-_Pair_with_Given_Sum.py
================================================================================

#User function Template for python3
class Solution:
    def twoSum(self, arr, target):
        seen = set()
        for num in arr:
            if target - num in seen:
                return True
            seen.add(num)
        return False


#{ 
 # Driver Code Starts
#Initial Template for Python 3

#Initial Template for Python 3


def main():
    T = int(input())
    while T > 0:
        x = int(input())
        arr = list(map(int, input().strip().split()))
        ob = Solution()
        ans = ob.twoSum(arr, x)
        if ans:
            print("true")
        else:
            print("false")
        T -= 1
        print("~")


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2024-12-27
Problem: Count pairs with given sum
Filename: 2024-12-27_Count_pairs_with_given_sum.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3

import math


# } Driver Code Ends

class Solution:
    def countPairs(self, arr, target):
        freq_map, count = {}, 0
        for num in arr:
            count += freq_map.get(target - num, 0)
            freq_map[num] = freq_map.get(num, 0) + 1
        return count

#{ 
 # Driver Code Starts.

def main():
    T = int(input())
    while (T > 0):

        A = [int(x) for x in input().strip().split()]

        k = int(input())
        ob = Solution()
        print(ob.countPairs(A, k))
        print('~')
        T -= 1


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2024-12-28
Problem: Find All Triplets with Zero Sum
Filename: 2024-12-28_Find_All_Triplets_with_Zero_Sum.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3

import math


# } Driver Code Ends
#User function Template for python3
class Solution:
    def findTriplets(self, arr):
        n = len(arr)
        result = set()
        pair_sum_map = {}
      
        for i in range(n):
            for j in range(i + 1, n):
                pair_sum = arr[i] + arr[j]
                if pair_sum not in pair_sum_map:
                    pair_sum_map[pair_sum] = []
                pair_sum_map[pair_sum].append((i, j))
              
        for i in range(n):
            target = -arr[i]
            if target in pair_sum_map:
                for pair in pair_sum_map[target]:
                    if i not in pair: 
                        triplet = tuple(sorted([i, pair[0], pair[1]]))
                        result.add(triplet)
                      
        return sorted([list(triplet) for triplet in result])


#{ 
 # Driver Code Starts.

def main():
    T = int(input())
    while (T > 0):

        A = [int(x) for x in input().strip().split()]

        ob = Solution()
        res = ob.findTriplets(A)
        res = sorted(res)
        if len(res) == 0:
            print('[]')
        for i in range(len(res)):
            for j in range(len(res[i])):
                print(res[i][j], end=" ")
            print("")
        print('~')
        T -= 1


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2024-12-29
Problem: Intersection of Two arrays with Duplicate Elements
Filename: 2024-12-29_Intersection_of_Two_arrays_with_Duplicate_Elements.py
================================================================================


class Solution:
    def intersectionWithDuplicates(self, a, b):
        set_a = set(a)
        result = []
        
        for num in b:
            if num in set_a:
                result.append(num)
                set_a.remove(num) 
        
        return result


#{ 
 # Driver Code Starts
#Position this line where user code will be pasted.
t = int(input().strip())
while t > 0:
    t -= 1
    # Read first array
    a = list(map(int, input().strip().split()))

    # Read second array
    b = list(map(int, input().strip().split()))

    #input()  # to consume the empty line

    # ADD Solution initialization
    sln = Solution()

    # Assuming numberofElementsInIntersection function is defined in Solution
    res = sln.intersectionWithDuplicates(a, b)

    # Sort the result
    res.sort()

    # Print the result
    if not res:
        print("[]")
    else:
        print(" ".join(map(str, res)))

    print("~")

# } Driver Code Ends


================================================================================
Date: 2024-12-30
Problem: Union of Arrays with Duplicates
Filename: 2024-12-30_Union_of_Arrays_with_Duplicates.py
================================================================================

#User function Template for python3
class Solution:    
    def findUnion(self, a, b):
        return len(set(a).union(b))

#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    t = int(input())
    for _ in range(t):

        a = [int(x) for x in input().strip().split()]
        b = [int(x) for x in input().strip().split()]
        ob = Solution()

        print(ob.findUnion(a, b))
        print("~")

# } Driver Code Ends


================================================================================
Date: 2024-12-31
Problem: Longest Consecutive Subsequence
Filename: 2024-12-31_Longest_Consecutive_Subsequence.py
================================================================================

 #User function Template for python3
 
class Solution:
    def longestConsecutive(self, arr):
        num_set = set(arr)
        longest = 0

        for num in num_set:
            if num - 1 not in num_set:
                current, count = num, 1
                while current + 1 in num_set:
                    current += 1
                    count += 1
                longest = max(longest, count)

        return longest


#{ 
 # Driver Code Starts
#Initial Template for Python 3

import atexit
import io
import sys

_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__
_OUTPUT_BUFFER = io.StringIO()
sys.stdout = _OUTPUT_BUFFER


@atexit.register
def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())


if __name__ == '__main__':
    t = int(input())
    for tt in range(t):
        a = list(map(int, input().strip().split()))
        print(Solution().longestConsecutive(a))
        print("~")
# } Driver Code Ends


================================================================================
Date: 2025-01-01
Problem: Print Anagrams Together
Filename: 2025-01-01_Print_Anagrams_Together.py
================================================================================

#User function Template for python3
from collections import defaultdict

class Solution:
    def anagrams(self, arr):
        umap = defaultdict(list)
        for s in arr:
            sorted_s = ''.join(sorted(s))
            umap[sorted_s].append(s)
        
        return list(umap.values())


#{ 
 # Driver Code Starts
#Initial Template for Python 3
if __name__ == '__main__':
    t = int(input())
    for tcs in range(t):
        words = input().split()

        ob = Solution()
        ans = ob.anagrams(words)

        for grp in sorted(ans):
            for word in grp:
                print(word, end=' ')
            print()

        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-01-02
Problem: Subarrays with sum K
Filename: 2025-01-02_Subarrays_with_sum_K.py
================================================================================

#User function Template for python3
class Solution:
    def countSubarrays(self, arr, k):
        prefix_sum_count = {0: 1}
        sum_, count = 0, 0

        for num in arr:
            sum_ += num
            count += prefix_sum_count.get(sum_ - k, 0)
            prefix_sum_count[sum_] = prefix_sum_count.get(sum_, 0) + 1

        return count
#{ 
 # Driver Code Starts
#Initial Template for Python 3

import atexit
import io
import sys
from collections import deque

#Contributed by : Nagendra Jha

_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__
_OUTPUT_BUFFER = io.StringIO()
sys.stdout = _OUTPUT_BUFFER


@atexit.register
def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())


if __name__ == '__main__':
    test_cases = int(input())
    for cases in range(test_cases):
        k = int(input())
        arr = list(map(int, input().strip().split()))
        ob = Solution()
        res = ob.countSubarrays(arr, k)
        print(res)
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-01-03
Problem: Count Subarrays with given XOR
Filename: 2025-01-03_Count_Subarrays_with_given_XOR.py
================================================================================

class Solution:
    def subarrayXor(self, arr, k):
        res, prefXOR = 0, 0
        count = {0: 1}
        for val in arr:
            prefXOR ^= val
            res += count.get(prefXOR ^ k, 0)
            count[prefXOR] = count.get(prefXOR, 0) + 1
        return res

#{ 
 # Driver Code Starts
if __name__ == "__main__":
    tc = int(input())

    for _ in range(tc):
        arr = list(map(int, input().split()))
        k = int(input())

        obj = Solution()
        print(obj.subarrayXor(arr, k))
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-01-04
Problem: Count all triplets with given sum in sorted array
Filename: 2025-01-04_Count_all_triplets_with_given_sum_in_sorted_array.py
================================================================================


class Solution:
    def countTriplets(self, arr, target):
        n, res = len(arr), 0
        for i in range(n - 2):
            left, right = i + 1, n - 1
            while left < right:
                sum_triplet = arr[i] + arr[left] + arr[right]
                if sum_triplet < target:
                    left += 1
                elif sum_triplet > target:
                    right -= 1
                else:
                    if arr[left] == arr[right]:
                        count = right - left + 1
                        res += count * (count - 1) // 2
                        break
                    cnt1, cnt2 = 1, 1
                    while left + 1 < right and arr[left] == arr[left + 1]:
                        left += 1
                        cnt1 += 1
                    while right - 1 > left and arr[right] == arr[right - 1]:
                        right -= 1
                        cnt2 += 1
                    res += cnt1 * cnt2
                    left += 1
                    right -= 1
        return res

#{ 
 # Driver Code Starts
if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        arr = list(map(int, input().split()))
        target = int(input())
        ob = Solution()
        ans = ob.countTriplets(arr, target)
        print(ans)
        print("~")
# } Driver Code Ends


================================================================================
Date: 2025-01-05
Problem: Count Pairs whose sum is less than target
Filename: 2025-01-05_Count_Pairs_whose_sum_is_less_than_target.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3

import math


# } Driver Code Ends
#User function Template for python3
class Solution:
    def countPairs(self, arr, target):
        arr.sort()
        l, r, ans = 0, len(arr) - 1, 0
        while l < r:
            if arr[l] + arr[r] < target: ans += (r - l); l += 1
            else: r -= 1
        return ans
#{ 
 # Driver Code Starts.

def main():
    T = int(input())
    while (T > 0):

        A = [int(x) for x in input().strip().split()]

        k = int(input())
        ob = Solution()
        print(ob.countPairs(A, k))
        print('~')
        T -= 1


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2025-01-06
Problem: Sum Pair closest to target
Filename: 2025-01-06_Sum_Pair_closest_to_target.py
================================================================================

#User function Template for python3
class Solution:
    def sumClosest(self, arr, target):
        arr.sort()
        l, r, minDiff, res = 0, len(arr) - 1, float('inf'), []
        while l < r:
            s = arr[l] + arr[r]
            if abs(target - s) < minDiff:
                minDiff, res = abs(target - s), [arr[l], arr[r]]
            l += s < target
            r -= s >= target
        return res



#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == "__main__":
    t = int(input().strip())
    while t > 0:
        arr = list(map(int, input().strip().split()))
        target = int(input().strip())
        ob = Solution()
        ans = ob.sumClosest(arr, target)
        if not ans:
            print("[]")
        else:
            print(*ans)
        print("~")
        t -= 1

# } Driver Code Ends


================================================================================
Date: 2025-01-07
Problem: Pair with given sum in a sorted array
Filename: 2025-01-07_Pair_with_given_sum_in_a_sorted_array.py
================================================================================

#User function Template for python3
class Solution:
    def countPairs(self, arr, target):
        freq = {}
        res = 0

        for num in arr:
            res += freq.get(target - num, 0)
            freq[num] = freq.get(num, 0) + 1

        return res

#{ 
 # Driver Code Starts
#Initial Template for Python 3


def main():
    import sys
    input = sys.stdin.read
    data = input().split('\n')

    t = int(data[0].strip())
    index = 1

    for _ in range(t):
        arr = list(map(int, data[index].strip().split()))
        index += 1
        target = int(data[index].strip())
        index += 1

        res = Solution().countPairs(arr, target)
        print(res)
        print("~")


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2025-01-08
Problem: Count the number of possible triangles
Filename: 2025-01-08_Count_the_number_of_possible_triangles.py
================================================================================

#User function Template for python3
class Solution:
    def countTriangles(self, arr):
        arr.sort()
        n, count = len(arr), 0
        for i in range(n - 1, 1, -1):
            l, r = 0, i - 1
            while l < r:
                if arr[l] + arr[r] > arr[i]:
                    count += r - l
                    r -= 1
                else:
                    l += 1
        return count

#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        arr = list(map(int, input().strip().split()))
        ob = Solution()
        print(ob.countTriangles(arr))

        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-01-09
Problem: Indexes of Subarray Sum
Filename: 2025-01-09_Indexes_of_Subarray_Sum.py
================================================================================

#User function Template for python3

class Solution:
    def subarraySum(self, arr, target):
        s, curr = 0, 0
        for e in range(len(arr)):
            curr += arr[e]
            while curr > target and s <= e:
                curr -= arr[s]
                s += 1
            if curr == target:
                return [s + 1, e + 1]
        return [-1]
#{ 
 # Driver Code Starts
# Initial Template for Python 3

if __name__ == '__main__':
    tc = int(input().strip())
    while tc > 0:
        arr = list(map(int, input().strip().split()))
        d = int(input().strip())
        ob = Solution()
        result = ob.subarraySum(arr, d)
        print(" ".join(map(str, result)))
        tc -= 1
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-01-10
Problem: Count distinct elements in every window
Filename: 2025-01-10_Count_distinct_elements_in_every_window.py
================================================================================


class Solution:
    def countDistinct(self, arr, k):
        freq = {}
        res = []
        for i in range(len(arr)):
            freq[arr[i]] = freq.get(arr[i], 0) + 1
            if i >= k - 1:
                res.append(len(freq))
                freq[arr[i - k + 1]] -= 1
                if freq[arr[i - k + 1]] == 0:
                    del freq[arr[i - k + 1]]
        return res

#{ 
 # Driver Code Starts
import sys
from collections import defaultdict
if __name__ == '__main__':
    input = sys.stdin.read
    data = input().splitlines()
    t = int(data[0])
    index = 1
    while t > 0:
        arr = list(map(int, data[index].strip().split()))
        index += 1
        k = int(data[index])
        index += 1

        ob = Solution()
        res = ob.countDistinct(arr, k)

        for element in res:
            print(element, end=" ")
        print()
        print("~")

        t -= 1

# } Driver Code Ends


================================================================================
Date: 2025-01-11
Problem: Longest substring with distinct characters
Filename: 2025-01-11_Longest_substring_with_distinct_characters.py
================================================================================

#User function Template for python3
class Solution:
    def longestUniqueSubstr(self, s):
        last_seen = [-1] * 128  
        max_length = 0
        start = 0

        for end, char in enumerate(s):
            start = max(start, last_seen[ord(char)] + 1)
            last_seen[ord(char)] = end
            max_length = max(max_length, end - start + 1)

        return max_length

#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':

    t = int(input())

    for _ in range(t):
        s = input()

        solObj = Solution()

        ans = solObj.longestUniqueSubstr(s)

        print(ans)

        print("~")
# } Driver Code Ends


================================================================================
Date: 2025-01-12
Problem: Trapping Rain Water
Filename: 2025-01-12_Trapping_Rain_Water.py
================================================================================


class Solution:
    def maxWater(self, arr):
        l, r, res, lMax, rMax = 0, len(arr) - 1, 0, 0, 0
        while l < r:
            if arr[l] < arr[r]: res += max(0, lMax - arr[l]); lMax = max(lMax, arr[l]); l += 1
            else: res += max(0, rMax - arr[r]); rMax = max(rMax, arr[r]); r -= 1
        return res
#{ 
 # Driver Code Starts
#Initial template for Python 3

import math


def main():
    t = int(input())
    while (t > 0):

        arr = [int(x) for x in input().strip().split()]
        obj = Solution()
        print(obj.maxWater(arr))

        t -= 1
        print("~")


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2025-01-13
Problem: Container With Most Water
Filename: 2025-01-13_Container_With_Most_Water.py
================================================================================


class Solution:
    def maxWater(self, arr):
        l, r, res = 0, len(arr) - 1, 0
        while l < r:
            res = max(res, (r - l) * (arr[l] if arr[l] < arr[r] else arr[r]))
            l, r = (l + 1, r) if arr[l] < arr[r] else (l, r - 1)
        return res


2)
class Solution:
    def maxWater(self, arr):
        l, r, res = 0, len(arr) - 1, 0
        while l < r:
            res = max(res, (r - l) * min(arr[l], arr[r]))
            if arr[l] < arr[r]:
                l += 1
            else:
                r -= 1
        return res
 # Driver Code Starts
#Initial template for Python 3

import math


def main():
    t = int(input())
    while (t > 0):

        arr = [int(x) for x in input().strip().split()]
        obj = Solution()
        print(obj.maxWater(arr))

        t -= 1
        print("~")


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2025-01-14
Problem: Equilibrium Point
Filename: 2025-01-14_Equilibrium_Point.py
================================================================================

# User function Template for python3
class Solution:
    def findEquilibrium(self, arr):
        total, prefix = sum(arr), 0
        for i, val in enumerate(arr):
            total -= val
            if prefix == total:
                return i
            prefix += val
        return -1




#{ 
 # Driver Code Starts
#Initial Template for Python 3
import math


def main():
    T = int(input())
    while (T > 0):

        arr = [int(x) for x in input().strip().split()]

        ob = Solution()

        print(ob.findEquilibrium(arr))
        print("~")
        T -= 1


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2025-01-15
Problem: Longest Subarray with Sum K
Filename: 2025-01-15_Longest_Subarray_with_Sum_K.py
================================================================================

# User function Template for python3
class Solution:
    def longestSubarray(self, arr, k):
        mp, sum, res = {}, 0, 0
        for i, num in enumerate(arr):
            sum += num
            if sum == k:
                res = i + 1
            if sum - k in mp:
                res = max(res, i - mp[sum - k])
            mp.setdefault(sum, i)
        return res
#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    tc = int(input().strip())
    while tc > 0:
        arr = list(map(int, input().strip().split()))
        k = int(input().strip())
        ob = Solution()
        print(ob.longestSubarray(arr, k))
        tc -= 1
        print("~")
# } Driver Code Ends


================================================================================
Date: 2025-01-16
Problem: Largest subarray of 0s and 1s
Filename: 2025-01-16_Largest_subarray_of_0s_and_1s.py
================================================================================

class Solution:
    def maxLen(self, arr):
        hmap = {}
        sum, max_len = 0, 0
        for i in range(len(arr)):
            sum += -1 if arr[i] == 0 else 1
            if sum == 0:
                max_len = i + 1
            elif sum in hmap:
                max_len = max(max_len, i - hmap[sum])
            else:
                hmap[sum] = i
        return max_len


#{ 
 # Driver Code Starts
#Initial Template for Python 3

t = int(input())
for _ in range(0, t):
    a = list(map(int, input().split()))
    s = Solution().maxLen(a)
    print(s)

# } Driver Code Ends


================================================================================
Date: 2025-01-17
Problem: Product array puzzle
Filename: 2025-01-17_Product_array_puzzle.py
================================================================================

#User function Template for python3
class Solution:
    def productExceptSelf(self, arr):
        product, zero_count = 1, arr.count(0)
        if zero_count > 1:
            return [0] * len(arr)
        for x in arr:
            if x != 0:
                product *= x
        return [product if x == 0 else 0 if zero_count else product // x for x in arr]

#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    t = int(input())

    for _ in range(t):

        arr = [int(x) for x in input().split()]

        ans = Solution().productExceptSelf(arr)
        print(*ans)
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-01-18
Problem: Reverse a linked list
Filename: 2025-01-18_Reverse_a_linked_list.py
================================================================================

#function Template for python3

"""
# Node Class

class Node:
    def __init__(self, val):
        self.data = val
        self.next = None

"""

class Solution:
    def reverseList(self, head):
        prev = None
        while head:
            next = head.next
            head.next = prev
            prev = head
            head = next
        return prev
#{ 
 # Driver Code Starts
# Node Class
class Node:

    def __init__(self, val):
        self.data = val
        self.next = None


# Linked List Class
class Linked_List:

    def __init__(self):
        self.head = None
        self.tail = None

    def insert(self, val):
        if self.head is None:
            self.head = Node(val)
            self.tail = self.head
        else:
            self.tail.next = Node(val)
            self.tail = self.tail.next


def printList(head):
    tmp = head
    while tmp:
        print(tmp.data, end=' ')
        tmp = tmp.next
    print()


if __name__ == '__main__':
    for i in range(int(input())):

        arr = [int(x) for x in input().split()]

        lis = Linked_List()
        for i in arr:
            lis.insert(i)

        newHead = Solution().reverseList(lis.head)
        printList(newHead)
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-01-19
Problem: Rotate a Linked List
Filename: 2025-01-19_Rotate_a_Linked_List.py
================================================================================

# Your task is to complete this function

'''

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

'''

class Solution:
    def rotate(self, head, k):
        if k == 0 or head is None:
            return head
        curr = head
        length = 1
        while curr.next is not None:
            curr = curr.next
            length += 1
        k %= length
        if k == 0:
            curr.next = None
            return head
        curr.next = head
        curr = head
        for _ in range(1, k):
            curr = curr.next
        newHead = curr.next
        curr.next = None
        return newHead


#{ 
 # Driver Code Starts
#Initial Template for Python 3


# Define the Node class for the linked list
class Node:

    def __init__(self, x):
        self.data = x
        self.next = None


# Function to print the linked list
def printList(node):
    while node:
        print(node.data, end=" ")
        node = node.next
    print()


#Position this line where user code will be pasted.

# Main function
if __name__ == "__main__":
    import sys
    input = sys.stdin.read
    data = input().splitlines()

    t = int(data[0].strip())
    idx = 1

    while t > 0:
        arr = list(map(int, data[idx].strip().split()))

        head = None
        if arr:
            head = Node(arr[0])
            tail = head
            for num in arr[1:]:
                tail.next = Node(num)
                tail = tail.next

        k = int(data[idx + 1].strip())
        idx += 2
        head = Solution().rotate(head, k)
        printList(head)
        print("~")
        t -= 1

# } Driver Code Ends


================================================================================
Date: 2025-01-20
Problem: Merge two sorted linked lists
Filename: 2025-01-20_Merge_two_sorted_linked_lists.py
================================================================================

#User function Template for python3
'''
# Node Class
class Node:
    def __init__(self, data):   # data -> value stored in node
        self.data = data
        self.next = None

'''
class Solution:
    def sortedMerge(self, head1, head2):
        dummy = Node(0)
        tail = dummy
        while head1 and head2:
            if head1.data <= head2.data:
                tail.next = head1
                head1 = head1.next
            else:
                tail.next = head2
                head2 = head2.next
            tail = tail.next
        tail.next = head1 or head2
        return dummy.next

#{ 
 # Driver Code Starts
class Node:

    def __init__(self, data):
        self.data = data
        self.next = None


def print_list(head):
    temp = head
    while temp:
        print(temp.data, end=' ')
        temp = temp.next
    print()
    print("~")


def insert_sorted(head, data):
    new_node = Node(data)
    if not head or head.data >= data:
        new_node.next = head
        return new_node

    current = head
    while current.next and current.next.data < data:
        current = current.next

    new_node.next = current.next
    current.next = new_node

    return head


if __name__ == "__main__":
    T = int(input())
    for _ in range(T):
        input1 = list(map(int, input().split()))
        input2 = list(map(int, input().split()))

        head1 = None
        for item in input1:
            head1 = insert_sorted(head1, item)

        head2 = None
        for item in input2:
            head2 = insert_sorted(head2, item)

        obj = Solution()
        merged_head = obj.sortedMerge(head1, head2)
        print_list(merged_head)

# } Driver Code Ends


================================================================================
Date: 2025-01-21
Problem: Linked List Group Reverse
Filename: 2025-01-21_Linked_List_Group_Reverse.py
================================================================================

"""Node is defined as

class Node:
    def __init__(self, data):
		self.data = data
		self.next = None
"""

class Solution:
    def reverseKGroup(self, head, k):
        if not head or k <= 1:
            return head
        current = head
        new_head = None
        tail = None
        while current:
            group_prev = None
            group_curr = current
            count = 0
            while current and count < k:
                next_node = current.next
                current.next = group_prev
                group_prev = current
                current = next_node
                count += 1
            if not new_head:
                new_head = group_prev
            if tail:
                tail.next = group_prev
            tail = group_curr
        return new_head

#{ 
 # Driver Code Starts
class Node:

    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:

    def __init__(self):
        self.head = None

    def push(self, new_data):
        new_node = Node(new_data)
        new_node.next = self.head
        self.head = new_node

    def printList(self):
        temp = self.head
        while temp:
            print(temp.data, end=" ")
            temp = temp.next
        print()


if __name__ == '__main__':
    t = int(input())  # Number of test cases
    while t > 0:
        llist = LinkedList()

        # Read list values and push them to the LinkedList
        values = list(map(int, input().split()))
        for i in reversed(values):
            llist.push(i)

        k = int(input())  # Size of the group for reversal
        ob = Solution()
        new_head = ob.reverseKGroup(llist.head, k)
        llist.head = new_head
        llist.printList()  # Print the modified linked list
        t -= 1

        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-01-22
Problem: Add Number Linked Lists
Filename: 2025-01-22_Add_Number_Linked_Lists.py
================================================================================

#User function Template for python3

''' Node for linked list:

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

'''
class Solution:
    def reverse(self, head):
        prev, curr = None, head
        while curr:
            next_node = curr.next
            curr.next = prev
            prev = curr
            curr = next_node
        return prev

    def addTwoLists(self, l1, l2):
        l1 = self.reverse(l1)
        l2 = self.reverse(l2)
        dummy = Node(0)
        tail = dummy
        carry = 0

        while l1 or l2 or carry:
            summ = carry
            if l1:
                summ += l1.data
                l1 = l1.next
            if l2:
                summ += l2.data
                l2 = l2.next
            carry = summ // 10
            tail.next = Node(summ % 10)
            tail = tail.next

        res = self.reverse(dummy.next)
        while res and res.data == 0 and res.next:
            res = res.next
        return res

#{ 
 # Driver Code Starts
#Initial Template for Python 3


# Node Class
class Node:

    def __init__(self, data):
        self.data = data
        self.next = None


# Linked List Class
class LinkedList:

    def __init__(self):
        self.head = None
        self.tail = None

    # creates a new node with given value and appends it at the end of the linked list
    def insert(self, val):
        if self.head is None:
            self.head = Node(val)
            self.tail = self.head
        else:
            self.tail.next = Node(val)
            self.tail = self.tail.next


# prints the elements of linked list starting with head
def printList(n):
    while n:
        print(n.data, end=' ')
        n = n.next
    print()


if __name__ == '__main__':
    for _ in range(int(input())):

        arr1 = (int(x) for x in input().split())
        num1 = LinkedList()
        for i in arr1:
            num1.insert(i)

        arr2 = (int(x) for x in input().split())
        num2 = LinkedList()
        for i in arr2:
            num2.insert(i)

        res = Solution().addTwoLists(num1.head, num2.head)
        printList(res)
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-01-23
Problem: Clone List with Next and Random
Filename: 2025-01-23_Clone_List_with_Next_and_Random.py
================================================================================

# Link list Node
# class Node:

#     def __init__(self, x):
#         self.data = x
#         self.next = None
#         self.random = None
        
class Solution:
    def cloneLinkedList(self, head):
        if not head:
            return None

        d = {}
        ch = Node(head.data)
        chh = ch
        d[head] = ch

        h = head.next
        while h:
            nn = Node(h.data)
            chh.next = nn
            d[h] = nn
            h = h.next
            chh = nn

        h = head
        chh = ch
        while h:
            if h.random:
                chh.random = d[h.random]
            h = h.next
            chh = chh.next

        return ch

#{ 
 # Driver Code Starts
class Node:

    def __init__(self, x):
        self.data = x
        self.next = None
        self.random = None


def print_linked_list(root):
    link = {}
    temp = root
    index = 0
    while temp:
        link[temp] = index
        temp = temp.next
        index += 1

    temp = root
    result = []
    while temp:
        random_index = "NULL" if not temp.random else link.get(temp.random) + 1
        result.append(f"[{temp.data}, {random_index}]")
        temp = temp.next

    print(f"[{', '.join(result)}]")


def build_linked_list(v, org_address):
    address = [None] * len(v)
    head = Node(v[0][0])
    address[0] = head
    org_address[head] = 0
    temp = head

    for i in range(1, len(v)):
        new_node = Node(v[i][0])
        org_address[new_node] = i
        address[i] = new_node
        temp.next = new_node
        temp = temp.next

    temp = head
    for i in range(len(v)):
        random_index = v[i][1]
        if random_index != -1:
            temp.random = address[random_index - 1]
        temp = temp.next

    return head


def validate_input(org_address, head, v):
    address = [None] * len(v)
    temp = head
    for i in range(len(v)):
        if temp not in org_address or org_address[temp] != i:
            return False
        address[i] = temp
        temp = temp.next

    if temp is not None:
        return False

    temp = head
    for i in range(len(v)):
        value = v[i][0]
        random_index = v[i][1]

        if random_index == -1:
            if temp.random is not None:
                return False
        else:
            temp_node = address[random_index - 1]
            if temp.random != temp_node:
                return False
        temp = temp.next
    return True


def validation(res, org_address):
    temp = res
    while temp:
        if temp in org_address:
            return False
        if temp.random in org_address:
            return False
        temp = temp.next
    return True


def main():
    T = int(input())
    for _ in range(T):
        n = int(input())
        v = []
        for _ in range(n):
            a, b = input().split()
            a = int(a)
            b = -1 if b in ["NULL", "N", "null", "n", "Null"] else int(b)
            v.append((a, b))

        org_address = {}
        head = build_linked_list(v, org_address)

        solution = Solution()
        res = solution.cloneLinkedList(head)

        # Validate if input is modified
        if validate_input(org_address, head, v):
            if validation(res, org_address):
                print_linked_list(res)
            else:
                print("Pointing to the original list")
        else:
            print("Input list modified")
        print("~")


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2025-01-24
Problem: Detect Loop in linked list
Filename: 2025-01-24_Detect_Loop_in_linked_list.py
================================================================================

#User function Template for python3
'''
		# Node Class
		class Node:
		    def __init__(self, data):   # data -> value stored in node
		        self.data = data
		        self.next = None
	
'''
# Return boolean value True or False

class Solution:
    def detectLoop(self, head):
        slow, fast = head, head
        while fast and fast.next:
            slow, fast = slow.next, fast.next.next
            if slow == fast:
                return True
        return False
        
#{ 
 # Driver Code Starts
#Initial Template for Python 3


# Node Class
class Node:

    def __init__(self, data):  # data -> value stored in node
        self.data = data
        self.next = None


# Linked List Class
class LinkedList:

    def __init__(self):
        self.head = None
        self.tail = None

    # creates a new node with given value and appends it at the end of the linked list
    def insert(self, val):
        if self.head is None:
            self.head = Node(val)
            self.tail = self.head
        else:
            self.tail.next = Node(val)
            self.tail = self.tail.next

    #connects last node to node at position pos from begining.
    def loopHere(self, pos):
        if pos == 0:
            return

        walk = self.head
        for i in range(1, pos):
            walk = walk.next

        self.tail.next = walk


if __name__ == '__main__':
    for _ in range(int(input())):

        LL = LinkedList()
        for i in input().split():
            LL.insert(int(i))

        LL.loopHere(int(input()))
        res = Solution().detectLoop(LL.head)
        if (res):
            print("true")
        else:
            print("false")
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-01-25
Problem: Find the first node of loop in linked list
Filename: 2025-01-25_Find_the_first_node_of_loop_in_linked_list.py
================================================================================

#User function Template for python3

""" Node Class
    class Node:
        def __init__(self, data):   # data -> value stored in node
            self.data = data
            self.next = None
"""
class Solution:
    def findFirstNode(self, head):
        slow, fast = head, head
        while fast and fast.next:
            slow, fast = slow.next, fast.next.next
            if slow == fast:
                slow = head
                while slow != fast:
                    slow, fast = slow.next, fast.next
                return slow
        return None
#{ 
 # Driver Code Starts
class Node:

    def __init__(self, data):
        self.data = data
        self.next = None


def print_list(node):
    while node:
        print(node.data, end=' ')
        node = node.next
    print()


def loop_here(head, tail, position):
    if position == 0:
        return

    walk = head
    for _ in range(1, position):
        walk = walk.next
    tail.next = walk


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        arr = list(map(int, input().split()))
        k = int(input())
        head = Node(arr[0])
        tail = head
        for value in arr[1:]:
            tail.next = Node(value)
            tail = tail.next
        loop_here(head, tail, k)

        ob = Solution()
        ans = ob.findFirstNode(head)
        if (ans == None):
            print(-1)
        else:
            print(ans.data)
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-01-26
Problem: Remove loop in Linked List
Filename: 2025-01-26_Remove_loop_in_Linked_List.py
================================================================================

'''
# node class:

class Node:
    def __init__(self,val):
        self.next=None
        self.data=val

'''

class Solution:
    def removeLoop(self, head):
        slow, fast = head, head
        while fast and fast.next and (slow := slow.next) != (fast := fast.next.next): pass
        if not fast or not fast.next: return
        slow = head
        while slow != fast: slow, fast = slow.next, fast.next
        while fast.next != slow: fast = fast.next
        fast.next = None

class Solution:
    def removeLoop(self, head):
        visited = set()
        prev = None

        while head:
            # If the node is already visited, break the loop
            if head in visited:
                prev.next = None
                break
            visited.add(head)  # Mark the current node as visited
            prev = head
            head = head.next
#{ 
 # Driver Code Starts
# driver code:


class Node:

    def __init__(self, val):
        self.next = None
        self.data = val


class linkedList:

    def __init__(self):
        self.head = None
        self.tail = None

    def add(self, num):
        if self.head is None:
            self.head = Node(num)
            self.tail = self.head
        else:
            self.tail.next = Node(num)
            self.tail = self.tail.next

    def isLoop(self):
        if self.head is None:
            return False

        fast = self.head.next
        slow = self.head

        while slow != fast:
            if fast is None or fast.next is None:
                return False
            fast = fast.next.next
            slow = slow.next

        return True

    def loopHere(self, position):
        if position == 0:
            return

        walk = self.head
        for _ in range(1, position):
            walk = walk.next
        self.tail.next = walk

    def length(self):
        walk = self.head
        ret = 0
        while walk:
            ret += 1
            walk = walk.next
        return ret


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):

        arr = tuple(int(x) for x in input().split())
        pos = int(input())
        n = len(arr)
        ll = linkedList()
        for i in arr:
            ll.add(i)
        ll.loopHere(pos)

        Solution().removeLoop(ll.head)

        if ll.isLoop() or ll.length() != n:
            print("false")
            continue
        else:
            print("true")
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-01-27
Problem: LRU Cache
Filename: 2025-01-27_LRU_Cache.py
================================================================================

#User function Template for python3

# design the class in the most optimal way

from collections import OrderedDict

class LRUCache:
    def __init__(self, cap):
        self.cap = cap
        self.cache = OrderedDict()

    def get(self, key):
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key, value):
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
        if len(self.cache) > self.cap:
            self.cache.popitem(last=False)




#{ 
 # Driver Code Starts
#Initial Template for Python 3


def inputLine():
    return input().strip().split()


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        capacity = int(input())
        cache = LRUCache(capacity)

        queries = int(input())
        for __ in range(queries):
            vec = inputLine()
            if vec[0] == "PUT":
                key = int(vec[1])
                value = int(vec[2])
                cache.put(key, value)
            else:
                key = int(vec[1])
                print(cache.get(key), end=" ")
        print()
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-01-28
Problem: Permutations of a String
Filename: 2025-01-28_Permutations_of_a_String.py
================================================================================

#User function Template for python3

from itertools import permutations

class Solution:
    def findPermutation(self, s):
        return sorted(set(["".join(p) for p in permutations(s)]))  # Unique permutations      


2)
class Solution:
    def findPermutation(self, s):
        s, res = ''.join(sorted(s)), []
        while s:
            res.append(s)
            s = self.next(s)
        return res

    def next(self, s):
        s = list(s)
        i = len(s) - 2
        while i >= 0 and s[i] >= s[i + 1]: i -= 1
        if i < 0: return None
        j = len(s) - 1
        while s[j] <= s[i]: j -= 1
        s[i], s[j] = s[j], s[i]
        return ''.join(s[:i + 1] + s[i + 1:][::-1])

#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    t = int(input())
    for i in range(t):
        S = input()
        ob = Solution()
        ans = ob.findPermutation(S)
        ans.sort()
        for i in ans:
            print(i, end=" ")
        print()
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-01-29
Problem: Implement Pow
Filename: 2025-01-29_Implement_Pow.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3


# } Driver Code Ends
#User function Template for python3
class Solution:
    def power(self, b: float, e: int) -> float:
        result = 1.0
        exp = abs(e)
        while exp > 0:
            if exp % 2 == 1:
                result *= b
            b *= b
            exp //= 2
        return result if e >= 0 else 1.0 / result
#{ 
 # Driver Code Starts.

if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        b = float(input())
        e = int(input())
        ob = Solution()
        result = ob.power(b, e)
        print(f"{result:.5f}")
        print("~")
# } Driver Code Ends


================================================================================
Date: 2025-01-30
Problem: N-Queen Problem
Filename: 2025-01-30_N-Queen_Problem.py
================================================================================

#User function Template for python3
class Solution:
    def nQueen(self, n):
        if n < 4 and n != 1:
            return []
        res = []
        row = [0] * n

        def solve(c, cols, d1, d2):
            if c == n:
                res.append([r + 1 for r in row])
                return
            for r in range(n):
                pos = 1 << r
                if not (cols & pos or d1 & (pos << c) or d2 & (pos << (n - 1 - c))):
                    row[c] = r
                    solve(c + 1, cols | pos, d1 | (pos << c), d2 | (pos << (n - 1 - c)))

        solve(0, 0, 0, 0)
        return res

#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        n = int(input())

        ob = Solution()
        ans = ob.nQueen(n)
        if (len(ans) == 0):
            print("-1")
        else:
            ans.sort()
            for i in range(len(ans)):
                print("[", end="")
                for j in range(len(ans[i])):
                    print(ans[i][j], end=" ")
                print("]", end=" ")
            print()

        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-01-31
Problem: Solve the Sudoku
Filename: 2025-01-31_Solve_the_Sudoku.py
================================================================================

#User function Template for python3
class Solution:
    def solveSudoku(self, b):
        r, c, box = [0] * 9, [0] * 9, [0] * 9
        for i in range(9):
            for j in range(9):
                if b[i][j]:
                    m = 1 << b[i][j]
                    r[i] |= m; c[j] |= m; box[i // 3 * 3 + j // 3] |= m
        self.solve(b, r, c, box, 0, 0)
    
    def solve(self, b, r, c, box, i, j):
        if i == 9: return True
        if j == 9: return self.solve(b, r, c, box, i + 1, 0)
        if b[i][j]: return self.solve(b, r, c, box, i, j + 1)
        for num in range(1, 10):
            m = 1 << num
            idx = i // 3 * 3 + j // 3
            if r[i] & m or c[j] & m or box[idx] & m: continue
            b[i][j] = num; r[i] |= m; c[j] |= m; box[idx] |= m
            if self.solve(b, r, c, box, i, j + 1): return True
            b[i][j] = 0; r[i] &= ~m; c[j] &= ~m; box[idx] &= ~m
        return False
        
#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    import sys
    input = sys.stdin.read
    data = input().split()

    t = int(data[0])
    index = 1

    for _ in range(t):
        matrix = []
        n = 9
        for i in range(n):
            row = list(map(int, data[index:index + n]))
            matrix.append(row)
            index += n
        obj = Solution()
        obj.solveSudoku(matrix)
        for i in range(n):
            for j in range(n):
                print(matrix[i][j], end=" ")
            print()
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-02-01
Problem: Word Search
Filename: 2025-02-01_Word_Search.py
================================================================================

class Solution:
    def isWordExist(self, b, w):
        def dfs(i, j, k):
            if k == len(w): return True
            if i < 0 or j < 0 or i >= len(b) or j >= len(b[0]) or b[i][j] != w[k]: return False
            t, b[i][j] = b[i][j], '#'
            f = any(dfs(i + dx, j + dy, k + 1) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)])
            b[i][j] = t
            return f

        return any(dfs(i, j, 0) for i in range(len(b)) for j in range(len(b[0])) if b[i][j] == w[0])

#{ 
 # Driver Code Starts
if __name__ == '__main__':
    T = int(input())
    for tt in range(T):
        n = int(input())
        m = int(input())
        mat = []
        for i in range(n):
            a = list(input().strip().split())
            b = []
            for j in range(m):
                b.append(a[j][0])
            mat.append(b)
        word = input().strip()
        obj = Solution()
        ans = obj.isWordExist(mat, word)
        if ans:
            print("true")
        else:
            print("false")
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-02-02
Problem: Level order traversal
Filename: 2025-02-02_Level_order_traversal.py
================================================================================

"""
class Node:
    def __init__(self, value):
        self.left = None
        self.data = value
        self.right = None
"""

class Solution:
    def levelOrder(self, root):
        if not root: return []
        res, q = [], [root]
        while q:
            res.append([n.data for n in q])
            q = [c for n in q for c in (n.left, n.right) if c]
        return res


#{ 
 # Driver Code Starts
#Initial Template for Python 3

#Contributed by Sudarshan Sharma
from collections import deque


# Tree Node
class Node:

    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None


# Function to Build Tree
def buildTree(s):
    #Corner Case
    if (len(s) == 0 or s[0] == "N"):
        return None

    # Creating list of strings from input
    # string after spliting by space
    ip = list(map(str, s.split()))

    # Create the root of the tree
    root = Node(int(ip[0]))
    size = 0
    q = deque()

    # Push the root to the queue
    q.append(root)
    size = size + 1

    # Starting from the second element
    i = 1
    while (size > 0 and i < len(ip)):
        # Get and remove the front of the queue
        currNode = q[0]
        q.popleft()
        size = size - 1

        # Get the current node's value from the string
        currVal = ip[i]

        # If the left child is not null
        if (currVal != "N"):

            # Create the left child for the current node
            currNode.left = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.left)
            size = size + 1
        # For the right child
        i = i + 1
        if (i >= len(ip)):
            break
        currVal = ip[i]

        # If the right child is not null
        if (currVal != "N"):

            # Create the right child for the current node
            currNode.right = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.right)
            size = size + 1
        i = i + 1
    return root


if __name__ == "__main__":
    t = int(input())
    for _ in range(0, t):
        s = input()
        root = buildTree(s)
        res = Solution().levelOrder(root)
        for level in res:
            print(' '.join(map(str, level)), end=" ")
        print()
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-02-03
Problem: Height of Binary Tree
Filename: 2025-02-03_Height_of_Binary_Tree.py
================================================================================

#User function Template for python3

'''
# Node Class:
class Node:
    def _init_(self,val):
        self.data = val
        self.left = None
        self.right = None
'''
# class Solution:
#     def height(self, root):
#         return -1 if not root else 1+max(self.height(root.left),self.height(root.right))

class Solution:
    def height(self, root):
        return -1 if not root else 1 + max(self.height(root.left), self.height(root.right))


#{ 
 # Driver Code Starts
#Initial Template for Python 3

from collections import deque


# Tree Node
class Node:

    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None


# Function to Build Tree
def buildTree(s):
    #Corner Case
    if (len(s) == 0 or s[0] == "N"):
        return None

    # Creating list of strings from input
    # string after spliting by space
    ip = list(map(str, s.split()))

    # Create the root of the tree
    root = Node(int(ip[0]))
    size = 0
    q = deque()

    # Push the root to the queue
    q.append(root)
    size = size + 1

    # Starting from the second element
    i = 1
    while (size > 0 and i < len(ip)):
        # Get and remove the front of the queue
        currNode = q[0]
        q.popleft()
        size = size - 1

        # Get the current node's value from the string
        currVal = ip[i]

        # If the left child is not null
        if (currVal != "N"):

            # Create the left child for the current node
            currNode.left = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.left)
            size = size + 1
        # For the right child
        i = i + 1
        if (i >= len(ip)):
            break
        currVal = ip[i]

        # If the right child is not null
        if (currVal != "N"):

            # Create the right child for the current node
            currNode.right = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.right)
            size = size + 1
        i = i + 1
    return root


if __name__ == "__main__":
    t = int(input())
    for _ in range(0, t):
        s = input()
        root = buildTree(s)
        ob = Solution()
        print(ob.height(root))
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-02-04
Problem: Diameter of a Binary Tree
Filename: 2025-02-04_Diameter_of_a_Binary_Tree.py
================================================================================

'''
# Tree Node
class Node:

    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None
'''

class Solution:
    def f(self, r):
        if not r: 
            return (0, 0)
        a, b = self.f(r.left), self.f(r.right)
        h = 1 + max(a[0], b[0])
        d = max(a[1], b[1], a[0] + b[0])
        return (h, d)
    
    def diameter(self, root):
        return self.f(root)[1]
        


#{ 
 # Driver Code Starts
#Initial Template for Python 3

#Contributed by Sudarshan Sharma
from collections import deque
import sys

sys.setrecursionlimit(500000)


# Tree Node
class Node:

    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None


# Function to Build Tree
def buildTree(s):
    #Corner Case
    if (len(s) == 0 or s[0] == "N"):
        return None

    # Creating list of strings from input
    # string after spliting by space
    ip = list(map(str, s.split()))

    # Create the root of the tree
    root = Node(int(ip[0]))
    size = 0
    q = deque()

    # Push the root to the queue
    q.append(root)
    size = size + 1

    # Starting from the second element
    i = 1
    while (size > 0 and i < len(ip)):
        # Get and remove the front of the queue
        currNode = q[0]
        q.popleft()
        size = size - 1

        # Get the current node's value from the string
        currVal = ip[i]

        # If the left child is not null
        if (currVal != "N"):

            # Create the left child for the current node
            currNode.left = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.left)
            size = size + 1
        # For the right child
        i = i + 1
        if (i >= len(ip)):
            break
        currVal = ip[i]

        # If the right child is not null
        if (currVal != "N"):

            # Create the right child for the current node
            currNode.right = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.right)
            size = size + 1
        i = i + 1
    return root


if __name__ == "__main__":
    t = int(input())
    for _ in range(0, t):
        s = input()
        root = buildTree(s)
        k = Solution().diameter(root)
        print(k)

        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-02-05
Problem: Mirror Tree
Filename: 2025-02-05_Mirror_Tree.py
================================================================================

#User function Template for python3

'''
class Node:
    def _init_(self, val):
        self.right = None
        self.data = val
        self.left = None
'''
# your task is to complete this function

# class Solution:
#     def mirror(self, root):
#         if not root: return
#         self.mirror(root.left)
#         self.mirror(root.right)
#         root.left, root.right = root.right, root.left

class Solution:
    def mirror(self, root):
        if not root:
            return
        self.mirror(root.left)
        self.mirror(root.right)
        root.left, root.right = root.right, root.left
#{ 
 # Driver Code Starts
#Initial Template for Python 3

#Contributed by Sudarshan Sharma
from collections import deque


# Tree Node
class Node:

    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None


from collections import deque


class Node:

    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None


def levelOrder(root):
    if root is None:
        return "N\n"

    result = []
    qq = deque()
    qq.append(root)

    while qq:
        curr = qq.popleft()

        if curr is None:
            result.append("N")
            continue

        result.append(str(curr.data))
        qq.append(curr.left)
        qq.append(curr.right)

    # Remove trailing non-numeric elements
    while result and not result[-1].isnumeric():
        result.pop()

    return " ".join(result)


def inorderTraversal(root):
    # Code here
    inorderTraversalUtil(root)
    print()


# Function to Build Tree
def buildTree(s):
    #Corner Case
    if (len(s) == 0 or s[0] == "N"):
        return None

    # Creating list of strings from input
    # string after spliting by space
    ip = list(map(str, s.split()))

    # Create the root of the tree
    root = Node(int(ip[0]))
    size = 0
    q = deque()

    # Push the root to the queue
    q.append(root)
    size = size + 1

    # Starting from the second element
    i = 1
    while (size > 0 and i < len(ip)):
        # Get and remove the front of the queue
        currNode = q[0]
        q.popleft()
        size = size - 1

        # Get the current node's value from the string
        currVal = ip[i]

        # If the left child is not null
        if (currVal != "N"):

            # Create the left child for the current node
            currNode.left = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.left)
            size = size + 1
        # For the right child
        i = i + 1
        if (i >= len(ip)):
            break
        currVal = ip[i]

        # If the right child is not null
        if (currVal != "N"):

            # Create the right child for the current node
            currNode.right = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.right)
            size = size + 1
        i = i + 1
    return root


if __name__ == "__main__":
    t = int(input())
    for _ in range(0, t):
        s = input()
        root = buildTree(s)
        Solution().mirror(root)
        print(levelOrder(root))
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-02-06
Problem: Construct Tree from Inorder  Preorder
Filename: 2025-02-06_Construct_Tree_from_Inorder__Preorder.py
================================================================================

#User function Template for python3

'''
# Node class
class Node:
    def __init__(self,val):
        self.data = val
        self.right = None
        self.left = None

'''
# Note: Build tree and return root node
class Solution:
    def buildTree(self, inorder, preorder):
        m = {v: i for i, v in enumerate(inorder)}
        self.i = 0
        def f(l, r):
            if l > r: return None
            root = Node(preorder[self.i])
            self.i += 1
            pos = m[root.data]
            root.left = f(l, pos - 1)
            root.right = f(pos + 1, r)
            return root
        return f(0, len(inorder) - 1)


#{ 
 # Driver Code Starts
#Initial Template for Python 3


class Node:

    def __init__(self, val):
        self.data = val
        self.right = None
        self.left = None


def printPostorder(n):
    if n is None:
        return
    printPostorder(n.left)
    printPostorder(n.right)
    print(n.data, end=' ')


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        inorder = [int(x) for x in input().split()]
        preorder = [int(x) for x in input().split()]

        root = Solution().buildTree(inorder, preorder)
        printPostorder(root)
        print()

# } Driver Code Ends


================================================================================
Date: 2025-02-07
Problem: Inorder Traversal
Filename: 2025-02-07_Inorder_Traversal.py
================================================================================


'''
# Node Class:
class Node:
    def init(self,val):
        self.data = val
        self.left = None
        self.right = None
'''

class Solution:
    def inOrder(self, root):
        a = []
        def f(r):
            if r:
                f(r.left)
                a.append(r.data)
                f(r.right)
        f(root)
        return a

2)
class Solution:
    def inOrder(self, root):
        result, stack = [], []
        curr = root
        while curr or stack:
            while curr:
                stack.append(curr)
                curr = curr.left
            curr = stack.pop()
            result.append(curr.data)
            curr = curr.right
        return result


#{ 
 # Driver Code Starts
#Initial Template for Python 3

#Contributed by Sudarshan Sharma
from collections import deque


# Tree Node
class Node:

    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None


# Function to Build Tree
def buildTree(s):
    #Corner Case
    if (len(s) == 0 or s[0] == "N"):
        return None

    # Creating list of strings from input
    # string after spliting by space
    ip = list(map(str, s.split()))

    # Create the root of the tree
    root = Node(int(ip[0]))
    size = 0
    q = deque()

    # Push the root to the queue
    q.append(root)
    size = size + 1

    # Starting from the second element
    i = 1
    while (size > 0 and i < len(ip)):
        # Get and remove the front of the queue
        currNode = q[0]
        q.popleft()
        size = size - 1

        # Get the current node's value from the string
        currVal = ip[i]

        # If the left child is not null
        if (currVal != "N"):

            # Create the left child for the current node
            currNode.left = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.left)
            size = size + 1
        # For the right child
        i = i + 1
        if (i >= len(ip)):
            break
        currVal = ip[i]

        # If the right child is not null
        if (currVal != "N"):

            # Create the right child for the current node
            currNode.right = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.right)
            size = size + 1
        i = i + 1
    return root


if __name__ == "__main__":
    t = int(input())
    for _ in range(0, t):
        s = input()
        root = buildTree(s)
        res = Solution().inOrder(root)
        for i in range(len(res)):
            print(res[i], end=" ")
        print()

        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-02-08
Problem: Tree Boundary Traversal
Filename: 2025-02-08_Tree_Boundary_Traversal.py
================================================================================

#User function Template for python3

'''
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None
'''
class Solution:
    def boundaryTraversal(self, root):
        if not root:
            return []
        res = [root.data] if root.left or root.right else []

        cur = root.left
        while cur:
            if cur.left or cur.right:
                res.append(cur.data)
            cur = cur.left if cur.left else cur.right

        def leaf_nodes(node):
            if not node:
                return
            leaf_nodes(node.left)
            if not node.left and not node.right:
                res.append(node.data)
            leaf_nodes(node.right)

        leaf_nodes(root)

        right_boundary = []
        cur = root.right
        while cur:
            if cur.left or cur.right:
                right_boundary.append(cur.data)
            cur = cur.right if cur.right else cur.left

        res += reversed(right_boundary)
        return res

#{ 
 # Driver Code Starts
#Initial Template for Python 3

# function should return a list containing the boundary view of the binary tree
#{
#  Driver Code Starts
import sys

import sys

sys.setrecursionlimit(100000)
#Contributed by Sudarshan Sharma
from collections import deque


# Tree Node
class Node:

    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None


# Function to Build Tree
def buildTree(s):
    #Corner Case
    if (len(s) == 0 or s[0] == "N"):
        return None

    # Creating list of strings from input
    # string after spliting by space
    ip = list(map(str, s.split()))

    # Create the root of the tree
    root = Node(int(ip[0]))
    size = 0
    q = deque()

    # Push the root to the queue
    q.append(root)
    size = size + 1

    # Starting from the second element
    i = 1
    while (size > 0 and i < len(ip)):
        # Get and remove the front of the queue
        currNode = q[0]
        q.popleft()
        size = size - 1

        # Get the current node's value from the string
        currVal = ip[i]

        # If the left child is not null
        if (currVal != "N"):

            # Create the left child for the current node
            currNode.left = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.left)
            size = size + 1
        # For the right child
        i = i + 1
        if (i >= len(ip)):
            break
        currVal = ip[i]

        # If the right child is not null
        if (currVal != "N"):

            # Create the right child for the current node
            currNode.right = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.right)
            size = size + 1
        i = i + 1
    return root


if __name__ == "__main__":
    t = int(input())
    for _ in range(0, t):
        s = input()
        root = buildTree(s)
        obj = Solution()
        res = obj.boundaryTraversal(root)
        for i in res:
            print(i, end=" ")
        print('')
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-02-09
Problem: Maximum path sum from any node
Filename: 2025-02-09_Maximum_path_sum_from_any_node.py
================================================================================

#User function Template for python3


'''
class Node:
    def __init__(self,val):
        self.data = val
        self.left = None
        self.right = None
'''

class Solution:
    def findMaxSum(self, root):
        def dfs(node):
            if not node: return 0
            l = max(0, dfs(node.left))
            r = max(0, dfs(node.right))
            nonlocal res
            res = max(res, l + r + node.data)
            return max(l, r) + node.data
        res = float('-inf')
        dfs(root)
        return res

#{ 
 # Driver Code Starts
#Initial Template for Python 3

#Contributed by Suman Rana
import sys
sys.setrecursionlimit(100000)
from collections import deque
# Tree Node
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None

    
# Function to Build Tree   
def buildTree(s):
    #Corner Case
    if(len(s)==0 or s[0]=="N"):           
        return None
        
    # Creating list of strings from input 
    # string after spliting by space
    ip=list(map(str,s.split()))
    
    # Create the root of the tree
    root=Node(int(ip[0]))                     
    size=0
    q=deque()
    
    # Push the root to the queue
    q.append(root)                            
    size=size+1 
    
    # Starting from the second element
    i=1                                       
    while(size>0 and i<len(ip)):
        # Get and remove the front of the queue
        currNode=q[0]
        q.popleft()
        size=size-1
        
        # Get the current node's value from the string
        currVal=ip[i]
        
        # If the left child is not null
        if(currVal!="N"):
            
            # Create the left child for the current node
            currNode.left=Node(int(currVal))
            
            # Push it to the queue
            q.append(currNode.left)
            size=size+1
        # For the right child
        i=i+1
        if(i>=len(ip)):
            break
        currVal=ip[i]
        
        # If the right child is not null
        if(currVal!="N"):
            
            # Create the right child for the current node
            currNode.right=Node(int(currVal))
            
            # Push it to the queue
            q.append(currNode.right)
            size=size+1
        i=i+1
    return root
    


if __name__=="__main__":
    t=int(input())
    for _ in range(0,t):
        root=buildTree(input())
        ob = Solution()
        print(ob.findMaxSum(root))
        
        

        print("~")
# } Driver Code Ends


================================================================================
Date: 2025-02-10
Problem: K Sum Paths
Filename: 2025-02-10_K_Sum_Paths.py
================================================================================

'''
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None
'''
class Solution:
    def sumK(self, r, k):
        self.c = 0
        m = {0: 1}
        def dfs(r, s):
            if not r: return
            s += r.data
            self.c += m.get(s - k, 0)
            m[s] = m.get(s, 0) + 1
            dfs(r.left, s)
            dfs(r.right, s)
            m[s] -= 1
            if m[s] == 0: del m[s]
        dfs(r, 0)
        return self.c


#{ 
 # Driver Code Starts
#Initial Template for Python 3

import sys

sys.setrecursionlimit(100000)
from collections import deque
from collections import defaultdict


class Node:

    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None


# Function to Build Tree
def buildTree(s):
    #Corner Case
    if (len(s) == 0 or s[0] == "N"):
        return None

    # Creating list of strings from input
    # string after spliting by space
    ip = list(map(str, s.split()))

    # Create the root of the tree
    root = Node(int(ip[0]))
    size = 0
    q = deque()

    # Push the root to the queue
    q.append(root)
    size = size + 1

    # Starting from the second element
    i = 1
    while (size > 0 and i < len(ip)):
        # Get and remove the front of the queue
        currNode = q[0]
        q.popleft()
        size = size - 1

        # Get the current node's value from the string
        currVal = ip[i]

        # If the left child is not null
        if (currVal != "N"):

            # Create the left child for the current node
            currNode.left = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.left)
            size = size + 1
        # For the right child
        i = i + 1
        if (i >= len(ip)):
            break
        currVal = ip[i]

        # If the right child is not null
        if (currVal != "N"):

            # Create the right child for the current node
            currNode.right = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.right)
            size = size + 1
        i = i + 1
    return root


if __name__ == "__main__":
    t = int(input())
    for _ in range(0, t):
        s = input()
        root = buildTree(s)
        d = int(input())
        ob = Solution()
        print(ob.sumK(root, d))

        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-02-11
Problem: Check for BST
Filename: 2025-02-11_Check_for_BST.py
================================================================================

#User function Template for python3


class Solution:
    def isBST(self, root, min_val=float('-inf'), max_val=float('inf')):
        return not root or (min_val < root.data < max_val and
                            self.isBST(root.left, min_val, root.data) and
                            self.isBST(root.right, root.data, max_val))



#{ 
 # Driver Code Starts
#Initial Template for Python 3
from collections import deque


# Tree Node
class Node:

    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None


# Function to Build Tree
def buildTree(s):
    #Corner Case
    if (len(s) == 0 or s[0] == "N"):
        return None

    # Creating list of strings from input
    # string after spliting by space
    ip = list(map(str, s.split()))

    # Create the root of the tree
    root = Node(int(ip[0]))
    size = 0
    q = deque()

    # Push the root to the queue
    q.append(root)
    size = size + 1

    # Starting from the second element
    i = 1
    while (size > 0 and i < len(ip)):
        # Get and remove the front of the queue
        currNode = q[0]
        q.popleft()
        size = size - 1

        # Get the current node's value from the string
        currVal = ip[i]

        # If the left child is not null
        if (currVal != "N"):

            # Create the left child for the current node
            currNode.left = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.left)
            size = size + 1
        # For the right child
        i = i + 1
        if (i >= len(ip)):
            break
        currVal = ip[i]

        # If the right child is not null
        if (currVal != "N"):

            # Create the right child for the current node
            currNode.right = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.right)
            size = size + 1
        i = i + 1
    return root


if __name__ == "__main__":
    t = int(input())
    for _ in range(0, t):
        s = input()
        root = buildTree(s)
        if Solution().isBST(root):
            print("true")
        else:
            print("false")
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-02-12
Problem: k-th Smallest in BST
Filename: 2025-02-12_k-th_Smallest_in_BST.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3

from collections import deque
# Tree Node
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None

# Function to Build Tree   
def buildTree(s):
    #Corner Case
    if(len(s)==0 or s[0]=="N"):           
        return None
        
    # Creating list of strings from input 
    # string after spliting by space
    ip=list(map(str,s.split()))
    
    # Create the root of the tree
    root=Node(int(ip[0]))                     
    size=0
    q=deque()
    
    # Push the root to the queue
    q.append(root)                            
    size=size+1 
    
    # Starting from the second element
    i=1                                       
    while(size>0 and i<len(ip)):
        # Get and remove the front of the queue
        currNode=q[0]
        q.popleft()
        size=size-1
        
        # Get the current node's value from the string
        currVal=ip[i]
        
        # If the left child is not null
        if(currVal!="N"):
            
            # Create the left child for the current node
            currNode.left=Node(int(currVal))
            
            # Push it to the queue
            q.append(currNode.left)
            size=size+1
        # For the right child
        i=i+1
        if(i>=len(ip)):
            break
        currVal=ip[i]
        
        # If the right child is not null
        if(currVal!="N"):
            
            # Create the right child for the current node
            currNode.right=Node(int(currVal))
            
            # Push it to the queue
            q.append(currNode.right)
            size=size+1
        i=i+1
    return root
    

# } Driver Code Ends
#User function Template for python3

'''
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None
'''

class Solution:
    def kthSmallest(self, root, k):
        while root:
            if not root.left:
                k -= 1
                if k == 0:
                    return root.data
                root = root.right
            else:
                pre = root.left
                while pre.right and pre.right != root:
                    pre = pre.right
                if not pre.right:
                    pre.right = root
                    root = root.left
                else:
                    pre.right = None
                    k -= 1
                    if k == 0:
                        return root.data
                    root = root.right
        return -1

#{ 
 # Driver Code Starts.
if __name__=="__main__":
    t=int(input())
    for _ in range(0,t):
        s=input()
        root=buildTree(s)
        k1=int(input())
        print(Solution().kthSmallest(root, k1))
        
        print("~")
# } Driver Code Ends


================================================================================
Date: 2025-02-13
Problem: Pair Sum in BST
Filename: 2025-02-13_Pair_Sum_in_BST.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3
from collections import deque
# Tree Node
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None

# Function to Build Tree   
def buildTree(s):
    #Corner Case
    if(len(s)==0 or s[0]=="N"):           
        return None
        
    # Creating list of strings from input 
    # string after spliting by space
    ip=list(map(str,s.split()))
    
    # Create the root of the tree
    root=Node(int(ip[0]))                     
    size=0
    q=deque()
    
    # Push the root to the queue
    q.append(root)                            
    size=size+1 
    
    # Starting from the second element
    i=1                                       
    while(size>0 and i<len(ip)):
        # Get and remove the front of the queue
        currNode=q[0]
        q.popleft()
        size=size-1
        
        # Get the current node's value from the string
        currVal=ip[i]
        
        # If the left child is not null
        if(currVal!="N"):
            
            # Create the left child for the current node
            currNode.left=Node(int(currVal))
            
            # Push it to the queue
            q.append(currNode.left)
            size=size+1
        # For the right child
        i=i+1
        if(i>=len(ip)):
            break
        currVal=ip[i]
        
        # If the right child is not null
        if(currVal!="N"):
            
            # Create the right child for the current node
            currNode.right=Node(int(currVal))
            
            # Push it to the queue
            q.append(currNode.right)
            size=size+1
        i=i+1
    return root
    

# } Driver Code Ends

'''
# Tree Node
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None

'''

class Solution:
    def findTarget(self, root, target):
        inorder = []
        def inorderTraversal(node):
            if not node:
                return
            inorderTraversal(node.left)
            inorder.append(node.data)
            inorderTraversal(node.right)

        inorderTraversal(root)
        left, right = 0, len(inorder) - 1
        while left < right:
            total = inorder[left] + inorder[right]
            if total == target:
                return True
            if total < target:
                left += 1
            else:
                right -= 1
        return False

#{ 
 # Driver Code Starts.
if __name__=="__main__":
    t=int(input())
    for _ in range(0,t):
        s=input()
        summ = int(input())
        root=buildTree(s)
        ans = Solution().findTarget(root,summ)
        if (ans==False):
            print(0)
        else:
            print(1)
        print("~")
# } Driver Code Ends


================================================================================
Date: 2025-02-14
Problem: Fixing Two nodes of a BST
Filename: 2025-02-14_Fixing_Two_nodes_of_a_BST.py
================================================================================

'''
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None
'''

class Solution:
    def correctBST(self, root):
        self.first = self.middle = self.last = self.prev = None

        def inorder(node):
            if not node:
                return
            inorder(node.left)
            if self.prev and node.data < self.prev.data:
                if not self.first:
                    self.first, self.middle = self.prev, node
                else:
                    self.last = node
            self.prev = node
            inorder(node.right)

        inorder(root)
        self.first.data, (self.last or self.middle).data = (self.last or self.middle).data, self.first.data


#{ 
 # Driver Code Starts
#Initial Template for Python 3

from collections import deque


# Tree Node
class Node:

    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None


# Function to Build Tree
def buildTree(s):
    #Corner Case
    if (len(s) == 0 or s[0] == "N"):
        return None

    # Creating list of strings from input
    # string after spliting by space
    ip = list(map(str, s.split()))

    # Create the root of the tree
    root = Node(int(ip[0]))
    size = 0
    q = deque()

    # Push the root to the queue
    q.append(root)
    size = size + 1

    # Starting from the second element
    i = 1
    while (size > 0 and i < len(ip)):
        # Get and remove the front of the queue
        currNode = q[0]
        q.popleft()
        size = size - 1

        # Get the current node's value from the string
        currVal = ip[i]

        # If the left child is not null
        if (currVal != "N"):

            # Create the left child for the current node
            currNode.left = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.left)
            size = size + 1
        # For the right child
        i = i + 1
        if (i >= len(ip)):
            break
        currVal = ip[i]

        # If the right child is not null
        if (currVal != "N"):

            # Create the right child for the current node
            currNode.right = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.right)
            size = size + 1
        i = i + 1
    return root


def isBST(n, lower, upper):
    if n is None:
        return True
    if n.data <= lower or n.data >= upper:
        return False
    return isBST(n.left, lower, n.data) and isBST(n.right, n.data, upper)


def compare(a, b, mismatch):
    if a is None and b is None:
        return True
    if a is None or b is None:
        return False

    if a.data != b.data:
        mismatch.append((a.data, b.data))

    return compare(a.left, b.left, mismatch) and compare(
        a.right, b.right, mismatch)


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        s = input()

        root = buildTree(s)
        duplicate = buildTree(s)
        obj = Solution()
        obj.correctBST(root)

        # check 1: is tree now a BST
        if not isBST(root, 0, 1000000000):
            print(0)
            continue

        # check 2: comparing with duplicate tree

        mismatch = []
        # a list to store data of mismatching nodes

        if not compare(root, duplicate, mismatch):
            # false output from this function indicates change in tree structure
            print(0)

        if len(mismatch) != 2 or mismatch[0][0] != mismatch[1][1] or mismatch[
                0][1] != mismatch[1][0]:
            print(0)
        else:
            print(1)

        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-02-15
Problem: Lowest Common Ancestor in a BST
Filename: 2025-02-15_Lowest_Common_Ancestor_in_a_BST.py
================================================================================

'''
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None
'''

class Solution:
    def LCA(self, root, n1, n2):
        while root and (root.data - n1.data) * (root.data - n2.data) > 0:
            root = root.left if n1.data < root.data else root.right
        return root
 



#{ 
 # Driver Code Starts
from collections import deque


# Tree Node
class Node:

    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None


# Function to Build Tree
def buildTree(s):
    # Corner Case
    if len(s) == 0 or s[0] == "N":
        return None

    # Creating list of strings from input string after splitting by space
    ip = list(map(str, s.split()))

    # Create the root of the tree
    root = Node(int(ip[0]))
    q = deque()

    # Push the root to the queue
    q.append(root)

    # Starting from the second element
    i = 1
    while len(q) > 0 and i < len(ip):
        # Get and remove the front of the queue
        currNode = q.popleft()

        # Get the current node's value from the string
        currVal = ip[i]

        # If the left child is not null
        if currVal != "N":
            # Create the left child for the current node
            currNode.left = Node(int(currVal))
            # Push it to the queue
            q.append(currNode.left)

        # For the right child
        i += 1
        if i >= len(ip):
            break
        currVal = ip[i]

        # If the right child is not null
        if currVal != "N":
            # Create the right child for the current node
            currNode.right = Node(int(currVal))
            # Push it to the queue
            q.append(currNode.right)
        i += 1
    return root


if __name__ == "__main__":
    t = int(input())
    ob = Solution()
    for _ in range(t):
        s = input()
        root = buildTree(s)

        # Read n1 and n2 from two separate lines
        x = int(input())
        y = int(input())
        n1 = Node(x)
        n2 = Node(y)
        print(ob.LCA(root, n1, n2).data)
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-02-16
Problem: Serialize and deserialize a binary tree
Filename: 2025-02-16_Serialize_and_deserialize_a_binary_tree.py
================================================================================

#User function Template for python3


'''
class Node:
    def __init__(self,val):
        self.data = val
        self.left = None
        self.right = None
'''

class Solution:
    def serialize(self, root):
        a = []
        def s(r):
            if not r:
                a.append(-1)
                return
            a.append(r.data)
            s(r.left)
            s(r.right)
        s(root)
        return a

    def deSerialize(self, arr):
        self.i = 0
        def d():
            if self.i >= len(arr) or arr[self.i] == -1:
                self.i += 1
                return None
            r = Node(arr[self.i])
            self.i += 1
            r.left = d()
            r.right = d()
            return r
        return d()


#{ 
 # Driver Code Starts
#Initial Template for Python 3

#Initial Template for Python 3

#Contributed by Suman Rana
from collections import deque


# Tree Node
class Node:

    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None


# Function to Build Tree
def buildTree(s):
    #Corner Case
    if (len(s) == 0 or s[0] == "N"):
        return None

    # Creating list of strings from input
    # string after spliting by space
    ip = list(map(str, s.split()))

    # Create the root of the tree
    root = Node(int(ip[0]))
    size = 0
    q = deque()

    # Push the root to the queue
    q.append(root)
    size = size + 1

    # Starting from the second element
    i = 1
    while (size > 0 and i < len(ip)):
        # Get and remove the front of the queue
        currNode = q[0]
        q.popleft()
        size = size - 1

        # Get the current node's value from the string
        currVal = ip[i]

        # If the left child is not null
        if (currVal != "N"):

            # Create the left child for the current node
            currNode.left = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.left)
            size = size + 1
        # For the right child
        i = i + 1
        if (i >= len(ip)):
            break
        currVal = ip[i]

        # If the right child is not null
        if (currVal != "N"):

            # Create the right child for the current node
            currNode.right = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.right)
            size = size + 1
        i = i + 1
    return root


def inorder(root):
    if not root:
        return
    inorder(root.left)
    print(root.data, end=" ")
    inorder(root.right)


def _deleteTree(node):
    if (node == None):
        return

    # first delete both subtrees
    _deleteTree(node.left)
    _deleteTree(node.right)
    node.left = None
    node.right = None
    # then delete the node


# Deletes a tree and sets the root as NULL
def deleteTree(node_ref):
    _deleteTree(node_ref)
    node_ref = None


if __name__ == "__main__":
    t = int(input())
    for _ in range(0, t):
        root = buildTree(input())
        ob = Solution()
        A = ob.serialize(root)
        deleteTree(root)
        root = None
        r = ob.deSerialize(A)
        inorder(r)
        print()

        print("~")
# } Driver Code Ends


================================================================================
Date: 2025-02-17
Problem: k largest elements
Filename: 2025-02-17_k_largest_elements.py
================================================================================

class Solution:
    def kLargest(self, arr, k):
        return sorted(arr, reverse=True)[:k]


#{ 
 # Driver Code Starts
#Initial Template for Python 3
if __name__ == '__main__':
    tc = int(input())
    while tc > 0:
        arr = list(map(int, input().strip().split()))
        k = int(input().strip())
        ob = Solution()
        ans = ob.kLargest(arr, k)

        print(" ".join(map(str, ans)))
        tc -= 1
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-02-18
Problem: K Closest Points to Origin
Filename: 2025-02-18_K_Closest_Points_to_Origin.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3
from typing import List


# } Driver Code Ends

class Solution:
    def kClosest(self, p: list[list[int]], k: int) -> list[list[int]]:
        return sorted(p, key=lambda a: a[0]**2 + a[1]**2)[:k]
        

#{ 
 # Driver Code Starts.

if __name__ == "__main__":
    t = int(input())
    while t > 0:
        t -= 1
        k = int(input())
        n = int(input())
        points = []
        for _ in range(n):
            x, y = map(int, input().split())
            points.append([x, y])
        
        solution = Solution()
        ans = solution.kClosest(points, k)
        ans.sort()
        for point in ans:
            print(point[0], point[1])
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-02-19
Problem: Merge K sorted linked lists
Filename: 2025-02-19_Merge_K_sorted_linked_lists.py
================================================================================

#User function Template for python3
'''
class Node:
    def _init_(self,x):
        self.data = x
        self.next = None
'''
class Solution:
    def mergeKLists(self, l):
        pq, d = [], Node(0)
        for x in l: 
            if x: heapq.heappush(pq, (x.data, x))
        t = d
        while pq:
            _, t.next = heapq.heappop(pq)
            t = t.next
            if t.next: heapq.heappush(pq, (t.next.data, t.next))
        return d.next

2)
class Solution:
    def mergeKLists(self, lists):
        if not lists: return None
        while len(lists) > 1:
            temp = []
            for i in range(0, len(lists), 2):
                temp.append(self.merge(lists[i], lists[i+1] if i+1 < len(lists) else None))
            lists = temp
        return lists[0]

    def merge(self, a, b):
        if not a or not b: return a or b
        if a.data > b.data: a, b = b, a
        a.next = self.merge(a.next, b)
        return a

3)
class Solution:
    def mergeKLists(self, lists):
        v = []
        for l in lists:
            while l: v.append(l.data); l = l.next
        v.sort()
        d = Node(0); t = d
        for x in v: t.next = Node(x); t = t.next
        return d.next

#{ 
 # Driver Code Starts
import heapq


class Node:

    def __init__(self, x):
        self.data = x
        self.next = None

    # To compare nodes in the heap
    def __lt__(self, other):
        return self.data < other.data


def printList(node):
    while node:
        print(node.data, end=" ")
        node = node.next
    print()


def main():
    t = int(input())
    for _ in range(t):
        n = int(input())
        lists = []
        for _ in range(n):
            values = list(map(int, input().split()))
            head = None
            temp = None
            for value in values:
                newNode = Node(value)
                if head is None:
                    head = newNode
                    temp = head
                else:
                    temp.next = newNode
                    temp = temp.next
            lists.append(head)

        sol = Solution()
        head = sol.mergeKLists(lists)
        printList(head)
        print("~")


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2025-02-20
Problem: Find median in a stream
Filename: 2025-02-20_Find_median_in_a_stream.py
================================================================================

class Solution:
    def getMedian(self, arr):
        maxH, minH, res = [], [], []

        for n in arr:
            heapq.heappush(maxH, -heapq.heappushpop(minH, n))
            if len(maxH) > len(minH):
                heapq.heappush(minH, -heapq.heappop(maxH))
            res.append(minH[0] if len(minH) > len(maxH) else (-maxH[0] + minH[0]) / 2)
        return res
        
#{ 
 # Driver Code Starts
#Initial Template for Python 3


def main():
    t = int(input().strip())
    for _ in range(t):
        s = input().strip()
        nums = list(map(int, s.split()))
        ob = Solution()
        ans = ob.getMedian(nums)
        print(" ".join(f"{x:.1f}" for x in ans))


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2025-02-21
Problem: Parenthesis Checker
Filename: 2025-02-21_Parenthesis_Checker.py
================================================================================


class Solution:
    def isBalanced(self, s):
        st = []
        for c in s:
            if c in "({[": st.append(c)
            elif not st or abs(ord(st[-1]) - ord(c)) > 2: return False
            else: st.pop()
        return not st


#{ 
 # Driver Code Starts
#Initial Template for Python 3

import atexit
import io
import sys

#Contributed by : Nagendra Jha

_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__
_OUTPUT_BUFFER = io.StringIO()
sys.stdout = _OUTPUT_BUFFER


@atexit.register
def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())


if __name__ == '__main__':
    test_cases = int(input())
    for cases in range(test_cases):
        s = str(input())
        obj = Solution()
        if obj.isBalanced(s):
            print("true")
        else:
            print("false")
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-02-22
Problem: Longest valid Parentheses
Filename: 2025-02-22_Longest_valid_Parentheses.py
================================================================================


class Solution:
    def maxLength(self, s):
        l = r = m = 0
        for c in s:
            l += c == '('
            r += c == ')'
            if l == r:
                m = max(m, 2 * r)
            elif r > l:
                l = r = 0
        l = r = 0
        for c in s[::-1]:
            l += c == '('
            r += c == ')'
            if l == r:
                m = max(m, 2 * l)
            elif l > r:
                l = r = 0
        return m

2)
class Solution:
    def maxLength(self, s):
        st=[-1]; m=0
        for i,c in enumerate(s):
            if c=='(':
                st.append(i)
            else:
                st.pop()
                if not st: st.append(i)
                else: m = max(m, i - st[-1])
        return m


#{ 
 # Driver Code Starts
# Initial Template for Python3

if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        S = input()

        ob = Solution()
        print(ob.maxLength(S))
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-02-23
Problem: Next Greater Element
Filename: 2025-02-23_Next_Greater_Element.py
================================================================================

# User function Template for python3

class Solution:
    def nextLargerElement(self, arr):
        stack, res = [], [-1] * len(arr)
        for i in range(len(arr) - 1, -1, -1):
            while stack and stack[-1] <= arr[i]: stack.pop()
            if stack: res[i] = stack[-1]
            stack.append(arr[i])
        return res

2)
class Solution:
    def nextLargerElement(self, arr):
        s = []
        for i in range(len(arr) - 1, -1, -1):
            val = arr[i]
            while s and s[-1] <= val:
                s.pop()
            arr[i] = -1 if not s else s[-1]
            s.append(val)
        return arr
#{ 
 # Driver Code Starts
# Initial Template for Python 3

t = int(input())  # number of test cases
for _ in range(t):
    arr = list(map(int, input().split()))  # input array
    s = Solution().nextLargerElement(arr)  # find the next greater elements

    # Output formatting
    if s:
        print(" ".join(map(str, s)))  # Print next greater elements
    else:
        print("[]")  # Print empty list if no next greater element is found
    print("~")
# } Driver Code Ends


================================================================================
Date: 2025-02-24
Problem: Stock span problem
Filename: 2025-02-24_Stock_span_problem.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3

# } Driver Code Ends

class Solution:
    def calculateSpan(self, arr):
        span, st = [], []
        
        for i, price in enumerate(arr):
            days = 1
            while st and arr[st[-1]] <= price:
                days += span[st.pop()]
            span.append(days)
            st.append(i)
        
        return span

#{ 
 # Driver Code Starts.
#Initial Template for Python 3

if __name__ == "__main__":
    t = int(input())
    while t > 0:
        arr = list(map(int, input().split()))
        ob = Solution()
        ans = ob.calculateSpan(arr)
        print(*ans)
        print("~")
        t -= 1
# } Driver Code Ends


================================================================================
Date: 2025-02-25
Problem: Histogram Max Rectangular Area
Filename: 2025-02-25_Histogram_Max_Rectangular_Area.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3

# } Driver Code Ends


class Solution:
    def getMaxArea(self, arr):
        stack, n, res = [], len(arr), 0
        for i in range(n + 1):
            while stack and (i == n or arr[stack[-1]] >= arr[i]):
                h = arr[stack.pop()]
                w = i if not stack else i - stack[-1] - 1
                res = max(res, h * w)
            stack.append(i)
        return res

#{ 
 # Driver Code Starts.
#Initial Template for Python 3

if __name__ == "__main__":
    t = int(input())
    while t > 0:
        arr = list(map(int, input().split()))
        ob = Solution()
        res = ob.getMaxArea(arr)
        print(res)
        print("~")
        t -= 1


# } Driver Code Ends


================================================================================
Date: 2025-02-26
Problem: Maximum of minimum for every window size
Filename: 2025-02-26_Maximum_of_minimum_for_every_window_size.py
================================================================================

class Solution:
    def maxOfMins(self, arr):
        n = len(arr)
        res, length, s = [0] * n, [0] * n, []
        for i in range(n + 1):
            while s and (i == n or arr[s[-1]] >= arr[i]):
                j = s.pop()
                length[j] = i if not s else i - s[-1] - 1
            if i < n:
                s.append(i)
        for i in range(n):
            res[length[i] - 1] = max(res[length[i] - 1], arr[i])
        for i in range(n - 2, -1, -1):
            res[i] = max(res[i], res[i + 1])
        return res

#{ 
 # Driver Code Starts
if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        arr = list(map(int, input().split()))
        solution = Solution()
        result = solution.maxOfMins(arr)
        print(" ".join(map(str, result)))
        print("~")
# } Driver Code Ends


================================================================================
Date: 2025-02-27
Problem: Get Min from Stack
Filename: 2025-02-27_Get_Min_from_Stack.py
================================================================================

class Solution:
    def __init__(self): self.s, self.m = [], []

    def push(self, x): self.s.append(x); self.m.append(x if not self.m else min(x, self.m[-1]))
    def pop(self): 
        if self.s: self.s.pop(); self.m.pop()
    def peek(self): return -1 if not self.s else self.s[-1]
    def getMin(self): return -1 if not self.m else self.m[-1]

2)
class Solution:
    def __init__(self):
        self.s, self.m = [], []

    def push(self, x):
        self.s.append(x)
        self.m.append(x if not self.m else min(x, self.m[-1]))

    def pop(self):
        if self.s: self.s.pop(), self.m.pop()

    def peek(self):
        return -1 if not self.s else self.s[-1]

    def getMin(self):
        return -1 if not self.m else self.m[-1]

#{ 
 # Driver Code Starts
# Driver Code
if __name__ == '__main__':
    t = int(input())  # Number of test cases

    for _ in range(t):
        q = int(input())  # Number of queries
        stk = Solution()  # Initialize stack
        results = []

        for _ in range(q):
            query = list(map(int, input().split()))

            if query[0] == 1:
                stk.push(query[1])  # Push operation
            elif query[0] == 2:
                stk.pop()  # Pop operation (no return value)
            elif query[0] == 3:
                results.append(str(stk.peek()))  # Peek operation
            elif query[0] == 4:
                results.append(str(stk.getMin()))  # GetMin operation

        print(" ".join(results))  # Print all results in one line
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-02-28
Problem: Evaluation of Postfix Expression
Filename: 2025-02-28_Evaluation_of_Postfix_Expression.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3


# } Driver Code Ends


class Solution:
    def evaluate(self, arr):
        st = []
        for s in arr:
            if s in {"+", "-", "*", "/"}:
                b, a = st.pop(), st.pop()
                if s == "+": st.append(a + b)
                elif s == "-": st.append(a - b)
                elif s == "*": st.append(a * b)
                else: st.append(int(a / b))  # Division rounding towards zero
            else:
                st.append(int(s))
        return st[-1]


#{ 
 # Driver Code Starts.

if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        arr = input().split()
        solution = Solution()
        print(solution.evaluate(arr))
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-03-01
Problem: Decode the string
Filename: 2025-03-01_Decode_the_string.py
================================================================================

class Solution:
    def decodedString(self, s: str) -> str:
        str_st, num_st, cur, n = [], [], "", 0

        for c in s:
            if c.isdigit():
                n = n * 10 + int(c)
            elif c == "[":
                str_st.append(cur)
                num_st.append(n)
                cur, n = "", 0
            elif c == "]":
                cur = str_st.pop() + cur * num_st.pop()
            else:
                cur += c
        return cur


#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        s = input()

        ob = Solution()
        print(ob.decodedString(s))
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-03-02
Problem: K Sized Subarray Maximum
Filename: 2025-03-02_K_Sized_Subarray_Maximum.py
================================================================================

class Solution:
    def maxOfSubarrays(self, arr, k):
        res, dq = [], deque()
        for i in range(len(arr)):
            if dq and dq[0] <= i - k:
                dq.popleft()
            while dq and arr[dq[-1]] < arr[i]:
                dq.pop()
            dq.append(i)
            if i >= k - 1:
                res.append(arr[dq[0]])
        return res


#{ 
 # Driver Code Starts
#Initial Template for Python 3

import atexit
import io
import sys
from collections import deque

#Contributed by : Nagendra Jha

_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__
_OUTPUT_BUFFER = io.StringIO()
sys.stdout = _OUTPUT_BUFFER


@atexit.register
def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())


if __name__ == '__main__':
    test_cases = int(input())
    for cases in range(test_cases):
        arr = list(map(int, input().strip().split()))
        k = int(input())
        ob = Solution()
        res = ob.maxOfSubarrays(arr, k)
        for i in range(len(res)):
            print(res[i], end=" ")
        print()
        print("~")
# } Driver Code Ends


================================================================================
Date: 2025-03-03
Problem: Longest Bounded-Difference Subarray
Filename: 2025-03-03_Longest_Bounded-Difference_Subarray.py
================================================================================

from collections import deque

class Solution:
    def longestSubarray(self, arr, x):
        minQ, maxQ, start, resStart, resEnd = deque(), deque(), 0, 0, 0
        for end in range(len(arr)):
            while minQ and arr[minQ[-1]] > arr[end]: minQ.pop()
            while maxQ and arr[maxQ[-1]] < arr[end]: maxQ.pop()
            minQ.append(end), maxQ.append(end)
            while arr[maxQ[0]] - arr[minQ[0]] > x:
                if minQ[0] == start: minQ.popleft()
                if maxQ[0] == start: maxQ.popleft()
                start += 1
            if end - start > resEnd - resStart: resStart, resEnd = start, end
        return arr[resStart:resEnd + 1]


#{ 
 # Driver Code Starts
#Initial Template for Python 3
if __name__ == '__main__':
    tc = int(input())
    while tc > 0:
        arr = list(map(int, input().strip().split()))
        k = int(input().strip())
        ob = Solution()
        ans = ob.longestSubarray(arr, k)

        print(" ".join(map(str, ans)))
        tc -= 1
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-03-04
Problem: Longest Increasing Subsequence
Filename: 2025-03-04_Longest_Increasing_Subsequence.py
================================================================================

import bisect

class Solution:
    def lis(self, arr):
        ans = []
        for num in arr:
            idx = bisect.bisect_left(ans, num)
            if idx == len(ans):
                ans.append(num)
            else:
                ans[idx] = num
        return len(ans)



#{ 
 # Driver Code Starts
# Initial Template for Python 3
if __name__ == '__main__':
    for _ in range(int(input())):
        a = [int(x) for x in input().split()]
        ob = Solution()
        print(ob.lis(a))
        print("~")
# } Driver Code Ends


================================================================================
Date: 2025-03-05
Problem: Longest String Chain
Filename: 2025-03-05_Longest_String_Chain.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3

# } Driver Code Ends

#User function Template for python3

class Solution:
    def longestStringChain(self, words):
        words.sort(key=len)
        dp = {}
        res = 1
        for w in words:
            dp[w] = 1
            for i in range(len(w)):
                pred = w[:i] + w[i+1:]
                if pred in dp:
                    dp[w] = max(dp[w], dp[pred] + 1)
            res = max(res, dp[w])
        return res


#{ 
 # Driver Code Starts.
if __name__ == '__main__': 
    t = int(input())
    for _ in range (t):
        words = input().split()
        ob = Solution()
        res = ob.longestStringChain(words)
        print(res)
        print("~")
# } Driver Code Ends


================================================================================
Date: 2025-03-06
Problem: Longest Common Subsequence
Filename: 2025-03-06_Longest_Common_Subsequence.py
================================================================================

class Solution:
    def lcs(self, s1, s2):
        m, n = len(s1), len(s2)
        dp = [0] * (n + 1)
        for i in range(m):
            prev = 0
            for j in range(n):
                temp = dp[j + 1]
                dp[j + 1] = prev + 1 if s1[i] == s2[j] else max(dp[j + 1], dp[j])
                prev = temp
        return dp[n]
        
#{ 
 # Driver Code Starts
# Initial Template for Python 3
import atexit
import io
import sys

if __name__ == '__main__':
    test_cases = int(input())
    for cases in range(test_cases):
        s1 = str(input())  # Take first string as input
        s2 = str(input())  # Take second string as input
        ob = Solution()
        # Call the lcs function and print the result
        print(ob.lcs(s1, s2))
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-03-07
Problem: Longest Palindromic Subsequence
Filename: 2025-03-07_Longest_Palindromic_Subsequence.py
================================================================================

#User function Template for python3


# class Solution:
#     def longestPalinSubseq(self, s):
#         n = len(s)
#         prev = [0] * (n + 1)
#         curr = [0] * (n + 1)

#         for i in range(1, n + 1):
#             for j in range(1, n + 1):
#                 if s[i - 1] == s[n - j]:
#                     curr[j] = 1 + prev[j - 1]
#                 else:
#                     curr[j] = max(prev[j], curr[j - 1])
#             prev, curr = curr, prev

#         return prev[n]

class Solution:
    def longestPalinSubseq(self, s):
        n = len(s)
        dp = [[0] * n for _ in range(n)]
        for i in range(n - 1, -1, -1):
            dp[i][i] = 1
            for j in range(i + 1, n):
                if s[i] == s[j]:
                    dp[i][j] = 2 + dp[i + 1][j - 1]
                else:
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
        return dp[0][n - 1]

#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        s = input()
        ob = Solution()
        ans = ob.longestPalinSubseq(s)
        print(ans)
        print("~")
# } Driver Code Ends


================================================================================
Date: 2025-03-08
Problem: Longest Palindrome in a String
Filename: 2025-03-08_Longest_Palindrome_in_a_String.py
================================================================================

class Solution:
    def longestPalindrome(self, s):
        start, max_len = 0, 0
        for i in range(len(s)):
            for l in [i, i + 1]:
                j = i
                while j >= 0 and l < len(s) and s[j] == s[l]: j, l = j - 1, l + 1
                if l - j - 1 > max_len: start, max_len = j + 1, l - j - 1
        return s[start:start + max_len]
        
        

#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':

    t = int(input())

    for _ in range(t):
        S = input()

        ob = Solution()

        ans = ob.longestPalindrome(S)

        print(ans)
        print("~")
# } Driver Code Ends


================================================================================
Date: 2025-03-09
Problem: Palindrome SubStrings
Filename: 2025-03-09_Palindrome_SubStrings.py
================================================================================

#User function Template for python3
class Solution:
    def countPS(self, s):
        n, res = len(s), 0
        for i in range(n):
            l, r = i, i
            while l >= 0 and r < n and s[l] == s[r]: res += 1; l -= 1; r += 1
            l, r = i, i + 1
            while l >= 0 and r < n and s[l] == s[r]: res += 1; l -= 1; r += 1
        return res - n

2)
class Solution:
    def countPS(self, s):
        n, res = len(s), 0
        dp = [[False] * n for _ in range(n)]
        for i in range(n - 1, -1, -1):
            dp[i][i] = True
            for j in range(i + 1, n):
                if s[i] == s[j] and (j - i == 1 or dp[i + 1][j - 1]):
                    dp[i][j] = True
                    res += 1
        return res

#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':

    t = int(input())

    for _ in range(t):
        s = input()

        solObj = Solution()

        print(solObj.countPS(s))

        print("~")
# } Driver Code Ends


================================================================================
Date: 2025-03-10
Problem: Edit Distance
Filename: 2025-03-10_Edit_Distance.py
================================================================================

class Solution:
    def editDistance(self, s1, s2):
        m, n = len(s1), len(s2)
        prev, curr = list(range(n + 1)), [0] * (n + 1)
        for i in range(1, m + 1):
            curr[0] = i
            for j in range(1, n + 1):
                curr[j] = prev[j-1] if s1[i-1] == s2[j-1] else 1 + min(prev[j-1], prev[j], curr[j-1])
            prev, curr = curr, prev
        return prev[n]


#{ 
 # Driver Code Starts
if __name__ == '__main__':
    T = int(input())
    for i in range(T):
        s1 = input()
        s2 = input()
        ob = Solution()
        ans = ob.editDistance(s1, s2)
        print(ans)
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-03-11
Problem: Ways to Reach the nth Stair
Filename: 2025-03-11_Ways_to_Reach_the_nth_Stair.py
================================================================================

class Solution:
    def countWays(self, n):
        a, b = 1, 1
        for _ in range(n - 1):
            a, b = b, a + b
        return b

#{ 
 # Driver Code Starts
#Initial Template for Python 3
import atexit
import io
import sys

sys.setrecursionlimit(10**6)

# Contributed by : Nagendra Jha

if __name__ == '__main__':
    test_cases = int(input())
    for cases in range(test_cases):
        m = int(input())
        ob = Solution()
        print(ob.countWays(m))

        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-03-12
Problem: Min Cost Climbing Stairs
Filename: 2025-03-12_Min_Cost_Climbing_Stairs.py
================================================================================

#Back-end complete function Template for Python 3

class Solution:
    def minCostClimbingStairs(self, cost):
        a, b = cost[0], cost[1]
        for i in range(2, len(cost)):
            a, b = b, cost[i] + min(a, b)
        return min(a, b)
        


#{ 
 # Driver Code Starts
t = int(input())
for _ in range(t):
    arr = list(map(int, input().split()))  # Input array
    obj = Solution()
    res = obj.minCostClimbingStairs(arr)
    print(res)
    print("~")

# } Driver Code Ends


================================================================================
Date: 2025-03-13
Problem: 0 - 1 Knapsack Problem
Filename: 2025-03-13_0_-_1_Knapsack_Problem.py
================================================================================

class Solution:
    def knapsack(self, W, val, wt):
        dp = [0] * (W + 1)
        for i in range(len(wt)):
            for j in range(W, wt[i] - 1, -1):
                dp[j] = max(dp[j], val[i] + dp[j - wt[i]])
        return dp[W]


#{ 
 # Driver Code Starts
if __name__ == '__main__':
    test_cases = int(input())
    for _ in range(test_cases):
        capacity = int(input())
        values = list(map(int, input().strip().split()))
        weights = list(map(int, input().strip().split()))
        ob = Solution()
        print(ob.knapsack(capacity, values, weights))
        print("~")
# } Driver Code Ends


================================================================================
Date: 2025-03-14
Problem: Coin Change Count Ways
Filename: 2025-03-14_Coin_Change_Count_Ways.py
================================================================================

class Solution:
    def count(self, coins, sum):
        dp = [0] * (sum + 1)
        dp[0] = 1
        for coin in coins:
            for j in range(coin, sum + 1):
                dp[j] += dp[j - coin]
        return dp[sum]



#{ 
 # Driver Code Starts
#Initial Template for Python 3

import sys

sys.setrecursionlimit(10**6)

if __name__ == '__main__':
    t = int(input())
    for _ in range(t):

        coins = list(map(int, input().strip().split()))
        sum = int(input())
        ob = Solution()
        print(ob.count(coins, sum))

        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-03-15
Problem: Coin Change Minimum Coins
Filename: 2025-03-15_Coin_Change_Minimum_Coins.py
================================================================================

class Solution:
    def minCoins(self, coins, sum):
        dp = [float('inf')] * (sum + 1)
        dp[0] = 0
        for c in coins:
            for j in range(c, sum + 1):
                dp[j] = min(dp[j], dp[j - c] + 1)
        return -1 if dp[sum] == float('inf') else dp[sum]

#{ 
 # Driver Code Starts
#Initial Template for Python 3
#Position this line where user code will be pasted.
#Initial Template for Python 3

if __name__ == "__main__":
    t = int(input())
    while t > 0:
        k = int(input())
        arr = list(map(int, input().split()))
        ob = Solution()
        res = ob.minCoins(arr, k)
        print(res)
        print("~")
        t -= 1

# } Driver Code Ends


================================================================================
Date: 2025-03-16
Problem: Minimum Jumps
Filename: 2025-03-16_Minimum_Jumps.py
================================================================================

class Solution:
    def minJumps(self, arr):
        n, jumps, farthest, end = len(arr), 0, 0, 0
        if n == 1: return 0
        for i in range(n - 1):
            farthest = max(farthest, i + arr[i])
            if i == end:
                jumps += 1
                end = farthest
                if end >= n - 1: return jumps
        return -1


#{ 
 # Driver Code Starts
#Initial Template for Python 3
if __name__ == '__main__':
    T = int(input())
    for i in range(T):
        # n = int(input())
        Arr = [int(x) for x in input().split()]
        ob = Solution()
        ans = ob.minJumps(Arr)
        print(ans)
        print("~")
# } Driver Code Ends


================================================================================
Date: 2025-03-17
Problem: Subset Sum Problem
Filename: 2025-03-17_Subset_Sum_Problem.py
================================================================================

class Solution:
    def isSubsetSum(self, arr, sum):
        dp = [False] * (sum + 1)
        dp[0] = True
        for num in arr:
            for j in range(sum, num - 1, -1):
                dp[j] |= dp[j - num]
        return dp[sum]



#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        arr = input().split()
        N = len(arr)
        for itr in range(N):
            arr[itr] = int(arr[itr])
        sum = int(input())

        ob = Solution()
        if ob.isSubsetSum(arr, sum) == True:
            print("true")
        else:
            print("false")

        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-03-18
Problem: Partition Equal Subset Sum
Filename: 2025-03-18_Partition_Equal_Subset_Sum.py
================================================================================

class Solution:
    def equalPartition(self, arr):
        s = sum(arr)
        if s % 2: return False
        target, dp = s // 2, [False] * (s // 2 + 1)
        dp[0] = True
        for num in arr:
            for j in range(target, num - 1, -1):
                dp[j] |= dp[j - num]
        return dp[target]


#{ 
 # Driver Code Starts
import sys

input = sys.stdin.readline

if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        arr = list(map(int, input().strip().split()))

        ob = Solution()
        if ob.equalPartition(arr):
            print("true")
        else:
            print("false")
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-03-19
Problem: Stock Buy and Sell  Max K Transactions Allowed
Filename: 2025-03-19_Stock_Buy_and_Sell__Max_K_Transactions_Allowed.py
================================================================================

class Solution:
    def maxProfit(self, prices, k):
        n = len(prices)
        if n == 0 or k == 0:
            return 0
        if 2 * k >= n:
            return sum(max(0, prices[i] - prices[i - 1]) for i in range(1, n))
        dp = [-float('inf')] * (2 * k + 1)
        dp[0] = 0
        for price in prices:
            for j in range(1, 2 * k + 1):
                dp[j] = max(dp[j], dp[j - 1] - price) if j % 2 else max(dp[j], dp[j - 1] + price)
        return dp[2 * k]

#{ 
 # Driver Code Starts
from collections import deque

if __name__ == "__main__":
    tc = int(input())
    for _ in range(tc):
        arr = list(map(int, input().split()))
        k = int(input())
        obj = Solution()
        print(obj.maxProfit(arr, k))
        print("~")
# } Driver Code Ends


================================================================================
Date: 2025-03-20
Problem: Stock Buy and Sell  Max 2 Transactions Allowed
Filename: 2025-03-20_Stock_Buy_and_Sell__Max_2_Transactions_Allowed.py
================================================================================

class Solution:
    def maxProfit(self, a):
        b1, s1, b2, s2 = float('inf'), 0, float('inf'), 0
        for p in a:
            b1, s1, b2, s2 = min(b1, p), max(s1, p - b1), min(b2, p - s1), max(s2, p - b2)
        return s2

#{ 
 # Driver Code Starts
#Initial template for Python 3
import math


def main():
    t = int(input())
    while (t > 0):

        arr = [int(x) for x in input().strip().split()]
        obj = Solution()
        print(obj.maxProfit(arr))
        t -= 1
        print("~")


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2025-03-21
Problem: Stickler Thief
Filename: 2025-03-21_Stickler_Thief.py
================================================================================

class Solution:  
    def findMaxSum(self, arr):
        prev2 = prev1 = 0
        for num in arr:
            prev2, prev1 = prev1, max(prev1, prev2 + num)
        return prev1

#{ 
 # Driver Code Starts
import sys

sys.setrecursionlimit(10**6)

if __name__ == '__main__':
    test_cases = int(input())
    for cases in range(test_cases):

        a = list(map(int, input().strip().split()))
        ob = Solution()
        print(ob.findMaxSum(a))
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-03-22
Problem: Stickler Thief II
Filename: 2025-03-22_Stickler_Thief_II.py
================================================================================

class Solution:
    def maxValue(self, nums):
        if len(nums) == 1:
            return nums[0]

        def rob(l, r):
            prev2 = prev1 = 0
            for i in range(l, r + 1):
                prev2, prev1 = prev1, max(prev1, prev2 + nums[i])
            return prev1

        return max(rob(0, len(nums) - 2), rob(1, len(nums) - 1))


#{ 
 # Driver Code Starts
class IntArray:

    def __init__(self) -> None:
        pass

    def Input(self):
        arr = [int(i) for i in input().strip().split()]
        return arr

    def Print(self, arr):
        for i in arr:
            print(i, end=" ")
        print()


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        arr = IntArray().Input()

        obj = Solution()
        res = obj.maxValue(arr)

        print(res)
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-03-23
Problem: Total Decoding Messages
Filename: 2025-03-23_Total_Decoding_Messages.py
================================================================================

class Solution:
    def countWays(self, s: str) -> int:
        if s[0] == '0': return 0
        prev2, prev1 = 1, 1
        for i in range(1, len(s)):
            curr = prev1 if s[i] != '0' else 0
            if s[i - 1] != '0' and int(s[i - 1:i + 1]) <= 26:
                curr += prev2
            prev2, prev1 = prev1, curr
        return prev1


#{ 
 # Driver Code Starts
#Initial Template for Python 3

import sys

sys.setrecursionlimit(10**6)
if __name__ == '__main__':
    T = int(input())
    for i in range(T):
        digits = input()
        ob = Solution()
        ans = ob.countWays(digits)
        print(ans)
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-03-24
Problem: Matrix Chain Multiplication
Filename: 2025-03-24_Matrix_Chain_Multiplication.py
================================================================================


        
class Solution:
    def matrixMultiplication(self, arr):
        n, dp = len(arr), [[0] * len(arr) for _ in range(len(arr))]

        for l in range(2, n):
            for i in range(1, n - l + 1):
                j, dp[i][i + l - 1] = i + l - 1, float('inf')
                for k in range(i, j):
                    dp[i][j] = min(dp[i][j], arr[i - 1] * arr[k] * arr[j] + dp[i][k] + dp[k + 1][j])
        
        return dp[1][n - 1]




#{ 
 # Driver Code Starts
# Initial Template for Python 3

t = int(input())  # number of test cases
for _ in range(t):
    arr = list(map(int, input().split()))  # input array
    s = Solution().matrixMultiplication(arr)  # find the missing number
    print(s)  # print the result
    print("~")

# } Driver Code Ends


================================================================================
Date: 2025-03-25
Problem: Boolean Parenthesization
Filename: 2025-03-25_Boolean_Parenthesization.py
================================================================================

class Solution:
    def countWays(self, s):
        n = len(s)
        T, F = [[0] * n for _ in range(n)], [[0] * n for _ in range(n)]
        for i in range(0, n, 2): 
            T[i][i], F[i][i] = int(s[i] == 'T'), int(s[i] == 'F')
        for l in range(2, n, 2):
            for i in range(0, n - l, 2):
                for k, j in zip(range(i + 1, i + l, 2), [i + l] * (l // 2)):
                    lt, lf, rt, rf = T[i][k - 1], F[i][k - 1], T[k + 1][j], F[k + 1][j]
                    if s[k] == '&': 
                        T[i][j] += lt * rt
                        F[i][j] += lt * rf + lf * rt + lf * rf
                    elif s[k] == '|': 
                        T[i][j] += lt * rt + lt * rf + lf * rt
                        F[i][j] += lf * rf
                    else:  
                        T[i][j] += lt * rf + lf * rt
                        F[i][j] += lt * rt + lf * rf
        return T[0][n - 1]

#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    t = int(input())
    for i in range(t):
        s = input().strip()
        print(Solution().countWays(s))
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-03-26
Problem: Word Break
Filename: 2025-03-26_Word_Break.py
================================================================================

class Solution:
    def wordBreak(self, s, dictionary):
        d = set(dictionary)
        m = max((len(w) for w in dictionary), default=0)
        n = len(s)
        dp = [False] * (n + 1)
        dp[0] = True
        for i in range(n):
            if not dp[i]:
                continue
            for j in range(1, m + 1):
                if i + j <= n and s[i:i + j] in d:
                    dp[i + j] = True
        return dp[n]

#{ 
 # Driver Code Starts
if __name__ == '__main__':
    test_case = int(input())

    for _ in range(test_case):
        s = input().strip()
        dictionary = input().strip().split()
        ob = Solution()
        res = ob.wordBreak(s, dictionary)
        if res:
            print("true")
        else:
            print("false")
        print("~")
# } Driver Code Ends


================================================================================
Date: 2025-03-27
Problem: Minimum Platforms
Filename: 2025-03-27_Minimum_Platforms.py
================================================================================

class Solution:
    def minimumPlatform(self, arr, dep):
        arr.sort(); dep.sort()
        i = j = cnt = ans = 0
        n = len(arr)
        while i < n and j < n:
            if arr[i] <= dep[j]:
                cnt += 1; ans = max(ans, cnt); i += 1
            else:
                cnt -= 1; j += 1
        return ans
#{ 
 # Driver Code Starts
#Initial Template for Python 3
import atexit
import io
import sys

#Contributed by : Nagendra Jha

if __name__ == '__main__':
    test_cases = int(input())
    for cases in range(test_cases):
        arrival = list(map(int, input().strip().split()))
        departure = list(map(int, input().strip().split()))
        ob = Solution()
        print(ob.minimumPlatform(arrival, departure))
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-03-28
Problem: Activity Selection
Filename: 2025-03-28_Activity_Selection.py
================================================================================


class Solution:
    def activitySelection(self, start, finish):
        ans, finishtime = 0, -1
        for s, f in sorted(zip(start, finish), key=lambda x: x[1]):
            if s > finishtime: finishtime = f; ans += 1
        return ans

#{ 
 # Driver Code Starts
def main():
    t = int(input().strip())  # Number of test cases

    for _ in range(t):
        # Read the start times
        start = list(map(int, input().strip().split()))

        # Read the finish times
        finish = list(map(int, input().strip().split()))

        # Create solution object and call activitySelection
        obj = Solution()
        print(obj.activitySelection(start, finish))
        print("~")


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2025-03-29
Problem: Job Sequencing Problem
Filename: 2025-03-29_Job_Sequencing_Problem.py
================================================================================

from heapq import heappush, heappop

class Solution:
    def jobSequencing(self, d, p):
        jobs = sorted(zip(d, p))
        pq = []

        for deadline, profit in jobs:
            if len(pq) < deadline:
                heappush(pq, profit)
            elif pq and pq[0] < profit:
                heappop(pq)
                heappush(pq, profit)

        return [len(pq), sum(pq)]
#{ 
 # Driver Code Starts
#Initial Template for Python 3
import heapq

#Position this line where user code will be pasted.

if __name__ == "__main__":
    t = int(input().strip())

    for _ in range(t):
        deadline = list(map(int, input().strip().split()))
        profit = list(map(int, input().strip().split()))

        obj = Solution()
        ans = obj.jobSequencing(deadline, profit)
        print(ans[0], ans[1])
        print("~")
# } Driver Code Ends


================================================================================
Date: 2025-03-30
Problem: Gas Station
Filename: 2025-03-30_Gas_Station.py
================================================================================

class Solution:
    def startStation(self, gas, cost):
        total = curr = start = 0
        for i in range(len(gas)):
            diff = gas[i] - cost[i]
            total += diff
            curr += diff
            if curr < 0: start, curr = i + 1, 0
        return start if total >= 0 else -1



#{ 
 # Driver Code Starts
#Initial Template for Python 3
import io
import sys

if __name__ == '__main__':
    test_cases = int(input())
    for cases in range(test_cases):
        gas = list(map(int, input().strip().split()))
        cost = list(map(int, input().strip().split()))
        ob = Solution()
        ans = ob.startStation(gas, cost)
        print(ans)
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-03-31
Problem: Maximize partitions in a String
Filename: 2025-03-31_Maximize_partitions_in_a_String.py
================================================================================

class Solution:
    def maxPartitions(self, s: str) -> int:
        last = {c: i for i, c in enumerate(s)}
        count = end = 0
        for i, c in enumerate(s):
            end = max(end, last[c])
            if i == end:
                count += 1
        return count


#{ 
 # Driver Code Starts
if __name__ == '__main__':
    tc = int(input())

    for _ in range(tc):
        s = input()
        obj = Solution()
        print(obj.maxPartitions(s))
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-04-01
Problem: DFS of Graph
Filename: 2025-04-01_DFS_of_Graph.py
================================================================================

#User function Template for python3

class Solution:
    def dfs(self, adj):
        r, v = [], [False] * len(adj)
        def go(i):
            v[i] = True
            r.append(i)
            for j in adj[i]:
                if not v[j]:
                    go(j)
        for i in range(len(adj)):
            if not v[i]:
                go(i)
        return r


#{ 
 # Driver Code Starts
import sys
#Position this line where user code will be pasted.


def main():
    tc = int(sys.stdin.readline().strip())

    for _ in range(tc):
        V = int(sys.stdin.readline().strip())
        adj = []

        for _ in range(V):
            input_line = sys.stdin.readline().strip()
            node = list(map(int, input_line.split())) if input_line else []
            adj.append(node)

        obj = Solution()
        ans = obj.dfs(adj)
        print(" ".join(map(str, ans)))
        print("~")


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2025-04-02
Problem: BFS of graph
Filename: 2025-04-02_BFS_of_graph.py
================================================================================

#User function Template for python3
from collections import deque

class Solution:
    def bfs(self, adj):
        r, v = [], [False] * len(adj)
        q = deque([0])
        v[0] = True
        while q:
            i = q.popleft()
            r.append(i)
            for j in adj[i]:
                if not v[j]:
                    v[j] = True
                    q.append(j)
        return r
        
 # Driver Code Starts
import sys


#Position this line where user code will be pasted.
def main():
    tc = int(sys.stdin.readline().strip())

    for _ in range(tc):
        V = int(sys.stdin.readline().strip())  # Number of vertices
        adj = []  # Adjacency list

        for _ in range(V):
            input_line = sys.stdin.readline().strip()
            node = list(map(int, input_line.split())) if input_line else []
            adj.append(node)

        obj = Solution()
        ans = obj.bfs(adj)
        print(" ".join(map(str, ans)))
        print("~")


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2025-04-03
Problem: Rotten Oranges
Filename: 2025-04-03_Rotten_Oranges.py
================================================================================

from collections import deque
class Solution:
    def orangesRotting(self, a):
        n, m, f, t = len(a), len(a[0]), 0, 0
        q = deque()
        for i in range(n):
            for j in range(m):
                if a[i][j] == 2:
                    q.append((i, j))
                elif a[i][j] == 1:
                    f += 1
        if not f: return 0
        d = [(1,0),(-1,0),(0,1),(0,-1)]
        while q:
            sz, ch = len(q), False
            for _ in range(sz):
                i, j = q.popleft()
                for di, dj in d:
                    x, y = i + di, j + dj
                    if x < 0 or y < 0 or x >= n or y >= m or a[x][y] != 1:
                        continue
                    a[x][y] = 2
                    q.append((x, y))
                    f -= 1
                    ch = True
            if ch: t += 1
        return t if f == 0 else -1

#{ 
 # Driver Code Starts
from queue import Queue

T = int(input())
for i in range(T):
    n = int(input())
    m = int(input())
    mat = []
    for _ in range(n):
        a = list(map(int, input().split()))
        mat.append(a)
    obj = Solution()
    ans = obj.orangesRotting(mat)
    print(ans)
    print("~")

# } Driver Code Ends


================================================================================
Date: 2025-04-04
Problem: Undirected Graph Cycle
Filename: 2025-04-04_Undirected_Graph_Cycle.py
================================================================================

class Solution:
    def isCycle(self, V, edges):
        p = [-1]*V
        def f(x): return x if p[x]<0 else f(p[x])
        for u,v in edges:
            a, b = f(u), f(v)
            if a == b: return True
            if p[a] > p[b]: a,b = b,a
            p[a] += p[b]; p[b] = a
        return False

#{ 
 # Driver Code Starts
import sys
#Position this line where user code will be pasted.


def main():
    tc = int(input())
    for _ in range(tc):
        V = int(input())
        E = int(input())
        edges = []
        for _ in range(E):
            u, v = map(int, input().split())
            edges.append((u, v))

        obj = Solution()
        ans = obj.isCycle(V, edges)
        print("true" if ans else "false")
        print("~")


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2025-04-05
Problem: Find the number of islands
Filename: 2025-04-05_Find_the_number_of_islands.py
================================================================================

class Solution:
    def numIslands(self, g):
        n, m, ans = len(g), len(g[0]), 0
        def dfs(i, j):
            if i < 0 or j < 0 or i >= n or j >= m or g[i][j]=='W': return
            g[i][j] = 'W'
            for a in (-1,0,1):
                for b in (-1,0,1):
                    dfs(i+a, j+b)
        for i in range(n):
            for j in range(m):
                if g[i][j]=='L':
                    ans += 1
                    dfs(i, j)
        return ans

#{ 
 # Driver Code Starts
# Driver code
if __name__ == "__main__":
    for _ in range(int(input())):
        n = int(input().strip())
        m = int(input().strip())
        grid = [input().strip().split() for _ in range(n)]

        obj = Solution()
        print(obj.numIslands(grid))
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-04-06
Problem: Topological sort
Filename: 2025-04-06_Topological_sort.py
================================================================================


from collections import deque

class Solution:
    def topoSort(self, V, edges):
        g = [[] for _ in range(V)]
        in_deg = [0] * V
        res = []
        for u, v in edges:
            g[u].append(v)
            in_deg[v] += 1
        q = deque(i for i in range(V) if in_deg[i] == 0)
        while q:
            u = q.popleft()
            res.append(u)
            for v in g[u]:
                in_deg[v] -= 1
                if in_deg[v] == 0:
                    q.append(v)
        return res

#{ 
 # Driver Code Starts
# Driver Program

import sys

sys.setrecursionlimit(10**6)


def check(graph, N, res):
    if N != len(res):
        return False
    map = [0] * N
    for i in range(N):
        map[res[i]] = i
    for i in range(N):
        for v in graph[i]:
            if map[i] > map[v]:
                return False
    return True


def main():
    tc = int(input())
    for _ in range(tc):
        V = int(input())
        E = int(input())
        edges = []
        adj = [[] for i in range(V)]
        for _ in range(E):
            u, v = map(int, input().split())
            edges.append((u, v))
            adj[u].append(v)

        obj = Solution()
        res = obj.topoSort(V, edges)

        if check(adj, V, res):
            print("true")
        else:
            print("false")
        print("~")


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2025-04-07
Problem: Directed Graph Cycle
Filename: 2025-04-07_Directed_Graph_Cycle.py
================================================================================

class Solution:
    def isCycle(self, V, edges):
        g = [[] for _ in range(V)]
        in_d = [0]*V
        for u, v in edges: g[u].append(v); in_d[v] += 1
        q = [i for i in range(V) if in_d[i] == 0]
        c = 0
        while q:
            u = q.pop(0); c += 1
            for v in g[u]:
                in_d[v] -= 1
                if in_d[v] == 0: q.append(v)
        return c != V


#{ 
 # Driver Code Starts
from collections import deque


def main():
    tc = int(input())
    for _ in range(tc):
        V = int(input())
        E = int(input())
        edges = []
        for _ in range(E):
            u, v = map(int, input().split())
            edges.append((u, v))

        obj = Solution()
        ans = obj.isCycle(V, edges)
        print("true" if ans else "false")


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2025-04-08
Problem: Bridge edge in a graph
Filename: 2025-04-08_Bridge_edge_in_a_graph.py
================================================================================

class Solution:
    def dfs(self, g, vis, u):
        vis[u] = 1
        for v in g[u]:
            if not vis[v]: self.dfs(g, vis, v)

    def isBridge(self, V, edges, c, d):
        g = [[] for _ in range(V)]
        for u, v in edges:
            if (u, v) != (c, d) and (v, u) != (c, d):
                g[u].append(v)
                g[v].append(u)
        vis = [0] * V
        self.dfs(g, vis, c)
        return not vis[d]



#{ 
 # Driver Code Starts
import sys

sys.setrecursionlimit(10**7)
if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        V = int(input())
        E = int(input())
        adj = [[] for _ in range(V)]
        edges = []

        for _ in range(E):
            u, v = map(int, input().split())
            adj[u].append(v)
            adj[v].append(u)
            edges.append([u, v])

        c = int(input())
        d = int(input())

        obj = Solution()
        l = obj.isBridge(V, edges, c, d)

        if l:
            print("true")
        else:
            print("false")

        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-04-09
Problem: Articulation Point - II
Filename: 2025-04-09_Articulation_Point_-_II.py
================================================================================

class Solution:
    def articulationPoints(self, V, edges):
        adj = [[] for _ in range(V)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        disc = [-1] * V
        low = [-1] * V
        vis = [False] * V
        ap = [False] * V
        time = [0]

        def dfs(u, p):
            vis[u] = True
            disc[u] = low[u] = time[0] = time[0] + 1
            children = 0
            for v in adj[u]:
                if not vis[v]:
                    children += 1
                    dfs(v, u)
                    low[u] = min(low[u], low[v])
                    if p != -1 and low[v] >= disc[u]:
                        ap[u] = True
                elif v != p:
                    low[u] = min(low[u], disc[v])
            if p == -1 and children > 1:
                ap[u] = True

        for i in range(V):
            if not vis[i]:
                dfs(i, -1)
        res = [i for i, val in enumerate(ap) if val]
        return res if res else [-1]


#{ 
 # Driver Code Starts
import sys

sys.setrecursionlimit(int(1e7))


def main():
    tc = int(input())
    for _ in range(tc):
        V = int(input())
        E = int(input())
        edges = []
        for _ in range(E):
            u, v = map(int, input().split())
            edges.append([u, v])
        obj = Solution()
        ans = obj.articulationPoints(V, edges)
        ans.sort()
        print(" ".join(map(str, ans)))
        print("~")


if __name__ == "__main__":
    main()
# } Driver Code Ends


================================================================================
Date: 2025-04-10
Problem: Minimum cost to connect all houses in a city
Filename: 2025-04-10_Minimum_cost_to_connect_all_houses_in_a_city.py
================================================================================

class Solution:
    def minCost(self, a):
        n, ans = len(a), 0
        vis = [0]*n
        d = [float('inf')]*n
        d[0] = 0
        for _ in range(n):
            m, u = float('inf'), -1
            for i in range(n):
                if not vis[i] and d[i] < m:
                    m, u = d[i], i
            vis[u] = 1
            ans += m
            for v in range(n):
                if not vis[v]:
                    d[v] = min(d[v], abs(a[u][0] - a[v][0]) + abs(a[u][1] - a[v][1]))
        return ans


#{ 
 # Driver Code Starts
#Initial Template for Python 3
#Position this line where user code will be pasted.

if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        n = int(input())
        edges = []

        for _ in range(n):
            temp = list(map(int, input().split()))
            edges.append(temp)

        obj = Solution()
        print(obj.minCost(edges))
        print("~")
# } Driver Code Ends


================================================================================
Date: 2025-04-11
Problem: Dijkstra Algorithm
Filename: 2025-04-11_Dijkstra_Algorithm.py
================================================================================

class Solution:
    def dijkstra(self, V, edges, src):
        from heapq import heappush, heappop
        g = [[] for _ in range(V)]
        for u, v, w in edges:
            g[u].append((v, w))
        d = [float('inf')] * V
        d[src] = 0
        q = [(0, src)]
        while q:
            du, u = heappop(q)
            if du > d[u]: continue
            for v, w in g[u]:
                if du + w < d[v]:
                    d[v] = du + w
                    heappush(q, (d[v], v))
        return d



#{ 
 # Driver Code Starts
# Initial Template for Python 3
import sys
import heapq

# Position this line where user code will be pasted.


def main():
    t = int(input())
    for _ in range(t):
        V = int(input())
        E = int(input())
        edges = []
        for _ in range(E):
            u, v, w = map(int, input().split())
            edges.append([u, v, w])
            edges.append([v, u, w])  # Since the graph is undirected

        src = int(input())

        obj = Solution()
        res = obj.dijkstra(V, edges, src)

        print(" ".join(map(str, res)))
        print("~")


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2025-04-12
Problem: Flood fill Algorithm
Filename: 2025-04-12_Flood_fill_Algorithm.py
================================================================================

class Solution:
    def floodFill(self, A, sr, sc, nc):
        m, n, oc = len(A), len(A[0]), A[sr][sc]
        if oc == nc: return A
        q = [(sr, sc)]
        A[sr][sc] = nc
        d = [-1, 0, 1, 0, -1]
        while q:
            x, y = q.pop(0)
            for i in range(4):
                nx, ny = x + d[i], y + d[i+1]
                if 0 <= nx < m and 0 <= ny < n and A[nx][ny] == oc:
                    A[nx][ny] = nc
                    q.append((nx, ny))
        return A



#{ 
 # Driver Code Starts
import sys

sys.setrecursionlimit(10**7)

T = int(input())  # Read number of test cases
for i in range(T):
    n = int(input())
    m = int(input())

    # Reading the image matrix
    image = []
    for _ in range(n):
        image.append(list(map(int, input().split())))

    # Read starting row, column, and new color
    sr = int(input())
    sc = int(input())
    newColor = int(input())

    # Create an instance of the Solution class and apply floodFill
    obj = Solution()
    ans = obj.floodFill(image, sr, sc, newColor)

    for row in ans:
        print(" ".join(map(str, row)))
    print("~")

# } Driver Code Ends


================================================================================
Date: 2025-04-13
Problem: Clone an Undirected Graph
Filename: 2025-04-13_Clone_an_Undirected_Graph.py
================================================================================

#User function Template for python3

'''
class Node:
    def __init__(self, val = 0, neighbors = []):
        self.val = val
        self.neighbors = neighbors
'''

class Solution:
    def cloneGraph(self, node):
        if not node: return None
        m, q = {node: Node(node.val)}, [node]
        while q:
            for n in q[0].neighbors:
                if n not in m:
                    m[n] = Node(n.val)
                    q.append(n)
                m[q[0]].neighbors.append(m[n])
            q.pop(0)
        return m[node]


#{ 
 # Driver Code Starts
#Initial Template for Python 3

from queue import Queue
import sys

sys.setrecursionlimit(10**6)


class Node:

    def __init__(self, val=0, neighbors=None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []


def compare(prev, new, prev_vis=set(), new_vis=set()):
    if prev == new:
        return False
    if not prev or not new:
        if (not prev and new) or (prev and not new):
            return False
        return True

    if prev in prev_vis or new in new_vis:
        if (prev in prev_vis and new not in new_vis) or (prev not in prev_vis
                                                         and new in new_vis):
            return False
        return True
    prev_vis.add(prev)
    new_vis.add(new)

    if prev.val != new.val:
        return False

    prev_n = len(prev.neighbors)
    new_n = len(prev.neighbors)
    if prev_n != new_n:
        return False

    prev.neighbors.sort(key=lambda x: x.val)
    new.neighbors.sort(key=lambda x: x.val)
    for i in range(prev_n):
        if not compare(prev.neighbors[i], new.neighbors[i], prev_vis, new_vis):
            return False

    return True


if __name__ == "__main__":
    for _ in range(int(input())):
        N = int(input())
        v = [Node(i) for i in range(N)]
        for i in range(N):
            v[i].neighbors = [v[int(i)] for i in input().split()]
        ob = Solution()
        ans = ob.cloneGraph(v[0])
        # if ans == v[0]:
        #     print(0)
        print("true" if compare(v[0], ans) else "false")
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-04-14
Problem: Alien Dictionary
Filename: 2025-04-14_Alien_Dictionary.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3
import sys


# } Driver Code Ends

class Solution:
    @staticmethod
    def findOrder(words):
        from collections import deque, defaultdict
        g = defaultdict(list)
        in_deg = [0] * 26
        seen = [0] * 26
        for w in words:
            for c in w:
                seen[ord(c) - 97] = 1
        for i in range(len(words) - 1):
            a, b = words[i], words[i + 1]
            j, n = 0, min(len(a), len(b))
            while j < n and a[j] == b[j]: j += 1
            if j == n and len(a) > len(b): return ""
            if j < n:
                u, v = ord(a[j]) - 97, ord(b[j]) - 97
                g[u].append(v)
                in_deg[v] += 1
        q = deque(i for i in range(26) if seen[i] and in_deg[i] == 0)
        res = []
        while q:
            u = q.popleft()
            res.append(chr(u + 97))
            for v in g[u]:
                in_deg[v] -= 1
                if in_deg[v] == 0: q.append(v)
        return "".join(res) if sum(seen) == len(res) else ""

#{ 
 # Driver Code Starts.

def validate(original, order):
    char_map = {}
    for word in original:
        for ch in word:
            char_map[ch] = 1

    for ch in order:
        if ch not in char_map:
            return False
        del char_map[ch]

    if char_map:
        return False

    char_index = {ch: i for i, ch in enumerate(order)}

    for i in range(len(original) - 1):
        a, b = original[i], original[i + 1]
        k, n, m = 0, len(a), len(b)
        while k < n and k < m and a[k] == b[k]:
            k += 1
        if k < n and k < m and char_index[a[k]] > char_index[b[k]]:
            return False
        if k != n and k == m:
            return False

    return True

if __name__ == "__main__":
    input_data = sys.stdin.read().strip().split("\n")
    index = 0
    t = int(input_data[index])
    index += 1
    while t > 0:
        words = input_data[index].split()
        index += 1
        original = words[:]

        order = Solution.findOrder(words)

        if order == "":
            print("\"\"")
        else:
            print("true" if validate(original, order) else "false")
        print("~")
        t -= 1

# } Driver Code Ends


================================================================================
Date: 2025-04-15
Problem: Bellman-Ford
Filename: 2025-04-15_Bellman-Ford.py
================================================================================

class Solution:
    def bellmanFord(self, V, edges, src):
        dist = [int(1e8)] * V
        dist[src] = 0
        for _ in range(V - 1):
            for u, v, w in edges:
                if dist[u] < 1e8 and dist[u] + w < dist[v]:
                    dist[v] = dist[u] + w
        for u, v, w in edges:
            if dist[u] < 1e8 and dist[u] + w < dist[v]:
                return [-1]
        return dist


#{ 
 # Driver Code Starts
#Initial Template for Python 3
import atexit
import io
import sys

if __name__ == '__main__':
    test_cases = int(input())
    for cases in range(test_cases):
        V = int(input())
        E = int(input())
        edges = []
        for i in range(E):
            u, v, w = map(int, input().strip().split())
            edges.append([u, v, w])
        S = int(input())
        ob = Solution()

        res = ob.bellmanFord(V, edges, S)
        for i in res:
            print(i, end=" ")
        print()
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-04-16
Problem: Floyd Warshall
Filename: 2025-04-16_Floyd_Warshall.py
================================================================================

class Solution:
    def floydWarshall(self, d):
        n, inf = len(d), 100000000
        for k in range(n):
            for i in range(n):
                for j in range(n):
                    if d[i][k] < inf and d[k][j] < inf and d[i][j] > d[i][k] + d[k][j]:
                        d[i][j] = d[i][k] + d[k][j]


#{ 
 # Driver Code Starts
#Initial template for Python

if __name__ == '__main__':
    T = int(input())
    for i in range(T):
        n = int(input())
        matrix = []
        for _ in range(n):
            matrix.append(list(map(int, input().split())))
        obj = Solution()
        obj.floydWarshall(matrix)
        for _ in range(n):
            for __ in range(n):
                print(matrix[_][__], end=" ")
            print()
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-04-17
Problem: Minimum Weight Cycle
Filename: 2025-04-17_Minimum_Weight_Cycle.py
================================================================================

class Solution:
    def findMinCycle(self, V, edges):
        from heapq import heappush, heappop
        A = [[] for _ in range(V)]
        for u, v, w in edges:
            A[u].append((v, w))
        r = float('inf')
        for i in range(V):
            D = [int(1e9)] * V
            P = [-1] * V
            D[i] = 0
            Q = [(0, i)]
            while Q:
                d, u = heappop(Q)
                for v, w in A[u]:
                    if D[v] > d + w:
                        D[v] = d + w
                        P[v] = u
                        heappush(Q, (D[v], v))
                    elif P[u] != v and P[v] != u:
                        r = min(r, D[u] + D[v] + w)
        return -1 if r == float('inf') else r


        



#{ 
 # Driver Code Starts
# Initial Template for Python 3
import sys
import heapq

# Position this line where user code will be pasted.


def main():
    t = int(input())
    for _ in range(t):
        V = int(input())
        E = int(input())
        edges = []
        for _ in range(E):
            u, v, w = map(int, input().split())
            edges.append([u, v, w])
            edges.append([v, u, w])  # Since the graph is undirected

        obj = Solution()
        res = obj.findMinCycle(V, edges)

        print(res)


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2025-04-18
Problem: Implement Trie
Filename: 2025-04-18_Implement_Trie.py
================================================================================

class Trie:
    class N:
        def __init__(self): self.c, self.e = [None]*26, 0
    def __init__(self): self.r = self.N()
    def insert(self, w):
        n = self.r
        for ch in w:
            i = ord(ch)-97
            n.c[i] = n.c[i] or self.N()
            n = n.c[i]
        n.e = 1
    def search(self, w):
        n = self.r
        for ch in w:
            i = ord(ch)-97
            if not n.c[i]: return 0
            n = n.c[i]
        return n.e
    def isPrefix(self, w):
        n = self.r
        for ch in w:
            i = ord(ch)-97
            if not n.c[i]: return 0
            n = n.c[i]
        return 1


#{ 
 # Driver Code Starts
def main():
    t = int(input())
    for _ in range(t):
        q = int(input())
        ans = []
        trie = Trie()

        for _ in range(q):
            x, s = input().split()
            x = int(x)

            if x == 1:
                trie.insert(s)
            elif x == 2:
                ans.append(trie.search(s))
            elif x == 3:
                ans.append(trie.isPrefix(s))

        # Print results as lowercase true/false
        print(" ".join(["true" if res else "false" for res in ans]))
        print("~")


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2025-04-19
Problem: Maximum XOR of two numbers in an array
Filename: 2025-04-19_Maximum_XOR_of_two_numbers_in_an_array.py
================================================================================

class Solution:
    def maxXor(self, arr):
        class TrieNode:
            __slots__ = ['children']
            def __init__(self):
                self.children = [None, None]
        
        root = TrieNode()
        
        for num in arr:
            node = root
            for i in range(31, -1, -1):
                bit = (num >> i) & 1
                if not node.children[bit]:
                    node.children[bit] = TrieNode()
                node = node.children[bit]
        
        max_xor = 0
        for num in arr:
            node = root
            current_xor = 0
            for i in range(31, -1, -1):
                bit = (num >> i) & 1
                desired_bit = 1 - bit
                if node.children[desired_bit]:
                    current_xor |= (1 << i)
                    node = node.children[desired_bit]
                else:
                    node = node.children[bit]
            max_xor = max(max_xor, current_xor)
        return max_xor

2)
class Solution:
    def maxXor(self, nums):
        max_xor, mask = 0, 0
        for i in range(30, -1, -1):
            mask |= (1 << i)
            prefixes = set(num & mask for num in nums)
            candidate = max_xor | (1 << i)
            if any((candidate ^ p) in prefixes for p in prefixes):
                max_xor = candidate
        return max_xor

3)
class Solution:
    def maxXor(self, arr):
        max_xor, mask = 0, 0
        for i in range(30, -1, -1):
            mask |= (1 << i)
            prefixes = set()
            temp = max_xor | (1 << i)
            found = False
            for num in arr:
                prefix = num & mask
                if (temp ^ prefix) in prefixes:
                    found = True
                    break
                prefixes.add(prefix)
            if found:
                max_xor = temp
        return max_xor
#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    T = int(input())
    for i in range(T):
        n = int(input())
        arr = list(map(int, input().split()))
        ob = Solution()
        print(ob.maxXor(arr))
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-04-20
Problem: Find Only Repetitive Element from 1 to n-1
Filename: 2025-04-20_Find_Only_Repetitive_Element_from_1_to_n-1.py
================================================================================

class Solution:
    def findDuplicate(self, a):
        s = f = a[0]
        while True:
            s = a[s]
            f = a[a[f]]
            if s == f: break
        f = a[0]
        while s != f:
            s = a[s]
            f = a[f]
        return s


#{ 
 # Driver Code Starts
# Initial Template for Python 3

if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        arr = list(map(int, input().strip().split()))

        ob = Solution()
        print(ob.findDuplicate(arr))
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-04-21
Problem: Missing in Array
Filename: 2025-04-21_Missing_in_Array.py
================================================================================

class Solution:
    def missingNum(self, a):
        x, n = 0, len(a)
        for i in range(n): x ^= a[i] ^ (i + 1)
        return x ^ (n + 1)


2)
class Solution:
    def missingNum(self, arr):
        x = 0
        for i, v in enumerate(arr):
            x ^= v ^ (i + 1)
        return x ^ (len(arr) + 1)

#{ 
 # Driver Code Starts
#Initial Template for Python 3

t = int(input())
for _ in range(0, t):
    arr = list(map(int, input().split()))
    s = Solution().missingNum(arr)
    print(s)

    print("~")
# } Driver Code Ends


================================================================================
Date: 2025-04-22
Problem: Unique Number I
Filename: 2025-04-22_Unique_Number_I.py
================================================================================

class Solution:
    def findUnique(self, arr):
        r = 0
        for x in arr: r ^= x
        return r

#{ 
 # Driver Code Starts
# Initial Template for Python 3

if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        arr = list(map(int, input().split()))
        ob = Solution()
        ans = ob.findUnique(arr)
        print(ans)
        print("~")
# } Driver Code Ends


================================================================================
Date: 2025-04-23
Problem: Unique Number II
Filename: 2025-04-23_Unique_Number_II.py
================================================================================

class Solution:
    def singleNum(self, arr):
        x = 0
        for n in arr: x ^= n
        a = b = 0
        for n in arr:
            (a, b) = (a ^ n, b) if n & (x & -x) else (a, b ^ n)
        return [a, b] if a < b else [b, a]


#{ 
 # Driver Code Starts
#Initial Template for Python 3
if __name__ == '__main__':
    tc = int(input())
    while tc > 0:
        arr = list(map(int, input().strip().split()))

        ob = Solution()
        ans = ob.singleNum(arr)

        print(" ".join(map(str, ans)))
        tc -= 1
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-04-24
Problem: Unique Number III
Filename: 2025-04-24_Unique_Number_III.py
================================================================================

class Solution:
    def getSingle(self, arr):
        ones = twos = 0
        for num in arr:
            ones = (ones ^ num) & ~twos
            twos = (twos ^ num) & ~ones
        return ones



#{ 
 # Driver Code Starts
# Initial Template for Python 3

if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        arr = list(map(int, input().split()))
        ob = Solution()
        ans = ob.getSingle(arr)
        print(ans)
        print("~")
# } Driver Code Ends


================================================================================
Date: 2025-04-25
Problem: Majority Element
Filename: 2025-04-25_Majority_Element.py
================================================================================

#User function template for Python 3

class Solution:
    def majorityElement(self, a):
        count = cand = 0
        for v in a:
            if not count:
                cand = v
            count += 1 if v == cand else -1
        return cand if sum(1 for v in a if v == cand) > len(a)//2 else -1
#{ 
 # Driver Code Starts
#Initial Template for Python 3

import math
from sys import stdin


def main():
    t = int(input())
    while (t > 0):

        arr = [int(x) for x in input().strip().split()]

        obj = Solution()
        print(obj.majorityElement(arr))
        print("~")
        t -= 1


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2025-04-26
Problem: Is Binary Tree Heap
Filename: 2025-04-26_Is_Binary_Tree_Heap.py
================================================================================

#User Template for python3

'''
class Node:
    def __init__(self,val):
        self.data = val
        self.left = None
        self.right = None
'''

class Solution:
    def c(self, r):
        return 1 + self.c(r.left) + self.c(r.right) if r else 0
    def p(self, r, i, n):
        return (not r) or (
            i < n
            and (not r.left  or r.data >= r.left.data)
            and (not r.right or r.data >= r.right.data)
            and self.p(r.left,  2*i+1, n)
            and self.p(r.right, 2*i+2, n)
        )
    def isHeap(self, root):
        return self.p(root, 0, self.c(root))
#{ 
 # Driver Code Starts
#Initial Template for Python 3

#Contributed by Susanta Mukherjee
import sys

sys.setrecursionlimit(10**6)
from collections import deque


# Tree Node
class Node:

    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None


# Function to Build Tree
def buildTree(s):
    #Corner Case
    if (len(s) == 0 or s[0] == "N"):
        return None

    # Creating list of strings from input
    # string after spliting by space
    ip = list(map(str, s.split()))

    # Create the root of the tree
    root = Node(int(ip[0]))
    size = 0
    q = deque()

    # Push the root to the queue
    q.append(root)
    size = size + 1

    # Starting from the second element
    i = 1
    while (size > 0 and i < len(ip)):
        # Get and remove the front of the queue
        currNode = q[0]
        q.popleft()
        size = size - 1

        # Get the current node's value from the string
        currVal = ip[i]

        # If the left child is not null
        if (currVal != "N"):

            # Create the left child for the current node
            currNode.left = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.left)
            size = size + 1
        # For the right child
        i = i + 1
        if (i >= len(ip)):
            break
        currVal = ip[i]

        # If the right child is not null
        if (currVal != "N"):

            # Create the right child for the current node
            currNode.right = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.right)
            size = size + 1
        i = i + 1
    return root


if __name__ == "__main__":
    t = int(input())
    for _ in range(0, t):
        root = buildTree(input())
        ob = Solution()
        if ob.isHeap(root):
            print("true")
        else:
            print("false")

        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-04-27
Problem: Multiply two strings
Filename: 2025-04-27_Multiply_two_strings.py
================================================================================

class Solution:
    def multiplyStrings(self, s1, s2):
        sign=-1 if (s1[0]=='-')^(s2[0]=='-') else 1
        if s1[0]=='-': s1=s1[1:]
        if s2[0]=='-': s2=s2[1:]
        s1=s1.lstrip('0'); s2=s2.lstrip('0')
        if not s1 or not s2: return "0"
        n,m=len(s1),len(s2); r=[0]*(n+m)
        for i in range(n-1,-1,-1):
            for j in range(m-1,-1,-1):
                r[i+j+1]+=int(s1[i])*int(s2[j])
        for i in range(n+m-1,0,-1):
            r[i-1]+=r[i]//10; r[i]%=10
        i=0
        while i<len(r) and r[i]==0: i+=1
        ans=''.join(str(x) for x in r[i:])
        return "-"+ans if sign<0 else ans



#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == "__main__":
    t = int(input())
    for i in range(t):
        a = input()
        b = input()
        print(Solution().multiplyStrings(a.strip(), b.strip()))

        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-04-28
Problem: Maximum sum of Non-adjacent nodes
Filename: 2025-04-28_Maximum_sum_of_Non-adjacent_nodes.py
================================================================================

#User function Template for python3

'''
# Node Class:
class Node:
    def __init__(self,val):
        self.data = val
        self.left = None
        self.right = None
'''

# class Solution:
#     def f(self,r):
#         if not r: return (0,0)
#         l,rgt=self.f(r.left),self.f(r.right)
#         return (r.data+l[1]+rgt[1],max(l)+max(rgt))
#     def getMaxSum(self,root):
#         return max(self.f(root))


class Solution:
    def solve(self,r):
        if not r: return (0,0)
        l,r1=self.solve(r.left),self.solve(r.right)
        return (r.data+l[1]+r1[1],max(l)+max(r1))
    def getMaxSum(self,root):
        return max(self.solve(root))

#{ 
 # Driver Code Starts
#Initial Template for Python 3

#contributed by RavinderSinghPB
import sys
from collections import defaultdict
from collections import deque

sys.setrecursionlimit(10**6)


class Node:

    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None


# Function to Build Tree
def buildTree(s):
    #Corner Case
    if (len(s) == 0 or s[0] == "N"):
        return None

    # Creating list of strings from input
    # string after spliting by space
    ip = list(map(str, s.split()))

    # Create the root of the tree
    root = Node(int(ip[0]))
    size = 0
    q = deque()

    # Push the root to the queue
    q.append(root)
    size = size + 1

    # Starting from the second element
    i = 1
    while (size > 0 and i < len(ip)):
        # Get and remove the front of the queue
        currNode = q[0]
        q.popleft()
        size = size - 1

        # Get the current node's value from the string
        currVal = ip[i]

        # If the left child is not null
        if (currVal != "N"):

            # Create the left child for the current node
            currNode.left = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.left)
            size = size + 1
        # For the right child
        i = i + 1
        if (i >= len(ip)):
            break
        currVal = ip[i]

        # If the right child is not null
        if (currVal != "N"):

            # Create the right child for the current node
            currNode.right = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.right)
            size = size + 1
        i = i + 1
    return root


if __name__ == '__main__':
    t = int(input())
    for _ in range(0, t):
        s = input()
        root = buildTree(s)
        ob = Solution()
        print(ob.getMaxSum(root))

        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-04-29
Problem: Sort a linked list of 0s 1s and 2s
Filename: 2025-04-29_Sort_a_linked_list_of_0s_1s_and_2s.py
================================================================================

'''
	Function Arguments: head of the original list.
	Return Type: head of the new list formed.
	{
		# Node Class
		class Node:
		    def __init__(self, data):   # data -> value stored in node
		        self.data = data
		        self.next = None
	}'''
	
class Solution:
    def segregate(self, head):
        count = [0, 0, 0]
        curr = head
        while curr:
            count[curr.data] += 1
            curr = curr.next
        curr = head
        for i in range(3):
            while count[i]:
                curr.data = i
                curr = curr.next
                count[i] -= 1
        return head

#{ 
 # Driver Code Starts
# Initial Template for Python 3


class Node:

    def __init__(self, data):
        self.data = data
        self.next = None


def printList(node):
    while node:
        print(node.data, end=" ")
        node = node.next
    print()


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        arr = list(map(int, input().strip().split()))
        head = None
        if arr:
            head = Node(arr[0])
            tail = head
            for value in arr[1:]:
                tail.next = Node(value)
                tail = tail.next

        printList(Solution().segregate(head))
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-04-30
Problem: Find length of Loop
Filename: 2025-04-30_Find_length_of_Loop.py
================================================================================

#User function Template for python3

'''
# Node Class
class Node:
    def __init__(self, data):   # data -> value stored in node
        self.data = data
        self.next = None
'''
class Solution:
    def countNodesInLoop(self, head):
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                c = 1
                while (fast := fast.next) != slow:
                    c += 1
                return c
        return 0

#{ 
 # Driver Code Starts
import sys


class Node:

    def __init__(self, data):
        self.data = data
        self.next = None


def print_list(node):
    while node:
        print(node.data, end=' ')
        node = node.next
    print()


def loop_here(head, pos):
    if pos == 0:
        return

    walk = head
    for _ in range(1, pos):
        walk = walk.next

    tail = head
    while tail.next:
        tail = tail.next

    tail.next = walk


if __name__ == "__main__":
    input = sys.stdin.read
    data = input().split('\n')
    t = int(data[0])
    index = 1
    for _ in range(t):
        arr = list(map(int, data[index].split()))
        k = int(data[index + 1])
        head = Node(arr[0])
        tail = head
        for value in arr[1:]:
            tail.next = Node(value)
            tail = tail.next
        loop_here(head, k)
        ob = Solution()
        res = ob.countNodesInLoop(head)
        print(res)
        print("~")
        index += 2

# } Driver Code Ends


================================================================================
Date: 2025-05-01
Problem: Pascal Triangle
Filename: 2025-05-01_Pascal_Triangle.py
================================================================================

class Solution:
    def nthRowOfPascalTriangle(self, n):
        row, v = [], 1
        for i in range(n):
            row.append(v)
            v = v * (n-1-i) // (i+1)
        return row


#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':

    tc = int(input())
    while tc > 0:
        n = int(input())
        ob = Solution()
        ans = ob.nthRowOfPascalTriangle(n)
        for x in ans:
            print(x, end=" ")
        print()
        tc = tc - 1
        print("~")
# } Driver Code Ends


================================================================================
Date: 2025-05-02
Problem: Bitonic Point
Filename: 2025-05-02_Bitonic_Point.py
================================================================================

class Solution:
    def findMaximum(self, arr):
        return max(arr)

2)
class Solution:
    def findMaximum(self, arr):
        low, high = 0, len(arr) - 1
        while low < high:
            mid = (low + high) // 2
            if arr[mid] < arr[mid + 1]:
                low = mid + 1
            else:
                high = mid
        return arr[low]
#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    tc = int(input())
    while tc > 0:
        arr = list(map(int, input().strip().split()))
        ob = Solution()
        ans = ob.findMaximum(arr)
        print(ans)
        tc -= 1
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-05-03
Problem: Prime List
Filename: 2025-05-03_Prime_List.py
================================================================================

class Solution:
    def primeList(self, h):
        m = 0; p = h
        while p: m = max(m, p.val); p = p.next
        s = [1]*(2*m+1); s[0] = s[1] = 0
        for i in range(2, int((2*m)**0.5)+1):
            if s[i]: s[i*i:2*m+1:i] = [0]*len(range(i*i, 2*m+1, i))
        p = h
        while p:
            x, d = p.val, 0
            while 1:
                if x-d > 1 and s[x-d]: p.val = x-d; break
                if x+d <= 2*m and s[x+d]: p.val = x+d; break
                d += 1
            p = p.next
        return h

#{ 
 # Driver Code Starts
class Node:

    def __init__(self, x):
        self.val = x
        self.next = None


def printList(node):
    while (node != None):
        print(node.val, end=" ")
        node = node.next
    print()


def inputList():

    val = [int(i) for i in input().strip().split()
           ]  #all data of linked list in a line
    head = Node(val[0])
    tail = head
    for i in range(1, len(val)):
        tail.next = Node(val[i])
        tail = tail.next
    return head


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):

        head = inputList()

        obj = Solution()
        res = obj.primeList(head)

        printList(res)

        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-05-04
Problem: Smallest distinct window
Filename: 2025-05-04_Smallest_distinct_window.py
================================================================================

class Solution:
    def findSubString(self, s):
        d = len(set(s))
        i = j = c = 0
        res = len(s)
        freq = [0]*256
        while j < len(s):
            if freq[ord(s[j])] == 0:
                c += 1
            freq[ord(s[j])] += 1
            j += 1
            while c == d:
                res = min(res, j - i)
                freq[ord(s[i])] -= 1
                if freq[ord(s[i])] == 0:
                    c -= 1
                i += 1
        return res


#{ 
 # Driver Code Starts
#Initial Template for Python 3


def main():
    T = int(input())
    while (T > 0):
        str = input()
        ob = Solution()
        print(ob.findSubString(str))

        T -= 1
        print("~")


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2025-05-05
Problem: Search in an almost Sorted Array
Filename: 2025-05-05_Search_in_an_almost_Sorted_Array.py
================================================================================

#{ 
 # Driver Code Starts

# } Driver Code Ends

class Solution:
    def findTarget(self, arr, target):
        for i in range(len(arr)):
            if arr[i] == target: return i
        return -1


#{ 
 # Driver Code Starts.

if __name__ == "__main__":
    t = int(input())  # Number of test cases

    for _ in range(t):
        arr = list(map(int, input().strip().split()))  # Read the array
        target = int(input().strip())  # Read the target

        sln = Solution()
        ans = sln.findTarget(arr, target)
        print(ans)
        print("~")
# } Driver Code Ends


================================================================================
Date: 2025-05-06
Problem: Left View of Binary Tree
Filename: 2025-05-06_Left_View_of_Binary_Tree.py
================================================================================

#User function Template for python3


'''
# Node Class:
class Node:
    def _init_(self,val):
        self.data = val
        self.left = None
        self.right = None
'''

#Function to return a list containing elements of left view of the binary tree.
class Solution:
    def LeftView(self, root):
        if not root: return []
        res, q = [], [root]
        while q:
            res.append(q[0].data)
            q = [child for node in q for child in (node.left, node.right) if child]
        return res
#{ 
 # Driver Code Starts
#Contributed by Sudarshan Sharma
from collections import deque


# Tree Node
class Node:

    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None


# Function to Build Tree
def buildTree(s):
    #Corner Case
    if (len(s) == 0 or s[0] == "N"):
        return None

    # Creating list of strings from input
    # string after spliting by space
    ip = list(map(str, s.split()))

    # Create the root of the tree
    root = Node(int(ip[0]))
    size = 0
    q = deque()

    # Push the root to the queue
    q.append(root)
    size = size + 1

    # Starting from the second element
    i = 1
    while (size > 0 and i < len(ip)):
        # Get and remove the front of the queue
        currNode = q[0]
        q.popleft()
        size = size - 1

        # Get the current node's value from the string
        currVal = ip[i]

        # If the left child is not null
        if (currVal != "N"):

            # Create the left child for the current node
            currNode.left = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.left)
            size = size + 1
        # For the right child
        i = i + 1
        if (i >= len(ip)):
            break
        currVal = ip[i]

        # If the right child is not null
        if (currVal != "N"):

            # Create the right child for the current node
            currNode.right = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.right)
            size = size + 1
        i = i + 1
    return root


if __name__ == "__main__":
    t = int(input())
    for _ in range(0, t):
        s = input()
        root = buildTree(s)
        ob = Solution()
        result = ob.LeftView(root)
        if len(result) == 0:
            print("[]", end=" ")
        for value in result:
            print(value, end=" ")
        print()

        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-05-07
Problem: Root to Leaf Paths
Filename: 2025-05-07_Root_to_Leaf_Paths.py
================================================================================


from typing import Optional
from collections import deque

from typing import List

"""

definition of binary tree node.
class Node:
    def _init_(self,val):
        self.data = val
        self.left = None
        self.right = None
"""

class Solution:
    def Paths(self, root):
        res, curr = [], []
        def dfs(n):
            if not n: return
            curr.append(n.data)
            if not n.left and not n.right:
                res.append(curr.copy())
            else:
                dfs(n.left); dfs(n.right)
            curr.pop()
        dfs(root)
        return res



#{ 
 # Driver Code Starts
class Node:

    def __init__(self, val):
        self.data = val
        self.right = None
        self.left = None


# Function to Build Tree
def buildTree(s):
    #Corner Case
    if (len(s) == 0 or s[0] == "N"):
        return None

    # Creating list of strings from input
    # string after spliting by space
    ip = list(map(str, s.split()))

    # Create the root of the tree
    root = Node(int(ip[0]))
    size = 0
    q = deque()

    # Push the root to the queue
    q.append(root)
    size = size + 1

    # Starting from the second element
    i = 1
    while (size > 0 and i < len(ip)):
        # Get and remove the front of the queue
        currNode = q[0]
        q.popleft()
        size = size - 1

        # Get the current node's value from the string
        currVal = ip[i]

        # If the left child is not null
        if (currVal != "N"):

            # Create the left child for the current node
            currNode.left = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.left)
            size = size + 1
        # For the right child
        i = i + 1
        if (i >= len(ip)):
            break
        currVal = ip[i]

        # If the right child is not null
        if (currVal != "N"):

            # Create the right child for the current node
            currNode.right = Node(int(currVal))

            # Push it to the queue
            q.append(currNode.right)
            size = size + 1
        i = i + 1
    return root


def inputTree():
    treeString = input().strip()
    root = buildTree(treeString)
    return root


def inorder(root):
    if (root == None):
        return
    inorder(root.left)
    print(root.data, end=" ")
    inorder(root.right)


class IntMatrix:

    def __init__(self) -> None:
        pass

    def Input(self, n, m):
        matrix = []
        #matrix input
        for _ in range(n):
            matrix.append([int(i) for i in input().strip().split()])
        return matrix

    def Print(self, arr):
        for i in arr:
            for j in i:
                print(j, end=" ")
            print()


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):

        root = inputTree()

        obj = Solution()
        res = obj.Paths(root)

        IntMatrix().Print(res)

        print("~")
# } Driver Code Ends


================================================================================
Date: 2025-05-08
Problem: Missing element of AP
Filename: 2025-05-08_Missing_element_of_AP.py
================================================================================

class Solution:
    def findMissing(self, a):
        n = len(a)
        d1 = a[1] - a[0]; d2 = a[-1] - a[-2]; d3 = (a[-1] - a[0]) // n
        d = d1 if (d1==d2 or d1==d3) else d2
        if d == 0: return a[0]
        lo, hi = 0, n-1
        while lo <= hi:
            mid = (lo + hi) // 2
            if (a[mid]-a[0])//d == mid: lo = mid + 1
            else: hi = mid - 1
        return a[0] + lo * d



#{ 
 # Driver Code Starts
#Initial Template for Python 3
import sys
import math


def main():
    input = sys.stdin.read
    data = input().strip().split('\n')

    t = int(data[0])
    solution = Solution()

    for i in range(1, t + 1):
        arr = list(map(int, data[i].split()))
        print(solution.findMissing(arr))
        print("~")


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2025-05-09
Problem: Largest number in K swaps
Filename: 2025-05-09_Largest_number_in_K_swaps.py
================================================================================

class Solution:
    def findMaximumNum(self, s, k):
        ans = [s]
        def r(a, k, i):
            if k == 0 or i == len(a): return
            m = max(a[i:])
            if m != a[i]:
                for j in range(len(a)-1, i-1, -1):
                    if a[j] == m:
                        a[i], a[j] = a[j], a[i]
                        cur = ''.join(a)
                        if cur > ans[0]: ans[0] = cur
                        r(a, k-1, i+1)
                        a[i], a[j] = a[j], a[i]
            else:
                r(a, k, i+1)
        r(list(s), k, 0)
        return ans[0]

#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == "__main__":
    for _ in range(int(input())):
        k = int(input())
        s = input()
        ob = Solution()
        print(ob.findMaximumNum(s, k))

        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-05-10
Problem: Longest Subarray with Majority Greater than K
Filename: 2025-05-10_Longest_Subarray_with_Majority_Greater_than_K.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3

# } Driver Code Ends

class Solution:
    def longestSubarray(self, a, k):
        m, s, r = {}, 0, 0
        for i in range(len(a)):
            s += 1 if a[i] > k else -1
            if s > 0:
                r = i + 1
            elif s - 1 in m:
                r = max(r, i - m[s - 1])
            if s not in m:
                m[s] = i
        return r


#{ 
 # Driver Code Starts.

if __name__ == "__main__":
    t = int(input())
    while t > 0:
        
        arr = [int(x) for x in input().strip().split()]
        k = int(input())
        
        ob = Solution()
        print(ob.longestSubarray(arr, k))
        print("~")
        t -= 1
# } Driver Code Ends


================================================================================
Date: 2025-05-11
Problem: K-th Largest Sum Contiguous Subarray
Filename: 2025-05-11_K-th_Largest_Sum_Contiguous_Subarray.py
================================================================================

class Solution:
    def kthLargest(self, arr, k) -> int:
        p = [0]
        for x in arr: p.append(p[-1] + x)
        q = []
        for i in range(len(arr)):
            for j in range(i + 1, len(arr) + 1):
                heapq.heappush(q, p[j] - p[i])
                if len(q) > k: heapq.heappop(q)
        return q[0]


#{ 
 # Driver Code Starts
#Initial Template for Python 3
import heapq

# Position this line where user code will be pasted.

#Initial Template for Python 3

if __name__ == "__main__":
    t = int(input())
    while t > 0:
        arr = list(map(int, input().split()))
        k = int(input())
        ob = Solution()
        res = ob.kthLargest(arr, k)
        print(res)
        print("~")
        t -= 1

# } Driver Code Ends


================================================================================
Date: 2025-05-12
Problem: Meeting Rooms III
Filename: 2025-05-12_Meeting_Rooms_III.py
================================================================================

#{ 
 # Driver Code Starts
#Initial Template for Python 3
import heapq


# } Driver Code Ends

class Solution:
    def mostBooked(self, n, A):
        A.sort()
        free = list(range(n))
        heapq.heapify(free)
        used = []
        cnt = [0] * n
        for s, e in A:
            while used and used[0][0] <= s:
                _, i = heapq.heappop(used)
                heapq.heappush(free, i)
            if not free:
                t, i = heapq.heappop(used)
                heapq.heappush(used, (t + e - s, i))
                cnt[i] += 1
            else:
                i = heapq.heappop(free)
                heapq.heappush(used, (e, i))
                cnt[i] += 1
        return cnt.index(max(cnt))



#{ 
 # Driver Code Starts.

if __name__ == "__main__":
    import sys
    input = sys.stdin.read().split()
    it = iter(input)
    t = int(next(it))
    while t > 0:
        t -= 1
        n = int(next(it))
        m = int(next(it))
        meetings = []
        for _ in range(m):
            s = int(next(it))
            e = int(next(it))
            meetings.append([s, e])
        sol = Solution()
        res = sol.mostBooked(n, meetings)
        print(res)
        print("~")
# } Driver Code Ends


================================================================================
Date: 2025-05-13
Problem: nCr
Filename: 2025-05-13_nCr.py
================================================================================

class Solution:
    MOD = 10**9 + 7

    def power(self, x, y):
        res = 1
        while y:
            if y & 1:
                res = res * x % self.MOD
            x = x * x % self.MOD
            y >>= 1
        return res

    def nCr(self, n: int, r: int) -> int:
        if r > n:
            return 0
        fact = [1] * (n+1)
        for i in range(1, n+1):
            fact[i] = fact[i-1] * i % self.MOD
        inv = [1] * (n+1)
        inv[n] = self.power(fact[n], self.MOD-2)
        for i in range(n, 0, -1):
            inv[i-1] = inv[i] * i % self.MOD
        return fact[n] * inv[r] % self.MOD * inv[n-r] % self.MOD

#{ 
 # Driver Code Starts
if __name__ == '__main__':
    t = int(input())
    for _ in range(t):
        n = int(input())
        r = int(input())
        ob = Solution()
        print(ob.nCr(n, r))
        print("~")
# } Driver Code Ends


================================================================================
Date: 2025-05-14
Problem: Look and Say Pattern
Filename: 2025-05-14_Look_and_Say_Pattern.py
================================================================================

class Solution:
    def countAndSay(self, n: int) -> str:
        result = "1"
        for _ in range(n - 1):
            i = 0
            new_result = ""
            while i < len(result):
                count = 1
                while i + 1 < len(result) and result[i] == result[i + 1]:
                    count += 1
                    i += 1
                new_result += str(count) + result[i]
                i += 1
            result = new_result
        return result
#{ 
 # Driver Code Starts
#Initial Template for Python 3
if __name__ == '__main__':

    t = int(input())

    for _ in range(t):
        n = int(input())

        solObj = Solution()

        print(solObj.countAndSay(n))

        print("~")
# } Driver Code Ends


================================================================================
Date: 2025-05-15
Problem: Substrings with same first and last characters
Filename: 2025-05-15_Substrings_with_same_first_and_last_characters.py
================================================================================

class Solution:
    def countSubstring(self, s):
        from collections import Counter
        return sum(v * (v + 1) // 2 for v in Counter(s).values())



#{ 
 # Driver Code Starts
#Initial Template for Python 3

if __name__ == '__main__':
    T = int(input())
    for i in range(T):
        s = input()

        ob = Solution()
        answer = ob.countSubstring(s)

        print(answer)
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-05-16
Problem: Smallest range in K lists
Filename: 2025-05-16_Smallest_range_in_K_lists.py
================================================================================

import heapq
class Solution:
    def findSmallestRange(self, a):
        n, m = len(a), len(a[0])
        hi = max(row[0] for row in a)
        q = [(a[i][0], i, 0) for i in range(n)]
        heapq.heapify(q)
        lo, r = 0, float('inf')
        while True:
            x, i, j = heapq.heappop(q)
            if hi - x < r - lo: lo, r = x, hi
            if j + 1 == m: break
            y = a[i][j + 1]
            heapq.heappush(q, (y, i, j + 1))
            hi = max(hi, y)
        return [lo, r]


#{ 
 # Driver Code Starts
# Initial Template for Python 3

t = int(input())
for _ in range(t):
    n = int(input())
    k = int(input())
    arr = []
    for _ in range(k):
        arr.append(list(map(int, input().strip().split())))
    r = Solution().findSmallestRange(arr)
    print(r[0], r[1])
    print("~")

# } Driver Code Ends


================================================================================
Date: 2025-05-17
Problem: Sort the given array after applying the given equation
Filename: 2025-05-17_Sort_the_given_array_after_applying_the_given_equation.py
================================================================================

class Solution:
    def sortArray(self, arr, A, B, C):
        n, l, r, i = len(arr), 0, len(arr) - 1, len(arr) - 1 if A >= 0 else 0
        f = lambda x: A * x * x + B * x + C
        res = [0] * n
        while l <= r:
            lv, rv = f(arr[l]), f(arr[r])
            if A >= 0:
                res[i] = lv if lv > rv else rv
                i -= 1
                l += lv > rv
                r -= lv <= rv
            else:
                res[i] = lv if lv < rv else rv
                i += 1
                l += lv < rv
                r -= lv >= rv
        return res


#{ 
 # Driver Code Starts
#Initial Template for Python 3


def main():
    t = int(input())
    for _ in range(t):
        arr = list(map(int, input().strip().split()))
        a = int(input())
        b = int(input())
        c = int(input())

        ob = Solution()
        ans = ob.sortArray(arr, a, b, c)
        print(' '.join(map(str, ans)))
        print("~")


if __name__ == "__main__":
    main()

# } Driver Code Ends


================================================================================
Date: 2025-05-18
Problem: Level Order in spiral form
Filename: 2025-05-18_Level_Order_in_spiral_form.py
================================================================================

'''
class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None
'''        

class Solution:
    def findSpiral(self, r):
        if not r: return []
        a, q, f = [], deque([r]), True
        while q:
            for _ in range(len(q)):
                x = q.pop() if f else q.popleft()
                a.append(x.data)
                if f:
                    if x.right: q.appendleft(x.right)
                    if x.left: q.appendleft(x.left)
                else:
                    if x.left: q.append(x.left)
                    if x.right: q.append(x.right)
            f = not f
        return a


#{ 
 # Driver Code Starts
from collections import deque


class Node:

    def __init__(self, val):
        self.data = val
        self.right = None
        self.left = None


# Function to Build Tree
def buildTree(s):
    # Corner Case
    if len(s) == 0 or s[0] == "N":
        return None

    # Creating list of strings from input string after splitting by space
    ip = list(map(str, s.split()))

    # Create the root of the tree
    root = Node(int(ip[0]))
    q = deque()

    # Push the root to the queue
    q.append(root)

    # Starting from the second element
    i = 1
    while q and i < len(ip):
        # Get and remove the front of the queue
        currNode = q.popleft()

        # Get the current node's value from the string
        currVal = ip[i]

        # If the left child is not null
        if currVal != "N":
            # Create the left child for the current node
            currNode.left = Node(int(currVal))
            # Push it to the queue
            q.append(currNode.left)

        # For the right child
        i += 1
        if i >= len(ip):
            break
        currVal = ip[i]

        # If the right child is not null
        if currVal != "N":
            # Create the right child for the current node
            currNode.right = Node(int(currVal))
            # Push it to the queue
            q.append(currNode.right)

        i += 1
    return root


# Driver code
if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        s = input()
        root = buildTree(s)
        ob = Solution()
        result = ob.findSpiral(root)
        for value in result:
            print(value, end=" ")
        print()
        print("~")

# } Driver Code Ends


================================================================================
Date: 2025-05-19
Problem: Predecessor and Successor
Filename: 2025-05-19_Predecessor_and_Successor.py
================================================================================

'''
class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None
'''

class Solution:
    def findPreSuc(self, root, key):
        pre = suc = None
        curr = root
        while curr:
            if curr.data < key:
                pre = curr
                curr = curr.right
            else:
                curr = curr.left
        curr = root
        while curr:
            if curr.data > key:
                suc = curr
                curr = curr.left
            else:
                curr = curr.right
        return [pre, suc]


#{ 
 # Driver Code Starts
import queue


# BST Node
class Node:

    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None


def buildTree(ip):
    # Corner Case
    if len(ip) == 0 or ip[0] == 'N':
        return None

    # Create the root of the tree
    root = Node(int(ip[0]))

    # Push the root to the queue
    q = queue.Queue()
    q.put(root)

    # Starting from the second element
    i = 1
    while not q.empty() and i < len(ip):
        # Get and remove the front of the queue
        currNode = q.get()

        # Get the current node's value from the string
        currVal = ip[i]

        # If the left child is not null
        if currVal != "N":
            # Create the left child for the current node
            currNode.left = Node(int(currVal))

            # Push it to the queue
            q.put(currNode.left)

        # For the right child
        i += 1
        if i >= len(ip):
            break
        currVal = ip[i]

        # If the right child is not null
        if currVal != "N":
            # Create the right child for the current node
            currNode.right = Node(int(currVal))

            # Push it to the queue
            q.put(currNode.right)

        i += 1

    return root


# Driver program to test above functions
t = int(input())
for _ in range(t):
    s = input()
    root = buildTree(s.split())
    key = int(input())

    ob = Solution()
    result = ob.findPreSuc(root, key)
    pre, suc = result[0], result[1]

    if pre is not None:
        print(pre.data, end=" ")
    else:
        print(-1, end=" ")

    if suc is not None:
        print(suc.data)
    else:
        print(-1)
    print("~")

# } Driver Code Ends


================================================================================
Date: 2025-05-20
Problem: Burning Tree
Filename: 2025-05-20_Burning_Tree.py
================================================================================

class Solution:
    def minTime(self, root, target):
        self.ans = 0
        def dfs(r):
            if not r: return (0, -1)
            l0, l1 = dfs(r.left)
            r0, r1 = dfs(r.right)
            h = max(l0, r0) + 1
            d = -1
            if r.data == target:
                d = 0
                self.ans = max(self.ans, h-1)
            elif l1 >= 0:
                d = l1 + 1
                self.ans = max(self.ans, r0 + d)
            elif r1 >= 0:
                d = r1 + 1
                self.ans = max(self.ans, l0 + d)
            return (h, d)
        dfs(root)
        return self.ans


================================================================================
Date: 2025-05-21
Problem: Kth Smallest Number in Multiplication Table
Filename: 2025-05-21_Kth_Smallest_Number_in_Multiplication_Table.py
================================================================================

class Solution(object):
    def kthSmallest(self, m, n, k):
        l, r = 1, m * n
        while l < r:
            mid = (l + r) // 2
            cnt = sum(min(n, mid // i) for i in range(1, m + 1))
            if cnt < k: l = mid + 1
            else: r = mid
        return l


================================================================================
Date: 2025-05-22
Problem: Minimum Deletions
Filename: 2025-05-22_Minimum_Deletions.py
================================================================================

class Solution:
    def minDeletions(self, s):
        n = len(s)
        dp = [0] * n
        prev = [0] * n
        for i in range(n - 1, -1, -1):
            dp[i] = 1
            for j in range(i + 1, n):
                dp[j] = prev[j - 1] + 2 if s[i] == s[j] else max(prev[j], dp[j - 1])
            prev = dp[:]
        return n - dp[-1]


================================================================================
Date: 2025-05-23
Problem: Dice throw
Filename: 2025-05-23_Dice_throw.py
================================================================================

class Solution:
    def noOfWays(self, m, n, x):
        mod = 10**9 + 7
        dp = [[0] * (x + 1) for _ in range(n + 1)]
        dp[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                for k in range(1, min(m, j) + 1):
                    dp[i][j] = (dp[i][j] + dp[i - 1][j - k]) % mod
        return dp[n][x]


================================================================================
Date: 2025-05-24
Problem: Sum of all substrings of a number
Filename: 2025-05-24_Sum_of_all_substrings_of_a_number.py
================================================================================

class Solution:
    def sumSubstrings(self,s):
        res=f=0
        for i,ch in enumerate(s):
            f=f*10+int(ch)*(i+1)
            res+=f
        return res


================================================================================
Date: 2025-05-25
Problem: Pythagorean Triplet
Filename: 2025-05-25_Pythagorean_Triplet.py
================================================================================

class Solution:
    def pythagoreanTriplet(self, arr):
        s = set(x * x for x in arr)
        n = len(arr)
        for i in range(n):
            for j in range(i + 1, n):
                if arr[i]**2 + arr[j]**2 in s:
                    return True
        return False


================================================================================
Date: 2025-05-26
Problem: Insert in Sorted Circular Linked List
Filename: 2025-05-26_Insert_in_Sorted_Circular_Linked_List.py
================================================================================

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
     

class Solution:
    def sortedInsert(self, head, data):
        n = Node(data)
        if not head:
            n.next = n
            return n
        cur = head
        while True:
            if (cur.data <= data <= cur.next.data or
                cur.data > cur.next.data and (data >= cur.data or data <= cur.next.data) or
                cur.next == head):
                n.next = cur.next
                cur.next = n
                if data < head.data:
                    head = n
                break
            cur = cur.next
        return head


================================================================================
Date: 2025-05-27
Problem: Print leaf nodes from preorder traversal of BST
Filename: 2025-05-27_Print_leaf_nodes_from_preorder_traversal_of_BST.py
================================================================================

class Solution:
    def leafNodes(self, preorder):
        s, r = [], []
        for i in range(len(preorder)-1):
            f = False
            if preorder[i] > preorder[i+1]:
                s.append(preorder[i])
            else:
                while s and preorder[i+1] > s[-1]:
                    s.pop()
                    f = True
            if f:
                r.append(preorder[i])
        r.append(preorder[-1])
        return r


================================================================================
Date: 2025-05-28
Problem: Find rectangle with corners as 1
Filename: 2025-05-28_Find_rectangle_with_corners_as_1.py
================================================================================

class Solution:
    def ValidCorner(self, mat):
        n, m = len(mat), len(mat[0])
        for i in range(n):
            for j in range(i + 1, n):
                if sum(mat[i][k] & mat[j][k] for k in range(m)) > 1:
                    return True
        return False

2)
class Solution:
    def ValidCorner(self, mat):
        n, m = len(mat), len(mat[0])
        for i in range(n):
            for j in range(i + 1, n):
                cnt = sum(mat[i][k] & mat[j][k] for k in range(m))
                if cnt > 1:
                    return True
        return False


================================================================================
Date: 2025-05-29
Problem: Sum of nodes on the longest path
Filename: 2025-05-29_Sum_of_nodes_on_the_longest_path.py
================================================================================

'''
class Node:
    def __init__(self, val):
        self.data=val
        self.left=None
        self.right=None
'''
class Solution:
    def sumOfLongRootToLeafPath(self, root):
        def dfs(node):
            if not node: return (0, 0)
            l = dfs(node.left)
            r = dfs(node.right)
            if l[0] > r[0]: return (l[0] + 1, l[1] + node.data)
            if r[0] > l[0]: return (r[0] + 1, r[1] + node.data)
            return (l[0] + 1, max(l[1], r[1]) + node.data)
        return dfs(root)[1]


================================================================================
Date: 2025-05-30
Problem: Closest Neighbour in BST
Filename: 2025-05-30_Closest_Neighbour_in_BST.py
================================================================================

'''
class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None
'''

class Solution:
    def findMaxFork(self, root, k):
        if not root:
            return -1
        if root.data == k:
            return k
        if root.data < k:
            x = self.findMaxFork(root.right, k)
            return root.data if x == -1 else x
        return self.findMaxFork(root.left, k)

2)
class Solution:
    def findMaxFork(self, root, k):
        res = -1
        while root:
            if root.data == k:
                return k
            if root.data < k:
                res = root.data
                root = root.right
            else:
                root = root.left
        return res


================================================================================
Date: 2025-05-31
Problem: Kth element in Matrix
Filename: 2025-05-31_Kth_element_in_Matrix.py
================================================================================

class Solution:
    def kthSmallest(self, matrix, k):
        n, l, r = len(matrix), matrix[0][0], matrix[-1][-1]
        while l < r:
            m = (l + r) // 2
            cnt, j = 0, n - 1
            for i in range(n):
                while j >= 0 and matrix[i][j] > m:
                    j -= 1
                cnt += j + 1
            if cnt < k:
                l = m + 1
            else:
                r = m
        return l


================================================================================
Date: 2025-06-01
Problem: Count pairs Sum in matrices
Filename: 2025-06-01_Count_pairs_Sum_in_matrices.py
================================================================================

class Solution:
    def countPairs(self, a, b, x):
        r1 = c1 = 0
        r2, c2 = len(b) - 1, len(b[0]) - 1
        cnt = 0
        while r1 < len(a) and r2 >= 0:
            s = a[r1][c1] + b[r2][c2]
            if s == x:
                cnt += 1
                c1 += 1
                c2 -= 1
            elif s < x:
                c1 += 1
            else:
                c2 -= 1
            if c1 == len(a[0]):
                c1 = 0
                r1 += 1
            if c2 < 0:
                c2 = len(b[0]) - 1
                r2 -= 1
        return cnt


================================================================================
Date: 2025-06-02
Problem: Unique Paths in a Grid
Filename: 2025-06-02_Unique_Paths_in_a_Grid.py
================================================================================

class Solution:
    def uniquePaths(self, grid):
        r, c = len(grid), len(grid[0])
        dp = [0] * c
        dp[0] = 1 if grid[0][0] == 0 else 0
        for i in range(r):
            for j in range(c):
                if grid[i][j] == 1:
                    dp[j] = 0
                elif j > 0:
                    dp[j] += dp[j - 1]
        return dp[-1]


================================================================================
Date: 2025-06-03
Problem: Substrings with K Distinct
Filename: 2025-06-03_Substrings_with_K_Distinct.py
================================================================================

class Solution:
    def count(self, s, k):
        freq = [0] * 26
        i = ans = distinct = 0
        for j in range(len(s)):
            if freq[ord(s[j]) - ord('a')] == 0:
                distinct += 1
            freq[ord(s[j]) - ord('a')] += 1
            while distinct > k:
                freq[ord(s[i]) - ord('a')] -= 1
                if freq[ord(s[i]) - ord('a')] == 0:
                    distinct -= 1
                i += 1
            ans += j - i + 1
        return ans

    def countSubstr(self, s, k):
        return self.count(s, k) - self.count(s, k - 1)


================================================================================
Date: 2025-06-04
Problem: LCS of three strings
Filename: 2025-06-04_LCS_of_three_strings.py
================================================================================

class Solution:
    def lcsOf3(self, s1, s2, s3):
        n1, n2, n3 = len(s1), len(s2), len(s3)
        prev = [[0] * (n3 + 1) for _ in range(n2 + 1)]
        curr = [[0] * (n3 + 1) for _ in range(n2 + 1)]
        for i in range(1, n1 + 1):
            for j in range(1, n2 + 1):
                for k in range(1, n3 + 1):
                    if s1[i - 1] == s2[j - 1] == s3[k - 1]:
                        curr[j][k] = 1 + prev[j - 1][k - 1]
                    else:
                        curr[j][k] = max(
                            prev[j][k],
                            curr[j - 1][k],
                            curr[j][k - 1]
                        )
            prev, curr = curr, prev
        return prev[n2][n3]


================================================================================
Date: 2025-06-05
Problem: Count the paths
Filename: 2025-06-05_Count_the_paths.py
================================================================================

class Solution:
    def countPaths(self, E, V, S, D):
        from collections import defaultdict, deque
        G = defaultdict(list); I = [0] * V
        for u, v in E: G[u].append(v); I[v] += 1
        Q = deque(i for i in range(V) if I[i] == 0)
        T, dp = [], [0] * V; dp[D] = 1
        while Q:
            u = Q.popleft(); T.append(u)
            for v in G[u]:
                I[v] -= 1
                if I[v] == 0: Q.append(v)
        for u in reversed(T):
            for v in G[u]: dp[u] += dp[v]
        return dp[S]


================================================================================
Date: 2025-06-06
Problem: Search Pattern Rabin-Karp Algorithm
Filename: 2025-06-06_Search_Pattern_Rabin-Karp_Algorithm.py
================================================================================

class Solution:
    def search(self, pat, txt):
        d, q, m, n = 256, 101, len(pat), len(txt)
        ph = th = 0; h = 1; res = []
        for i in range(m - 1): h = (h * d) % q
        for i in range(m):
            ph = (d * ph + ord(pat[i])) % q
            th = (d * th + ord(txt[i])) % q
        for i in range(n - m + 1):
            if ph == th and txt[i:i + m] == pat:
                res.append(i + 1)
            if i < n - m:
                th = (d * (th - ord(txt[i]) * h) + ord(txt[i + m])) % q
                if th < 0: th += q
        return res


================================================================================
Date: 2025-06-07
Problem: Longest Span in two Binary Arrays
Filename: 2025-06-07_Longest_Span_in_two_Binary_Arrays.py
================================================================================

class Solution:
    def longestCommonSum(self, arr1, arr2):
        n = len(arr1)
        sum1 = sum2 = res = 0
        diff_map = {}
        for i in range(n):
            sum1 += arr1[i]
            sum2 += arr2[i]
            diff = sum1 - sum2
            if diff == 0:
                res = i + 1
            elif diff in diff_map:
                res = max(res, i - diff_map[diff])
            else:
                diff_map[diff] = i
        return res


================================================================================
Date: 2025-06-08
Problem: Sum-string
Filename: 2025-06-08_Sum-string.py
================================================================================

class Solution:
    def isSumString(self, s: str) -> bool:
        def add(a, b):
            return str(int(a) + int(b))
        
        def check(i, l1, l2):
            x, y = s[i:i + l1], s[i + l1:i + l1 + l2]
            if (len(x) > 1 and x[0] == '0') or (len(y) > 1 and y[0] == '0'):
                return False
            z = add(x, y)
            l3 = len(z)
            if i + l1 + l2 + l3 > len(s): return False
            if s[i + l1 + l2:i + l1 + l2 + l3] != z: return False
            if i + l1 + l2 + l3 == len(s): return True
            return check(i + l1, l2, l3)

        n = len(s)
        for l1 in range(1, n):
            for l2 in range(1, n - l1):
                if check(0, l1, l2): return True
        return False


================================================================================
Date: 2025-06-09
Problem: BST with Dead End
Filename: 2025-06-09_BST_with_Dead_End.py
================================================================================

class Solution:
    def dfs(self, root, l, r):
        if not root: return False
        if not root.left and not root.right and l == r: return True
        return self.dfs(root.left, l, root.data - 1) or self.dfs(root.right, root.data + 1, r)

    def isDeadEnd(self, root):
        return self.dfs(root, 1, float('inf'))


================================================================================
Date: 2025-06-10
Problem: Exactly one swap
Filename: 2025-06-10_Exactly_one_swap.py
================================================================================

class Solution:
    def countStrings(self, s):
        m = [0]*26
        ans = 0
        for i, ch in enumerate(s):
            ans += i - m[ord(ch) - 97]
            m[ord(ch) - 97] += 1
        if any(x > 1 for x in m):
            ans += 1
        return ans


================================================================================
Date: 2025-06-11
Problem: Remove the balls
Filename: 2025-06-11_Remove_the_balls.py
================================================================================

class Solution:
    def findLength(self, color, radius):
        j = -1
        for i, (c, r) in enumerate(zip(color, radius)):
            if j >= 0 and c == color[j] and r == radius[j]:
                j -= 1
            else:
                j += 1
                color[j], radius[j] = c, r
        return j + 1


================================================================================
Date: 2025-06-12
Problem: K closest elements
Filename: 2025-06-12_K_closest_elements.py
================================================================================

class Solution:
    def printKClosest(self, a, k, x):
        n, l, h, p = len(a), 0, len(a) - 1, -1
        while l <= h:
            m = (l + h) // 2
            if a[m] < x: p = m; l = m + 1
            else: h = m - 1
        i, j, r = p, p + 1, []
        if j < n and a[j] == x: j += 1
        while i >= 0 and j < n and len(r) < k:
            r.append(a[i] if abs(a[i] - x) < abs(a[j] - x) else a[j])
            if abs(a[i] - x) < abs(a[j] - x): i -= 1
            else: j += 1
        while i >= 0 and len(r) < k: r.append(a[i]); i -= 1
        while j < n and len(r) < k: r.append(a[j]); j += 1
        return r


================================================================================
Date: 2025-06-13
Problem: Koko Eating Bananas
Filename: 2025-06-13_Koko_Eating_Bananas.py
================================================================================

class Solution:
    def kokoEat(self, arr, k):
        lo, hi = 1, max(arr)
        while lo < hi:
            mid = (lo + hi) // 2
            hours = sum((pile + mid - 1) // mid for pile in arr)
            if hours <= k:
                hi = mid
            else:
                lo = mid + 1
        return lo


================================================================================
Date: 2025-06-14
Problem: Symmetric Tree
Filename: 2025-06-14_Symmetric_Tree.py
================================================================================

'''
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None
'''
class Solution:
    def isSymmetric(self, root):
        if not root:
            return True
        s1, s2 = [root.left], [root.right]
        while s1 and s2:
            a, b = s1.pop(), s2.pop()
            if not a and not b:
                continue
            if not a or not b or a.data != b.data:
                return False
            s1.extend([a.left, a.right])
            s2.extend([b.right, b.left])
        return not s1 and not s2

2)
class Solution:
    def isSym(self,a,b):
        if not a or not b: return a is b
        if a.data!=b.data: return False
        return self.isSym(a.left,b.right) and self.isSym(a.right,b.left)
    def isSymmetric(self, root):
        return root is None or self.isSym(root.left,root.right)


================================================================================
Date: 2025-06-15
Problem: Smallest Divisor
Filename: 2025-06-15_Smallest_Divisor.py
================================================================================

class Solution:
    def smallestDivisor(self, arr, k):
        l, h = 1, max(arr)
        while l < h:
            m, s = l + (h - l) // 2, 0
            for x in arr:
                s += (x + m - 1) // m
            if s <= k:
                h = m
            else:
                l = m + 1
        return l


================================================================================
Date: 2025-06-16
Problem: Equalize the Towers
Filename: 2025-06-16_Equalize_the_Towers.py
================================================================================

class Solution:
    def minCost(self, heights, cost):
        l, h = 0, max(heights)
        while l < h:
            m = l + (h - l) // 2
            c1 = sum(abs(heights[i] - m) * cost[i] for i in range(len(heights)))
            c2 = sum(abs(heights[i] - m - 1) * cost[i] for i in range(len(heights)))
            if c1 <= c2:
                h = m
            else:
                l = m + 1
        return sum(abs(heights[i] - l) * cost[i] for i in range(len(heights)))


================================================================================
Date: 2025-06-17
Problem: Coin Piles
Filename: 2025-06-17_Coin_Piles.py
================================================================================

class Solution:
    def minimumCoins(self, a, k):
        a.sort()
        n, t, res, w, p, e = len(a), sum(a), sum(a), 0, 0, 0
        for s in range(n):
            while e < n and a[e] - a[s] <= k:
                w += a[e]
                e += 1
            r = max(0, (t - p - w) - (n - e) * (a[s] + k))
            res = min(res, p + r)
            if e == s: e += 1
            else: w -= a[s]
            p += a[s]
        return res


================================================================================
Date: 2025-06-18
Problem: All Palindromic Partitions
Filename: 2025-06-18_All_Palindromic_Partitions.py
================================================================================

class Solution:
    def palinParts(self, s):
        n = len(s)
        d = [[False]*n for _ in range(n)]
        for i in range(n): d[i][i] = True
        for i in range(n-1): d[i][i+1] = s[i] == s[i+1]
        for l in range(3, n+1):
            for i in range(n-l+1):
                j = i + l - 1
                d[i][j] = s[i] == s[j] and d[i+1][j-1]
        r = []
        def b(i, c):
            if i == n: r.append(c[:]); return
            for j in range(i, n):
                if d[i][j]:
                    c.append(s[i:j+1])
                    b(j+1, c)
                    c.pop()
        b(0, [])
        return r


================================================================================
Date: 2025-06-19
Problem: Case-specific Sorting of Strings
Filename: 2025-06-19_Case-specific_Sorting_of_Strings.py
================================================================================

class Solution:
    def caseSort(self, s):
        l, u = [0] * 26, [0] * 26
        for c in s:
            if c.islower():
                l[ord(c) - 97] += 1
            else:
                u[ord(c) - 65] += 1
        r, i, j = list(s), 0, 0
        for k in range(len(s)):
            if s[k].islower():
                while l[i] == 0:
                    i += 1
                r[k] = chr(i + 97)
                l[i] -= 1
            else:
                while u[j] == 0:
                    j += 1
                r[k] = chr(j + 65)
                u[j] -= 1
        return ''.join(r)


================================================================================
Date: 2025-06-20
Problem: Group Balls by Sequence
Filename: 2025-06-20_Group_Balls_by_Sequence.py
================================================================================

from collections import Counter
class Solution:
    def validgroup(self, arr, k):
        m = Counter(arr)
        for v in sorted(m.keys()):
            f = m[v]
            if f == 0: continue
            for i in range(1, k):
                if m[v + i] < f: return False
                m[v + i] -= f
        return True


================================================================================
Date: 2025-06-21
Problem: Police and Thieves
Filename: 2025-06-21_Police_and_Thieves.py
================================================================================

class Solution:
    def catchThieves(self, arr, k):
        i = j = c = 0
        n = len(arr)
        while i < n and j < n:
            while i < n and arr[i] != 'P':
                i += 1
            while j < n and arr[j] != 'T':
                j += 1
            if i < n and j < n and abs(i - j) <= k:
                i += 1
                j += 1
                c += 1
            elif j < i:
                j += 1
            else:
                i += 1
        return c


================================================================================
Date: 2025-06-22
Problem: Largest Divisible Subset
Filename: 2025-06-22_Largest_Divisible_Subset.py
================================================================================

class Solution:
    def largestSubset(self, arr):
        n = len(arr)
        arr.sort(reverse=True)
        dp = [1] * n
        parent = [-1] * n
        max_idx = 0
        for i in range(1, n):
            for j in range(i):
                if arr[j] % arr[i] == 0 and dp[j] + 1 > dp[i]:
                    dp[i] = dp[j] + 1
                    parent[i] = j
            if dp[i] > dp[max_idx]:
                max_idx = i
        result = []
        i = max_idx
        while i != -1:
            result.append(arr[i])
            i = parent[i]
        return result


================================================================================
Date: 2025-06-23
Problem: Minimum sum
Filename: 2025-06-23_Minimum_sum.py
================================================================================

class Solution:
    def minSum(self, arr):
        count = [0]*10
        for x in arr: count[x]+=1
        s1 = s2 = ""
        first = True
        for d in range(10):
            while count[d]>0:
                if first:
                    if s1 or d!=0: s1 += str(d)
                    first = False
                else:
                    if s2 or d!=0: s2 += str(d)
                    first = True
                count[d] -= 1
        if not s1: s1="0"
        if not s2: s2="0"
        return self.addString(s1, s2)
    def addString(self, s1, s2):
        i, j, carry, res = len(s1)-1, len(s2)-1, 0, []
        while i>=0 or j>=0 or carry>0:
            if i>=0: carry += int(s1[i]); i-=1
            if j>=0: carry += int(s2[j]); j-=1
            res.append(str(carry%10))
            carry//=10
        while len(res)>1 and res[-1]=='0': res.pop()
        return ''.join(reversed(res))


================================================================================
Date: 2025-06-24
Problem: Lexicographically Largest String After K Deletions
Filename: 2025-06-24_Lexicographically_Largest_String_After_K_Deletions.py
================================================================================

class Solution:
    def maxSubseq(self, s, k):
        n, toRemove, res = len(s), k, []
        for c in s:
            while res and toRemove and res[-1] < c:
                res.pop()
                toRemove -= 1
            res.append(c)
        return ''.join(res[:n - k])


================================================================================
Date: 2025-06-25
Problem: Check if frequencies can be equal
Filename: 2025-06-25_Check_if_frequencies_can_be_equal.py
================================================================================

class Solution:
    def sameFreq(self, s: str) -> bool:
        from collections import Counter
        freq = Counter(s)
        count = Counter(freq.values())
        if len(count) == 1:
            return True
        if len(count) == 2:
            (f1, c1), (f2, c2) = count.items()
            return (f1 == 1 and c1 == 1) or (f2 == 1 and c2 == 1) or \
                   (abs(f1 - f2) == 1 and ((f1 > f2 and c1 == 1) or (f2 > f1 and c2 == 1)))
        return False


================================================================================
Date: 2025-06-26
Problem: Game with String
Filename: 2025-06-26_Game_with_String.py
================================================================================

class Solution:
    def minValue(self, s, k):
        f = [0] * 26
        for c in s: f[ord(c) - 97] += 1
        m = max(f)
        b = [0] * (m + 1)
        for x in f: b[x] += x > 0
        while k and m:
            if b[m] <= k: k -= b[m]; b[m - 1] += b[m]; b[m] = 0; m -= 1
            else: b[m] -= k; b[m - 1] += k; k = 0
        return sum(i * i * b[i] for i in range(1, m + 1))


================================================================================
Date: 2025-06-27
Problem: Mobile numeric keypad
Filename: 2025-06-27_Mobile_numeric_keypad.py
================================================================================

class Solution:
    def getCount(self, n):
        p = [[1]*3 for _ in range(4)]
        p[3][0] = p[3][2] = 0
        d = [(0,0),(0,1),(0,-1),(1,0),(-1,0)]
        for _ in range(2,n+1):
            c = [[0]*3 for _ in range(4)]
            for i in range(4):
                for j in range(3):
                    if i==3 and j in (0,2): continue
                    for dx,dy in d:
                        x,y = i+dx,j+dy
                        if 0<=x<4 and 0<=y<3: c[i][j] += p[x][y]
            p = c
        return sum(sum(r) for r in p)


================================================================================
Date: 2025-06-28
Problem: Counting elements in two arrays
Filename: 2025-06-28_Counting_elements_in_two_arrays.py
================================================================================

class Solution:
    def countLessEq(self, a, b):
        if not b: return [0]*len(a)
        m = max(b)
        cnt = [0]*(m+1)
        for x in b: cnt[x] += 1
        for i in range(1, m+1): cnt[i] += cnt[i-1]
        return [cnt[min(x, m)] for x in a]


================================================================================
Date: 2025-06-29
Problem: Split Array Largest Sum
Filename: 2025-06-29_Split_Array_Largest_Sum.py
================================================================================

class Solution:
    def splitArray(self, a, k):
        l, r = max(a), sum(a)
        while l < r:
            m, s, c = (l + r) // 2, 0, 1
            for x in a:
                if s + x > m:
                    c += 1
                    s = 0
                s += x
            if c <= k:
                r = m
            else:
                l = m + 1
        return l


================================================================================
Date: 2025-06-30
Problem: Max min Height
Filename: 2025-06-30_Max_min_Height.py
================================================================================

class Solution:
    def isPossible(self, arr, k, w, maxHeight):
        n = len(arr)
        water = [0] * n
        for i in range(n):
            if i > 0:
                water[i] = water[i - 1]
            currHeight = arr[i] + water[i]
            if i >= w:
                currHeight -= water[i - w]
            if currHeight < maxHeight:
                add = maxHeight - currHeight
                water[i] += add
                k -= add
                if k < 0:
                    return False
        return True
    
    def maxMinHeight(self, arr, k, w):
        n = len(arr)
        low = min(arr)
        high = low + k
        ans = low
        while low <= high:
            mid = low + (high - low) // 2
            if self.isPossible(arr, k, w, mid):
                ans = max(ans, mid)
                low = mid + 1
            else:
                high = mid - 1
        return ans


================================================================================
Date: 2025-07-01
Problem: Substrings of length k with k-1 distinct elements
Filename: 2025-07-01_Substrings_of_length_k_with_k-1_distinct_elements.py
================================================================================

class Solution:
    def substrCount(self, s, k):
        if k > len(s): return 0
        cnt = [0]*26
        ans = d = 0
        for i in range(k-1):
            if cnt[ord(s[i])-97] == 0: d += 1
            cnt[ord(s[i])-97] += 1
        for i in range(k-1, len(s)):
            if cnt[ord(s[i])-97] == 0: d += 1
            cnt[ord(s[i])-97] += 1
            if d == k - 1: ans += 1
            idx = ord(s[i-k+1])-97
            cnt[idx] -= 1
            if cnt[idx] == 0: d -= 1
        return ans


================================================================================
Date: 2025-07-02
Problem: Longest subarray with Atmost two distinct integers
Filename: 2025-07-02_Longest_subarray_with_Atmost_two_distinct_integers.py
================================================================================

class Solution:
    def totalElements(self, arr):
        mp = {}
        i = maxLen = 0
        for j in range(len(arr)):
            mp[arr[j]] = mp.get(arr[j], 0) + 1
            while len(mp) > 2:
                mp[arr[i]] -= 1
                if mp[arr[i]] == 0:
                    del mp[arr[i]]
                i += 1
            maxLen = max(maxLen, j - i + 1)
        return maxLen


================================================================================
Date: 2025-07-03
Problem: Longest Substring with K Uniques
Filename: 2025-07-03_Longest_Substring_with_K_Uniques.py
================================================================================

class Solution:
    def longestKSubstr(self, s, k):
        freq = [0] * 26
        i = cnt = maxi = 0
        for j in range(len(s)):
            if freq[ord(s[j]) - ord('a')] == 0:
                cnt += 1
            freq[ord(s[j]) - ord('a')] += 1
            while cnt > k:
                freq[ord(s[i]) - ord('a')] -= 1
                if freq[ord(s[i]) - ord('a')] == 0:
                    cnt -= 1
                i += 1
            if cnt == k:
                maxi = max(maxi, j - i + 1)
        return maxi if maxi > 0 else -1


================================================================================
Date: 2025-07-04
Problem: Subarrays With At Most K Distinct Integers
Filename: 2025-07-04_Subarrays_With_At_Most_K_Distinct_Integers.py
================================================================================

class Solution:
    def countAtMostK(self, arr, k):
        freq = {}
        n, res, left = len(arr), 0, 0
        for right in range(n):
            freq[arr[right]] = freq.get(arr[right], 0) + 1
            while len(freq) > k:
                freq[arr[left]] -= 1
                if freq[arr[left]] == 0:
                    del freq[arr[left]]
                left += 1
            res += right - left + 1
        return res


================================================================================
Date: 2025-07-05
Problem: Max Score from Subarray Mins
Filename: 2025-07-05_Max_Score_from_Subarray_Mins.py
================================================================================

class Solution:
    def maxSum(self, arr):
        ans = 0
        for i in range(1, len(arr)):
            ans = max(arr[i] + arr[i - 1], ans)
        return ans


================================================================================
Date: 2025-07-06
Problem: Maximum Sum Combination
Filename: 2025-07-06_Maximum_Sum_Combination.py
================================================================================

class Solution:
    def topKSumPairs(self, a, b, k):
        n = len(a)
        a.sort()
        b.sort()
        pq = [(-(a[-1] + b[-1]), n - 1, n - 1)]
        vis = {(n - 1, n - 1)}
        res = []
        while len(res) < k:
            s, i, j = heapq.heappop(pq)
            res.append(-s)
            if i > 0 and (i - 1, j) not in vis:
                vis.add((i - 1, j))
                heapq.heappush(pq, (-(a[i - 1] + b[j]), i - 1, j))
            if j > 0 and (i, j - 1) not in vis:
                vis.add((i, j - 1))
                heapq.heappush(pq, (-(a[i] + b[j - 1]), i, j - 1))
        return res


================================================================================
Date: 2025-07-07
Problem: Next Greater Element in Circular Array
Filename: 2025-07-07_Next_Greater_Element_in_Circular_Array.py
================================================================================

class Solution:
    def nextLargerElement(self, arr):
        n = len(arr)
        res = [-1] * n
        st = []
        for i in range(2 * n - 1, -1, -1):
            while st and st[-1] <= arr[i % n]:
                st.pop()
            if i < n and st:
                res[i] = st[-1]
            st.append(arr[i % n])
        return res


================================================================================
Date: 2025-07-08
Problem: Next element with greater frequency
Filename: 2025-07-08_Next_element_with_greater_frequency.py
================================================================================

from collections import Counter
class Solution:
    def findGreater(self, a):
        f = Counter(a)
        r, s = [-1]*len(a), []
        for i, v in enumerate(a):
            while s and f[v] > f[a[s[-1]]]:
                r[s.pop()] = v
            s.append(i)
        return r


================================================================================
Date: 2025-07-09
Problem: Sum of subarray minimum
Filename: 2025-07-09_Sum_of_subarray_minimum.py
================================================================================

class Solution:
    def sumSubMins(self, arr):
        MOD = 10**9 + 7
        n = len(arr)
        left = [0] * n
        right = [0] * n
        st = []
        for i in range(n):
            while st and arr[st[-1]] >= arr[i]:
                st.pop()
            left[i] = i + 1 if not st else i - st[-1]
            st.append(i)
        st.clear()
        for i in range(n - 1, -1, -1):
            while st and arr[st[-1]] > arr[i]:
                st.pop()
            right[i] = n - i if not st else st[-1] - i
            st.append(i)
        return sum(arr[i] * left[i] * right[i] for i in range(n)) % MOD


================================================================================
Date: 2025-07-10
Problem: Find the longest string
Filename: 2025-07-10_Find_the_longest_string.py
================================================================================

class Solution:
    def longestString(self, words):
        words.sort(key=len)
        st = set()
        res = ""
        for w in words:
            if len(w) == 1 or w[:-1] in st:
                st.add(w)
                if len(w) > len(res) or (len(w) == len(res) and w < res):
                    res = w
        return res


================================================================================
Date: 2025-07-11
Problem: Trail of ones
Filename: 2025-07-11_Trail_of_ones.py
================================================================================

class Solution:
    def countConsec(self, n: int) -> int:
        a = b = 0
        for i in range(n, 0, -1):
            a, b = a + b, a + (1 << (n - i))
        return a


================================================================================
Date: 2025-07-12
Problem: Gold Mine Problem
Filename: 2025-07-12_Gold_Mine_Problem.py
================================================================================

class Solution:
    def maxGold(self, mat):
        n, m = len(mat), len(mat[0])
        for j in range(m - 2, -1, -1):
            for i in range(n):
                mx = 0
                for di in [-1, 0, 1]:
                    ni = i + di
                    if 0 <= ni < n:
                        mx = max(mx, mat[ni][j + 1])
                mat[i][j] += mx
        return max(mat[i][0] for i in range(n))


================================================================================
Date: 2025-07-13
Problem: Maximum sum of elements not part of LIS
Filename: 2025-07-13_Maximum_sum_of_elements_not_part_of_LIS.py
================================================================================

import bisect
class Solution:
    def nonLisMaxSum(self, arr):
        dp, s = [], []
        total = sum(arr)
        for x in arr:
            i = bisect.bisect_left(dp, x)
            if i == len(dp):
                dp.append(x)
                s.append((s[-1] if s else 0) + x)
            else:
                dp[i] = x
                s[i] = (s[i-1] if i else 0) + x
        return total - s[-1]



================================================================================
Date: 2025-07-14
Problem: Cutting Binary String
Filename: 2025-07-14_Cutting_Binary_String.py
================================================================================

class Solution:
    def cuts(self, s):
        if s[0] == '0': return -1
        n = len(s)
        powers = set()
        p = 1
        while p <= 10**9:
            powers.add(p)
            p *= 5
        dp = [n + 1] * (n + 1)
        dp[n] = 0
        for i in range(n - 1, -1, -1):
            if s[i] == '0': continue
            num = 0
            for j in range(i, n):
                num = (num << 1) + int(s[j])
                if num > 10**9: break
                if num in powers and dp[j + 1] <= n:
                    dp[i] = min(dp[i], 1 + dp[j + 1])
        return -1 if dp[0] > n else dp[0]


================================================================================
Date: 2025-07-15
Problem: Divisible by 13
Filename: 2025-07-15_Divisible_by_13.py
================================================================================

class Solution:
    def divby13(self, s):
        r = 0
        for c in s:
            r = (r * 10 + int(c)) % 13
        return r == 0


================================================================================
Date: 2025-07-16
Problem: Nine Divisors
Filename: 2025-07-16_Nine_Divisors.py
================================================================================

class Solution:
    def countNumbers(self, n):
        from math import isqrt
        c, lim = 0, isqrt(n)
        spf = list(range(lim + 1))
        for i in range(2, isqrt(lim) + 1):
            if spf[i] == i:
                for j in range(i*i, lim + 1, i):
                    if spf[j] == j: spf[j] = i
        for i in range(2, lim + 1):
            p, q = spf[i], spf[i // spf[i]]
            if p * q == i and p != q and q != 1: c += 1
            elif spf[i] == i and i**8 <= n: c += 1
        return c


================================================================================
Date: 2025-07-17
Problem: Power of k in factorial of n
Filename: 2025-07-17_Power_of_k_in_factorial_of_n.py
================================================================================

class Solution:
    def maxKPower(self, n, k):
        res = float('inf')
        i = 2
        while i * i <= k:
            if k % i == 0:
                cnt = 0
                while k % i == 0:
                    k //= i
                    cnt += 1
                fact = 0
                p = i
                while p <= n:
                    fact += n // p
                    p *= i
                res = min(res, fact // cnt)
            i += 1
        if k > 1:
            fact = 0
            p = k
            while p <= n:
                fact += n // p
                p *= k
            res = min(res, fact)
        return res if res != float('inf') else 0


================================================================================
Date: 2025-07-18
Problem: LCM Triplet
Filename: 2025-07-18_LCM_Triplet.py
================================================================================

class Solution:
    def lcmTriplets(self, n):
        return n if n < 3 else n * (n - 1) * (n - 2) if n & 1 else \
               n * (n - 1) * (n - 3) if n % 3 else (n - 1) * (n - 2) * (n - 3)


================================================================================
Date: 2025-07-19
Problem: Count Unique Vowel Strings
Filename: 2025-07-19_Count_Unique_Vowel_Strings.py
================================================================================

from math import prod, factorial
from collections import Counter
class Solution:
    def vowelCount(self, s):
        freq = Counter(c for c in s if c in 'aeiou')
        vals = list(freq.values())
        return prod(vals) * factorial(len(vals)) if vals else 0


================================================================================
Date: 2025-07-20
Problem: Count Numbers Containing Specific Digits
Filename: 2025-07-20_Count_Numbers_Containing_Specific_Digits.py
================================================================================

class Solution:
    def countValid(self, n, arr):
        allowed = [False] * 10
        for d in arr:
            allowed[d] = True
        
        forbidden = sum(1 for i in range(10) if not allowed[i])
        non_zero_forbidden = sum(1 for i in range(1, 10) if not allowed[i])
        
        total = 9 * (10 ** (n - 1))
        invalid = non_zero_forbidden * (forbidden ** (n - 1)) if n > 1 else non_zero_forbidden
        
        return total - invalid


================================================================================
Date: 2025-07-21
Problem: Count the Coprimes
Filename: 2025-07-21_Count_the_Coprimes.py
================================================================================

class Solution:
    def cntCoprime(self, arr):
        mx = max(arr)
        cnt, div, mu = [0] * (mx + 1), [0] * (mx + 1), [1] * (mx + 1)
        vis = [False] * (mx + 1)
        
        for x in arr:
            cnt[x] += 1
        
        for i in range(2, mx + 1):
            if not vis[i]:
                for j in range(i, mx + 1, i):
                    mu[j] *= -1
                    vis[j] = True
                for j in range(i * i, mx + 1, i * i):
                    mu[j] = 0
        
        for i in range(1, mx + 1):
            for j in range(i, mx + 1, i):
                div[i] += cnt[j]
        
        ans = 0
        for i in range(1, mx + 1):
            if mu[i] and div[i] > 1:
                ans += mu[i] * div[i] * (div[i] - 1) // 2
        
        return ans


================================================================================
Date: 2025-07-22
Problem: Smallest Positive Missing
Filename: 2025-07-22_Smallest_Positive_Missing.py
================================================================================

class Solution:
    def missingNumber(self, a):
        n = len(a)
        for i in range(n):
            while 0 < a[i] <= n and a[i] != a[a[i] - 1]:
                a[a[i] - 1], a[i] = a[i], a[a[i] - 1]
        for i in range(n):
            if a[i] != i + 1: return i + 1
        return n + 1

2)
class Solution:
    def missingNumber(self, a):
        n = len(a)
        for i in range(n):
            if a[i] <= 0: a[i] = n + 1
        for i in range(n):
            x = abs(a[i])
            if x <= n: a[x - 1] = -abs(a[x - 1])
        for i in range(n):
            if a[i] > 0: return i + 1
        return n + 1


================================================================================
Date: 2025-07-23
Problem: Sum of Subarrays
Filename: 2025-07-23_Sum_of_Subarrays.py
================================================================================

class Solution:
    def subarraySum(self, arr):
        n = len(arr)
        return sum(arr[i] * (i + 1) * (n - i) for i in range(n))


================================================================================
Date: 2025-07-24
Problem: Last Moment Before All Ants Fall Out
Filename: 2025-07-24_Last_Moment_Before_All_Ants_Fall_Out.py
================================================================================

class Solution:
    def getLastMoment(self, n, left, right):
        return max([0] + left + [n - x for x in right])

2)
class Solution:
    def getLastMoment(self, n, left, right):
        max_left_time = max(left or [0])
        max_right_time = n - min(right or [n])
        return max(max_left_time, max_right_time)

3)
class Solution:
    def getLastMoment(self, n, left, right):
        ans = 0
        for x in left: ans = max(ans, x)
        for x in right: ans = max(ans, n - x)
        return ans


================================================================================
Date: 2025-07-25
Problem: Max Circular Subarray Sum
Filename: 2025-07-25_Max_Circular_Subarray_Sum.py
================================================================================

class Solution:
    def maxCircularSum(self, arr):
        def kadane(a):
            max_sum = curr_sum = a[0]
            for i in range(1, len(a)):
                curr_sum = max(a[i], curr_sum + a[i])
                max_sum = max(max_sum, curr_sum)
            return max_sum
        
        max_kadane = kadane(arr)
        total_sum = sum(arr)
        for i in range(len(arr)):
            arr[i] = -arr[i]
        max_circular = total_sum + kadane(arr)
        for i in range(len(arr)):
            arr[i] = -arr[i]
        
        return max_kadane if max_circular == 0 else max(max_kadane, max_circular)


================================================================================
Date: 2025-07-26
Problem: Majority Element II
Filename: 2025-07-26_Majority_Element_II.py
================================================================================

class Solution:
    def findMajority(self, arr):
        n, a, b, ca, cb = len(arr), 0, 1, 0, 0
        for x in arr:
            if x == a: ca += 1
            elif x == b: cb += 1
            elif ca == 0: a, ca = x, 1
            elif cb == 0: b, cb = x, 1
            else: ca, cb = ca - 1, cb - 1
        ca = cb = 0
        for x in arr:
            if x == a: ca += 1
            elif x == b: cb += 1
        res = []
        if ca > n // 3: res.append(a)
        if cb > n // 3 and a != b: res.append(b)
        return sorted(res)


================================================================================
Date: 2025-07-27
Problem: Set Matrix Zeros
Filename: 2025-07-27_Set_Matrix_Zeros.py
================================================================================

class Solution:
    def setMatrixZeroes(self, mat):
        n, m = len(mat), len(mat[0])
        row0 = any(mat[0][j] == 0 for j in range(m))
        col0 = any(mat[i][0] == 0 for i in range(n))
        for i in range(1, n):
            for j in range(1, m):
                if mat[i][j] == 0:
                    mat[i][0] = mat[0][j] = 0
        for i in range(1, n):
            for j in range(1, m):
                if mat[i][0] == 0 or mat[0][j] == 0:
                    mat[i][j] = 0
        if row0:
            for j in range(m): mat[0][j] = 0
        if col0:
            for i in range(n): mat[i][0] = 0


================================================================================
Date: 2025-07-28
Problem: Make Matrix Beautiful
Filename: 2025-07-28_Make_Matrix_Beautiful.py
================================================================================

class Solution:
    def balanceSums(self, mat):
        n, max_sum, res = len(mat), 0, 0
        for i in range(n):
            sum_val = sum(mat[i])
            max_sum = max(sum_val, max_sum)
        for j in range(n):
            sum_val = sum(mat[i][j] for i in range(n))
            max_sum = max(sum_val, max_sum)
        for i in range(n):
            res += max_sum - sum(mat[i])
        return res


================================================================================
Date: 2025-07-29
Problem: ASCII Range Sum
Filename: 2025-07-29_ASCII_Range_Sum.py
================================================================================

class Solution:
    def asciirange(self, s):
        result = []
        positions = {}
        
        for i, char in enumerate(s):
            if char not in positions:
                positions[char] = [i, i]
            else:
                positions[char][1] = i
        
        for char in sorted(positions.keys()):
            first, last = positions[char]
            if last > first:
                total = sum(ord(s[j]) for j in range(first + 1, last))
                if total:
                    result.append(total)
        
        return result


================================================================================
Date: 2025-07-30
Problem: Subarrays with sum K
Filename: 2025-07-30_Subarrays_with_sum_K.py
================================================================================

class Solution:
    def cntSubarrays(self, arr, k):
        mp, s, cnt = {0: 1}, 0, 0
        for x in arr:
            s += x
            cnt += mp.get(s - k, 0)
            mp[s] = mp.get(s, 0) + 1
        return cnt


================================================================================
Date: 2025-07-31
Problem: Powerful Integer
Filename: 2025-07-31_Powerful_Integer.py
================================================================================

from collections import defaultdict

class Solution:
    def powerfulInteger(self, intervals, k):
        events = defaultdict(int)
        for start, end in intervals:
            events[start] += 1
            events[end + 1] -= 1
        
        count, result = 0, -1
        for pos in sorted(events.keys()):
            if events[pos] > 0:
                count += events[pos]
                if count >= k:
                    result = pos
            else:
                if count >= k:
                    result = pos - 1
                count += events[pos]
        return result


================================================================================
Date: 2025-08-01
Problem: Balancing Consonants and Vowels Ratio
Filename: 2025-08-01_Balancing_Consonants_and_Vowels_Ratio.py
================================================================================

class Solution:
    def countBalanced(self, arr):
        mp, s, res = {0: 1}, 0, 0
        for string in arr:
            s += sum(1 if c in 'aeiou' else -1 for c in string)
            res += mp.get(s, 0)
            mp[s] = mp.get(s, 0) + 1
        return res


================================================================================
Date: 2025-08-02
Problem: Longest Subarray with Majority Greater than K
Filename: 2025-08-02_Longest_Subarray_with_Majority_Greater_than_K.py
================================================================================

class Solution:
    def longestSubarray(self, arr, k):
        mp, ans, s = {0: -1}, 0, 0
        for i, x in enumerate(arr):
            s += -1 if x <= k else 1
            if s > 0: ans = i + 1
            elif s - 1 in mp: ans = max(ans, i - mp[s - 1])
            mp.setdefault(s, i)
        return ans


================================================================================
Date: 2025-08-03
Problem: 2D Difference Array
Filename: 2025-08-03_2D_Difference_Array.py
================================================================================

class Solution:
    def applyDiff2D(self, mat, opr):
        n, m = len(mat), len(mat[0])
        d = [[0] * (m + 1) for _ in range(n + 1)]
        
        for v, r1, c1, r2, c2 in opr:
            d[r1][c1] += v
            d[r1][c2 + 1] -= v
            d[r2 + 1][c1] -= v
            d[r2 + 1][c2 + 1] += v
        
        for i in range(n):
            for j in range(m):
                if i: d[i][j] += d[i - 1][j]
                if j: d[i][j] += d[i][j - 1]
                if i and j: d[i][j] -= d[i - 1][j - 1]
                mat[i][j] += d[i][j]
        return mat


================================================================================
Date: 2025-08-04
Problem: Maximum sum Rectangle
Filename: 2025-08-04_Maximum_sum_Rectangle.py
================================================================================

class Solution:
    def maxRectSum(self, mat):
        m, n, res = len(mat), len(mat[0]), float('-inf')
        for l in range(n):
            temp = [0] * m
            for r in range(l, n):
                for i in range(m):
                    temp[i] += mat[i][r]
                sum_val, max_sum = 0, temp[0]
                for x in temp:
                    sum_val = max(x, sum_val + x)
                    max_sum = max(max_sum, sum_val)
                res = max(res, max_sum)
        return res


================================================================================
Date: 2025-08-05
Problem: Palindrome Sentence
Filename: 2025-08-05_Palindrome_Sentence.py
================================================================================

class Solution:
    def isPalinSent(self, s):
        l, r = 0, len(s) - 1
        while l < r:
            while l < r and not s[l].isalnum(): l += 1
            while l < r and not s[r].isalnum(): r -= 1
            if s[l].lower() != s[r].lower(): return False
            l, r = l + 1, r - 1
        return True


================================================================================
Date: 2025-08-06
Problem: Roman Number to Integer
Filename: 2025-08-06_Roman_Number_to_Integer.py
================================================================================

class Solution:
    def romanToDecimal(self, s): 
        vals = [1000,900,500,400,100,90,50,40,10,9,5,4,1]
        syms = ["M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"]
        res = i = 0
        for j in range(13):
            while i + len(syms[j]) <= len(s) and s[i:i+len(syms[j])] == syms[j]:
                res += vals[j]
                i += len(syms[j])
        return res


================================================================================
Date: 2025-08-07
Problem: Difference Check
Filename: 2025-08-07_Difference_Check.py
================================================================================

class Solution:
    def minDifference(self, arr):
        mins = []
        for t in arr:
            h = int(t[:2])
            m = int(t[3:5])
            s = int(t[6:8])
            mins.append(h * 3600 + m * 60 + s)
        mins.sort()
        res = mins[0] + 86400 - mins[-1]
        for i in range(1, len(mins)):
            res = min(res, mins[i] - mins[i-1])
        return res


================================================================================
Date: 2025-08-08
Problem: Longest Prefix Suffix
Filename: 2025-08-08_Longest_Prefix_Suffix.py
================================================================================

class Solution:
    def getLPSLength(self, s):
        n, j, lps = len(s), 0, [0] * len(s)
        i = 1
        while i < n:
            if s[i] == s[j]:
                j += 1
                lps[i] = j
                i += 1
            elif j:
                j = lps[j - 1]
            else:
                i += 1
        return lps[-1]


================================================================================
Date: 2025-08-09
Problem: Longest Periodic Proper Prefix
Filename: 2025-08-09_Longest_Periodic_Proper_Prefix.py
================================================================================

class Solution:
    def getLongestPrefix(self, s):
        n, l, r, ans = len(s), 0, 0, -1
        z = [0] * n
        for i in range(1, n):
            if i <= r:
                z[i] = min(r - i + 1, z[i - l])
            while i + z[i] < n and s[z[i]] == s[i + z[i]]:
                z[i] += 1
            if i + z[i] - 1 > r:
                l, r = i, i + z[i] - 1
            if z[i] == n - i:
                ans = i
        return ans


================================================================================
Date: 2025-08-10
Problem: Palindrome SubStrings
Filename: 2025-08-10_Palindrome_SubStrings.py
================================================================================

class Solution:
    def countPS(self, s):
        n, ans = len(s), 0
        def go(l, r):
            nonlocal ans
            while l >= 0 and r < n and s[l] == s[r]:
                ans += 1
                l -= 1
                r += 1
        for i in range(n):
            go(i-1, i+1)
            go(i, i+1)
        return ans


================================================================================
Date: 2025-08-11
Problem: Maximum Non-Overlapping Odd Palindrome Sum
Filename: 2025-08-11_Maximum_Non-Overlapping_Odd_Palindrome_Sum.py
================================================================================

class Solution:
    def maxSum(self, s):
        n = len(s)
        left, right, rad = [1] * n, [1] * n, [0] * n
        l, r = 0, -1
        
        for i in range(n):
            k = 1 if i > r else min(rad[l + r - i], r - i + 1)
            while i - k >= 0 and i + k < n and s[i - k] == s[i + k]:
                k += 1
            rad[i] = k
            k -= 1
            if i + k > r:
                l, r = i - k, i + k
        
        for i in range(n):
            length = rad[i] * 2 - 1
            end = i + rad[i] - 1
            if end < n:
                left[end] = max(left[end], length)
        
        for i in range(n - 2, -1, -1):
            left[i] = max(left[i], left[i + 1] - 2)
        for i in range(1, n):
            left[i] = max(left[i], left[i - 1])
        
        for i in range(n - 1, -1, -1):
            length = rad[i] * 2 - 1
            start = i - rad[i] + 1
            if start >= 0:
                right[start] = max(right[start], length)
        
        for i in range(1, n):
            right[i] = max(right[i], right[i - 1] - 2)
        for i in range(n - 2, -1, -1):
            right[i] = max(right[i], right[i + 1])
        
        ans = 1
        for i in range(n - 1):
            ans = max(ans, left[i] + right[i + 1])
        return ans


================================================================================
Date: 2025-08-12
Problem: Shop in Candy Store
Filename: 2025-08-12_Shop_in_Candy_Store.py
================================================================================

class Solution:
    def minMaxCandy(self, prices, k):
        prices.sort()
        n, min_, max_ = len(prices), 0, 0
        i, rem = 0, n
        while i < rem:
            min_ += prices[i]; i += 1; rem -= k
        j, idx = n - 1, -1
        while j > idx:
            max_ += prices[j]; j -= 1; idx += k
        return [min_, max_]


================================================================================
Date: 2025-08-13
Problem: Tywins War Strategy
Filename: 2025-08-13_Tywins_War_Strategy.py
================================================================================

class Solution:
    def minSoldiers(self, arr, k):
        import heapq
        need, costs = (len(arr) + 1) // 2, []
        for x in arr: heapq.heappush(costs, 0 if x % k == 0 else k - x % k)
        return sum(heapq.heappop(costs) for _ in range(need))


================================================================================
Date: 2025-08-14
Problem: Count Reverse Pairs
Filename: 2025-08-14_Count_Reverse_Pairs.py
================================================================================

class Solution:
    def countRevPairs(self, arr):
        def mergeSort(l, r):
            if l >= r: return 0
            m = (l + r) // 2
            return mergeSort(l, m) + mergeSort(m + 1, r) + merge(l, m, r)
        
        def merge(l, m, r):
            cnt = j = 0
            for i in range(l, m + 1):
                while m + 1 + j <= r and arr[i] > 2 * arr[m + 1 + j]: j += 1
                cnt += j
            arr[l:r+1] = sorted(arr[l:r+1])
            return cnt
        
        return mergeSort(0, len(arr) - 1)


================================================================================
Date: 2025-08-15
Problem: Insert Interval
Filename: 2025-08-15_Insert_Interval.py
================================================================================

class Solution:
    def insertInterval(self, intervals, newInterval):
        result = []
        i = 0
        
        while i < len(intervals) and intervals[i][1] < newInterval[0]:
            result.append(intervals[i])
            i += 1
        
        while i < len(intervals) and intervals[i][0] <= newInterval[1]:
            newInterval[0] = min(newInterval[0], intervals[i][0])
            newInterval[1] = max(newInterval[1], intervals[i][1])
            i += 1
        result.append(newInterval)
        
        while i < len(intervals):
            result.append(intervals[i])
            i += 1
            
        return result


================================================================================
Date: 2025-08-16
Problem: Form the Largest Number
Filename: 2025-08-16_Form_the_Largest_Number.py
================================================================================

class Solution:
    def findLargest(self, arr):
        s = sorted(map(str, arr), key=cmp_to_key(lambda x, y: -1 if x + y > y + x else 1))
        return '0' if s[0] == '0' else ''.join(s)


================================================================================
Date: 2025-08-17
Problem: Sort by Absolute Difference
Filename: 2025-08-17_Sort_by_Absolute_Difference.py
================================================================================

class Solution:
    def rearrange(self, arr, x):
        arr.sort(key=lambda val: abs(val - x))


================================================================================
Date: 2025-08-18
Problem: Find H-Index
Filename: 2025-08-18_Find_H-Index.py
================================================================================

class Solution:
    def hIndex(self, citations):
        n = len(citations)
        bucket = [0] * (n + 1)
        
        for c in citations:
            bucket[min(c, n)] += 1
        
        count = 0
        for i in range(n, -1, -1):
            count += bucket[i]
            if count >= i:
                return i
        return 0


================================================================================
Date: 2025-08-19
Problem: Farthest Smaller Right
Filename: 2025-08-19_Farthest_Smaller_Right.py
================================================================================

class Solution:
    def farMin(self, arr):
        n = len(arr)
        ans = []
        suff = [0] * n
        suff[n-1] = arr[n-1]
        for i in range(n-2, -1, -1):
            suff[i] = min(arr[i], suff[i+1])
        for i in range(n):
            lo, hi, res = i+1, n-1, -1
            while lo <= hi:
                mid = lo + (hi-lo)//2
                if suff[mid] < arr[i]:
                    res = mid
                    lo = mid+1
                else:
                    hi = mid-1
            ans.append(res)
        return ans


================================================================================
Date: 2025-08-20
Problem: Search in fully rotated sorted 2D matrix
Filename: 2025-08-20_Search_in_fully_rotated_sorted_2D_matrix.py
================================================================================

class Solution:
    def searchMatrix(self, mat, x):
        n, m = len(mat), len(mat[0])
        l, r = 0, n * m - 1
        while l <= r:
            mid = l + (r - l) // 2
            val = mat[mid // m][mid % m]
            if val == x: return True
            if mat[l // m][l % m] <= val:
                if mat[l // m][l % m] <= x < val: r = mid - 1
                else: l = mid + 1
            else:
                if val < x <= mat[r // m][r % m]: l = mid + 1
                else: r = mid - 1
        return False


================================================================================
Date: 2025-08-21
Problem: Maximize the minimum difference between k elements
Filename: 2025-08-21_Maximize_the_minimum_difference_between_k_elements.py
================================================================================

class Solution:
    def maxMinDiff(self, a, k):
        a.sort()
        l, r, ans = 0, a[-1] - a[0], 0
        while l <= r:
            m = (l + r) // 2
            cnt, last = 1, a[0]
            for x in a[1:]:
                if x - last >= m:
                    cnt += 1
                    last = x
                    if cnt == k: break
            if cnt >= k:
                ans, l = m, m + 1
            else:
                r = m - 1
        return ans


================================================================================
Date: 2025-08-22
Problem: Median in a row-wise sorted Matrix
Filename: 2025-08-22_Median_in_a_row-wise_sorted_Matrix.py
================================================================================

import bisect
class Solution:
    def median(self, mat):
        n, m = len(mat), len(mat[0])
        lo = min(row[0] for row in mat)
        hi = max(row[m-1] for row in mat)
        req = (n * m + 1) // 2
        while lo < hi:
            mid = (lo + hi) // 2
            cnt = sum(bisect.bisect_right(row, mid) for row in mat)
            if cnt < req:
                lo = mid + 1
            else:
                hi = mid
        return lo


================================================================================
Date: 2025-08-23
Problem: Allocate Minimum Pages
Filename: 2025-08-23_Allocate_Minimum_Pages.py
================================================================================

class Solution:
    def findPages(self, arr, k):
        if k > len(arr): return -1
        l, r = max(arr), sum(arr)
        while l < r:
            m = (l + r) // 2
            s, p = 1, 0
            for x in arr:
                if p + x > m: s, p = s + 1, x
                else: p += x
            r, l = (m, l) if s <= k else (r, m + 1)
        return l


================================================================================
Date: 2025-08-24
Problem: Minimum days to make M bouquets
Filename: 2025-08-24_Minimum_days_to_make_M_bouquets.py
================================================================================

class Solution:
    def minDaysBloom(self, arr, k, m):
        if k * m > len(arr): return -1
        l, r = min(arr), max(arr)
        while l < r:
            mid = (l + r) // 2
            flowers = bouquets = 0
            for bloom in arr:
                if bloom <= mid:
                    flowers += 1
                    if flowers == k:
                        bouquets += 1
                        flowers = 0
                else:
                    flowers = 0
            if bouquets >= m:
                r = mid
            else:
                l = mid + 1
        return l


================================================================================
Date: 2025-08-25
Problem: Maximize median after doing k addition operation
Filename: 2025-08-25_Maximize_median_after_doing_k_addition_operation.py
================================================================================

class Solution:
    def maximizeMedian(self, arr, k):
        arr.sort()
        n = len(arr)
        left = arr[n//2] if n % 2 == 1 else (arr[n//2-1] + arr[n//2]) // 2
        right = left + k
        result = left
        
        while left <= right:
            mid = left + (right - left) // 2
            if self.canAchieve(arr, mid, k):
                result = mid
                left = mid + 1
            else:
                right = mid - 1
        return result
    
    def canAchieve(self, arr, target, k):
        n = len(arr)
        ops = 0
        
        if n % 2 == 1:
            for i in range(n//2, n):
                if arr[i] < target:
                    ops += target - arr[i]
                    if ops > k:
                        return False
        else:
            median_sum = arr[n//2-1] + arr[n//2]
            if 2 * target > median_sum:
                ops += 2 * target - median_sum
                if ops > k:
                    return False
            for i in range(n//2+1, n):
                if arr[i] < target:
                    ops += target - arr[i]
                    if ops > k:
                        return False
        return True


================================================================================
Date: 2025-08-26
Problem: Check if a String is Subsequence of Other
Filename: 2025-08-26_Check_if_a_String_is_Subsequence_of_Other.py
================================================================================

class Solution:
    def isSubSeq(self, s1, s2):
        i = 0
        for c in s2:
            if i < len(s1) and s1[i] == c:
                i += 1
        return i == len(s1)


================================================================================
Date: 2025-08-27
Problem: Count the number of possible triangles
Filename: 2025-08-27_Count_the_number_of_possible_triangles.py
================================================================================

class Solution:
    def countTriangles(self, a):
        a.sort()
        c, n = 0, len(a)
        for k in range(n - 1, 1, -1):
            i, j = 0, k - 1
            while i < j:
                if a[i] + a[j] > a[k]:
                    c += j - i
                    j -= 1
                else:
                    i += 1
        return c


================================================================================
Date: 2025-08-28
Problem: Maximize Number of 1s
Filename: 2025-08-28_Maximize_Number_of_1s.py
================================================================================

class Solution:
    def maxOnes(self, arr, k):
        l = zeros = maxLen = 0
        for r in range(len(arr)):
            zeros += (arr[r] == 0)
            while zeros > k:
                zeros -= (arr[l] == 0)
                l += 1
            maxLen = max(maxLen, r - l + 1)
        return maxLen


================================================================================
Date: 2025-08-29
Problem: Smallest window containing all characters
Filename: 2025-08-29_Smallest_window_containing_all_characters.py
================================================================================

class Solution:
    def smallestWindow(self, s, p):
        m, n = len(s), len(p)
        if m < n: return ""
        need = [0] * 256
        for c in p: need[ord(c)] += 1
        missing, start, min_start, min_len = n, 0, 0, float('inf')
        for end in range(m):
            if need[ord(s[end])] > 0: missing -= 1
            need[ord(s[end])] -= 1
            while missing == 0:
                if end - start + 1 < min_len:
                    min_len = end - start + 1
                    min_start = start
                need[ord(s[start])] += 1
                if need[ord(s[start])] > 0: missing += 1
                start += 1
        return "" if min_len == float('inf') else s[min_start:min_start + min_len]


================================================================================
Date: 2025-08-30
Problem: The Celebrity Problem
Filename: 2025-08-30_The_Celebrity_Problem.py
================================================================================

class Solution:
    def celebrity(self, m):
        n, c = len(m), 0
        for i in range(1, n):
            if m[c][i]: c = i
        for i in range(n):
            if i != c and (m[c][i] or not m[i][c]): return -1
        return c


================================================================================
Date: 2025-08-31
Problem: Container With Most Water
Filename: 2025-08-31_Container_With_Most_Water.py
================================================================================

class Solution:
    def maxWater(self, h):
        l, r, ans = 0, len(h) - 1, 0
        while l < r:
            ans = max(ans, min(h[l], h[r]) * (r - l))
            l, r = (l + 1, r) if h[l] < h[r] else (l, r - 1)
        return ans


================================================================================
Date: 2025-09-01
Problem: Sum of Mode
Filename: 2025-09-01_Sum_of_Mode.py
================================================================================

class Solution:
    def sumOfModes(self, arr, k):
        n, sum_val = len(arr), 0
        freq = defaultdict(int)
        buckets = defaultdict(set)
        
        for i in range(k):
            freq[arr[i]] += 1
        
        for val, f in freq.items():
            buckets[f].add(val)
        
        max_freq = max(buckets.keys())
        sum_val += min(buckets[max_freq])
        
        for i in range(k, n):
            out, in_val = arr[i - k], arr[i]
            
            buckets[freq[out]].remove(out)
            if not buckets[freq[out]]:
                del buckets[freq[out]]
            
            freq[out] -= 1
            if freq[out] > 0:
                buckets[freq[out]].add(out)
            else:
                del freq[out]
            
            if freq[in_val] > 0:
                buckets[freq[in_val]].remove(in_val)
                if not buckets[freq[in_val]]:
                    del buckets[freq[in_val]]
            
            freq[in_val] += 1
            buckets[freq[in_val]].add(in_val)
            
            max_freq = max(buckets.keys())
            sum_val += min(buckets[max_freq])
        
        return sum_val


================================================================================
Date: 2025-09-02
Problem: Swap Kth nodes from ends
Filename: 2025-09-02_Swap_Kth_nodes_from_ends.py
================================================================================

'''
class Node:
    def __init__(self, x):
        self.data = x
        self.next = None
'''

class Solution:
    def swapKth(self, head, k):
        if not head: return head
        n, t = 0, head
        while t: n, t = n + 1, t.next
        if k > n or 2 * k - 1 == n: return head
        
        x, y, px, py = head, head, None, None
        for _ in range(k - 1): px, x = x, x.next
        for _ in range(n - k): py, y = y, y.next
        
        if px: px.next = y
        else: head = y
        if py: py.next = x  
        else: head = x
        
        x.next, y.next = y.next, x.next
        return head


================================================================================
Date: 2025-09-03
Problem: Reverse a Doubly Linked List
Filename: 2025-09-03_Reverse_a_Doubly_Linked_List.py
================================================================================

"""
class Node:
    def __init__(self, val):
        self.data = val
        self.next = None
        self.prev = None
"""

class Solution:
    def reverse(self, head):
        if not head or not head.next: return head
        curr = head
        while curr:
            curr.next, curr.prev = curr.prev, curr.next
            if not curr.prev: return curr
            curr = curr.prev
        return head


================================================================================
Date: 2025-09-04
Problem: Linked List Group Reverse
Filename: 2025-09-04_Linked_List_Group_Reverse.py
================================================================================

"""
class Node:
    def __init__(self, data):
		self.data = data
		self.next = None
"""

class Solution:
    def reverseKGroup(self, head, k):
        cur, cnt = head, 0
        while cur and cnt < k:
            cur = cur.next; cnt += 1
        if cnt < k:
            prev = None
            while head:
                nxt = head.next; head.next = prev; prev = head; head = nxt
            return prev
        cur = self.reverseKGroup(cur, k)
        while cnt:
            nxt = head.next; head.next = cur; cur = head; head = nxt; cnt -= 1
        return cur


================================================================================
Date: 2025-09-05
Problem: Sort a linked list of 0s 1s and 2s
Filename: 2025-09-05_Sort_a_linked_list_of_0s_1s_and_2s.py
================================================================================

'''
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
'''
	
class Solution:
    def segregate(self, head):
        if not head:
            return head
            
        zero = one = two = None
        z_tail = o_tail = t_tail = None
        
        while head:
            next_node = head.next
            head.next = None
            
            if head.data == 0:
                if not zero:
                    zero = z_tail = head
                else:
                    z_tail.next = head
                    z_tail = head
            elif head.data == 1:
                if not one:
                    one = o_tail = head
                else:
                    o_tail.next = head
                    o_tail = head
            else:
                if not two:
                    two = t_tail = head
                else:
                    t_tail.next = head
                    t_tail = head
            head = next_node
        
        if z_tail:
            head = zero
            z_tail.next = one if one else two
            if o_tail:
                o_tail.next = two
        elif o_tail:
            head = one
            o_tail.next = two
        else:
            head = two
            
        return head


================================================================================
Date: 2025-09-06
Problem: Find length of Loop
Filename: 2025-09-06_Find_length_of_Loop.py
================================================================================

'''
class Node:
    def __init__(self, data): 
        self.data = data
        self.next = None
'''

class Solution:
    def lengthOfLoop(self, head):
        s = f = head
        while f and f.next:
            s = s.next
            f = f.next.next
            if s == f:
                length = 0
                while True:
                    f = f.next
                    length += 1
                    if s == f:
                        break
                return length
        return 0


2)
class Solution:
    def lengthOfLoop(self, head):
        s, f = head, head
        while f and f.next:
            s, f = s.next, f.next.next
            if s == f:
                cnt = 1
                while s.next != f:
                    s, cnt = s.next, cnt + 1
                return cnt
        return 0


================================================================================
Date: 2025-09-07
Problem: Merge K sorted linked lists
Filename: 2025-09-07_Merge_K_sorted_linked_lists.py
================================================================================

'''
class Node:
    def _init_(self, x):
        self.data = x
        self.next = None
'''

import heapq

class Solution:
    def mergeKLists(self, arr):
        heap = []
        for i, head in enumerate(arr):
            if head: heapq.heappush(heap, (head.data, i, head))
        
        dummy = Node(-1)
        tail = dummy
        while heap:
            _, i, node = heapq.heappop(heap)
            tail.next = node
            tail = node
            if node.next: heapq.heappush(heap, (node.next.data, i, node.next))
        return dummy.next


================================================================================
Date: 2025-09-08
Problem: Merge Sort for Linked List
Filename: 2025-09-08_Merge_Sort_for_Linked_List.py
================================================================================

'''
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
'''

class Solution:
    def mergeSort(self, h):
        if not h or not h.next: return h
        s, f = h, h.next
        while f and f.next:
            s, f = s.next, f.next.next
        r = s.next
        s.next = None
        return self.merge(self.mergeSort(h), self.mergeSort(r))
    
    def merge(self, a, b):
        if not a: return b
        if not b: return a
        if a.data <= b.data:
            a.next = self.merge(a.next, b)
            return a
        b.next = self.merge(a, b.next)
        return b


================================================================================
Date: 2025-09-09
Problem: Assign Mice Holes
Filename: 2025-09-09_Assign_Mice_Holes.py
================================================================================

class Solution:
    def assignHole(self, m, h):
        m.sort()
        h.sort()
        return max(abs(a - b) for a, b in zip(m, h))


================================================================================
Date: 2025-09-10
Problem: Largest number in one swap
Filename: 2025-09-10_Largest_number_in_one_swap.py
================================================================================

class Solution:
    def largestSwap(self, s):
        s = list(s)
        n, l, r, maxIdx = len(s), -1, -1, len(s) - 1
        for i in range(n - 2, -1, -1):
            if s[i] > s[maxIdx]: maxIdx = i
            elif s[i] < s[maxIdx]: l, r = i, maxIdx
        if l != -1: s[l], s[r] = s[r], s[l]
        return ''.join(s)


================================================================================
Date: 2025-09-11
Problem: Minimum Jumps
Filename: 2025-09-11_Minimum_Jumps.py
================================================================================

class Solution:
    def minJumps(self, arr):
        n, jumps, far, end = len(arr), 0, 0, 0
        for i in range(n - 1):
            far = max(far, i + arr[i])
            if i == end:
                jumps += 1
                end = far
            if end >= n - 1:
                return jumps
        return -1


================================================================================
Date: 2025-09-12
Problem: Problem 12
Filename: 2025-09-12_Problem_12.py
================================================================================

class Solution:
    def getMinDiff(self, a, k):
        a.sort()
        n = len(a)
        ans = a[n-1] - a[0]
        for i in range(1, n):
            if a[i] >= k:
                mn = min(a[0] + k, a[i] - k)
                mx = max(a[n-1] - k, a[i-1] + k)
                ans = min(ans, mx - mn)
        return ans


================================================================================
Date: 2025-09-13
Problem: Problem 13
Filename: 2025-09-13_Problem_13.py
================================================================================

class Solution:
    def minCost(self, n, m, x, y):
        x.sort(reverse=True); y.sort(reverse=True)
        h = v = i = j = cost = 0; h = v = 1
        while i < len(x) and j < len(y):
            if x[i] > y[j]: cost += x[i] * h; v += 1; i += 1
            else: cost += y[j] * v; h += 1; j += 1
        while i < len(x): cost += x[i] * h; i += 1
        while j < len(y): cost += y[j] * v; j += 1
        return cost


================================================================================
Date: 2025-09-14
Problem: Gas Station
Filename: 2025-09-14_Gas_Station.py
================================================================================

class Solution:
    def startStation(self, gas, cost):
        total = curr = start = 0
        for i in range(len(gas)):
            diff = gas[i] - cost[i]
            total += diff
            curr += diff
            if curr < 0: start, curr = i + 1, 0
        return start if total >= 0 else -1


================================================================================
Date: 2025-09-15
Problem: String stack
Filename: 2025-09-15_String_stack.py
================================================================================

class Solution:
    def stringStack(self, pat, tar):
        i, j = len(pat) - 1, len(tar) - 1
        while i >= 0 and j >= 0:
            if pat[i] == tar[j]:
                i -= 1
                j -= 1
            else:
                i -= 2
        return j < 0


================================================================================
Date: 2025-09-16
Problem: Postfix Evaluation
Filename: 2025-09-16_Postfix_Evaluation.py
================================================================================

class Solution:
    def evaluatePostfix(self, arr):
        st = []
        for t in arr:
            if t in "+-*/^" and len(t) == 1:
                b, a = st.pop(), st.pop()
                if t == '/':
                    st.append(a // b)
                else:
                    st.append(a + b if t == '+' else a - b if t == '-' else 
                             a * b if t == '*' else a ** b)
            else:
                st.append(int(t))
        return st[-1]


================================================================================
Date: 2025-09-17
Problem: Decode the string
Filename: 2025-09-17_Decode_the_string.py
================================================================================

class Solution:
    def decodedString(self, s):
        st_str, st_num = [], []
        curr, num = "", 0
        
        for c in s:
            if c.isdigit():
                num = num * 10 + int(c)
            elif c == '[':
                st_str.append(curr)
                st_num.append(num)
                curr, num = "", 0
            elif c == ']':
                temp = curr
                curr = st_str.pop()
                cnt = st_num.pop()
                curr += temp * cnt
            else:
                curr += c
        return curr


================================================================================
Date: 2025-09-18
Problem: Next Greater Element in Circular Array
Filename: 2025-09-18_Next_Greater_Element_in_Circular_Array.py
================================================================================

class Solution:
    def nextGreater(self, arr):
        n = len(arr)
        res = [-1] * n
        stk = []
        for i in range(2 * n):
            while stk and arr[stk[-1]] < arr[i % n]:
                res[stk.pop()] = arr[i % n]
            if i < n:
                stk.append(i)
        return res


================================================================================
Date: 2025-09-19
Problem: Min Add to Make Parentheses Valid
Filename: 2025-09-19_Min_Add_to_Make_Parentheses_Valid.py
================================================================================

class Solution:
    def minParentheses(self, s):
        open = close = 0
        for c in s:
            if c == '(':
                open += 1
            elif c == ')':
                if open > 0:
                    open -= 1
                else:
                    close += 1
        return open + close


================================================================================
Date: 2025-09-20
Problem: Longest Subarray Length
Filename: 2025-09-20_Longest_Subarray_Length.py
================================================================================

class Solution:
    def longestSubarray(self, a):
        n, res = len(a), 0
        l, r, s = [-1] * n, [n] * n, []
        for i in range(n - 1, -1, -1):
            while s and a[s[-1]] <= a[i]: s.pop()
            if s: r[i] = s[-1]
            s.append(i)
        s.clear()
        for i in range(n):
            while s and a[s[-1]] <= a[i]: s.pop()
            if s: l[i] = s[-1]
            s.append(i)
            length = r[i] - l[i] - 1
            if length >= a[i]: res = max(res, length)
        return res


================================================================================
Date: 2025-09-21
Problem: Max rectangle
Filename: 2025-09-21_Max_rectangle.py
================================================================================

class Solution:
    def maxArea(self, mat):
        n, m, res = len(mat), len(mat[0]), 0
        h = [0] * m
        for i in range(n):
            for j in range(m):
                h[j] = h[j] + 1 if mat[i][j] else 0
            st = []
            for j in range(m + 1):
                cur = 0 if j == m else h[j]
                while st and h[st[-1]] > cur:
                    tp = st.pop()
                    w = j if not st else j - st[-1] - 1
                    res = max(res, h[tp] * w)
                st.append(j)
        return res


================================================================================
Date: 2025-09-22
Problem: Max of min for every window size
Filename: 2025-09-22_Max_of_min_for_every_window_size.py
================================================================================

class Solution:
    def maxOfMins(self, a):
        n = len(a)
        ans, mx, st = [], [0] * (n + 1), []
        
        for i in range(n + 1):
            while st and (i == n or a[st[-1]] >= a[i]):
                mid = st.pop()
                w = i - (st[-1] if st else -1) - 1
                mx[w] = max(mx[w], a[mid])
            st.append(i)
        
        ans = mx[1:n+1]
        for i in range(n - 2, -1, -1):
            ans[i] = max(ans[i], ans[i + 1])
        return ans


================================================================================
Date: 2025-09-23
Problem: Queue Reversal
Filename: 2025-09-23_Queue_Reversal.py
================================================================================

class Solution:
    def reverseQueue(self, q):
        s = []
        while q:
            s.append(q.popleft())
        while s:
            q.append(s.pop())


================================================================================
Date: 2025-09-24
Problem: Design MinMax Queue
Filename: 2025-09-24_Design_MinMax_Queue.py
================================================================================

from collections import deque

class SpecialQueue:
    def __init__(self):
        self.q = deque()
        self.mn = deque()
        self.mx = deque()
    
    def enqueue(self, x):
        self.q.append(x)
        while self.mn and self.mn[-1] > x: self.mn.pop()
        self.mn.append(x)
        while self.mx and self.mx[-1] < x: self.mx.pop()
        self.mx.append(x)
    
    def dequeue(self):
        f = self.q.popleft()
        if f == self.mn[0]: self.mn.popleft()
        if f == self.mx[0]: self.mx.popleft()
    
    def getFront(self): return self.q[0]
    def getMin(self): return self.mn[0]
    def getMax(self): return self.mx[0]


================================================================================
Date: 2025-09-25
Problem: Generate Binary Numbers
Filename: 2025-09-25_Generate_Binary_Numbers.py
================================================================================

class Solution:
    def generateBinary(self, n):
        return [bin(i)[2:] for i in range(1, n + 1)]


================================================================================
Date: 2025-09-26
Problem: Rotate Deque By K
Filename: 2025-09-26_Rotate_Deque_By_K.py
================================================================================

class Solution:    
    def rotateDeque(self, dq, type, k):
        n = len(dq)
        if n == 0 or k % n == 0: return
        k %= n
        
        if type == 1:
            for _ in range(k):
                dq.appendleft(dq.pop())
        else:
            for _ in range(k):
                dq.append(dq.popleft())


================================================================================
Date: 2025-09-27
Problem: Minimum K Consecutive Bit Flips
Filename: 2025-09-27_Minimum_K_Consecutive_Bit_Flips.py
================================================================================

class Solution:
    def kBitFlips(self, a, k):
        n, flips, flip = len(a), 0, 0
        for i in range(n):
            if i >= k and a[i - k] > 1: flip ^= 1
            if (a[i] ^ flip) == 0:
                if i + k > n: return -1
                a[i] = 2
                flip ^= 1
                flips += 1
        return flips


================================================================================
Date: 2025-09-28
Problem: Longest Bounded-Difference Subarray
Filename: 2025-09-28_Longest_Bounded-Difference_Subarray.py
================================================================================

class Solution:
    def longestSubarray(self, arr, x):
        from collections import deque
        minQ, maxQ = deque(), deque()
        n, l, start, maxLen = len(arr), 0, 0, 0
        for r in range(n):
            while minQ and arr[minQ[-1]] >= arr[r]: minQ.pop()
            while maxQ and arr[maxQ[-1]] <= arr[r]: maxQ.pop()
            minQ.append(r)
            maxQ.append(r)
            while arr[maxQ[0]] - arr[minQ[0]] > x:
                if l == minQ[0]: minQ.popleft()
                if l == maxQ[0]: maxQ.popleft()
                l += 1
            if r - l + 1 > maxLen:
                maxLen = r - l + 1
                start = l
        return arr[start:start + maxLen]


================================================================================
Date: 2025-09-29
Problem: Maximum subarray sum 2
Filename: 2025-09-29_Maximum_subarray_sum_2.py
================================================================================

class Solution:
    def maxSubarrSum(self, arr, a, b):
        n, res = len(arr), float('-inf')
        pre = [0] * (n + 1)
        for i in range(n): pre[i + 1] = pre[i] + arr[i]
        dq = []
        for i in range(a, n + 1):
            l, r = max(0, i - b), i - a
            while dq and pre[dq[-1]] >= pre[r]: dq.pop()
            dq.append(r)
            while dq and dq[0] < l: dq.pop(0)
            res = max(res, pre[i] - pre[dq[0]])
        return res


================================================================================
Date: 2025-09-30
Problem: Generate all binary strings
Filename: 2025-09-30_Generate_all_binary_strings.py
================================================================================

class Solution:
    def binstr(self, n):
        res = []
        for i in range(1 << n):
            s = ""
            for j in range(n - 1, -1, -1):
                s += '1' if (i >> j) & 1 else '0'
            res.append(s)
        return res


================================================================================
Date: 2025-10-01
Problem: All Unique Permutations of an array
Filename: 2025-10-01_All_Unique_Permutations_of_an_array.py
================================================================================

class Solution:
    def uniquePerms(self, arr):
        arr.sort()
        res = []
        def next_permutation(nums):
            n = len(nums)
            i = n - 2
            while i >= 0 and nums[i] >= nums[i + 1]:
                i -= 1
            if i < 0:
                return False
            j = n - 1
            while nums[j] <= nums[i]:
                j -= 1
            nums[i], nums[j] = nums[j], nums[i]
            nums[i + 1:] = reversed(nums[i + 1:])
            return True
        res.append(arr[:])
        while next_permutation(arr):
            res.append(arr[:])
        return res


================================================================================
Date: 2025-10-02
Problem: Unique K-Number Sum
Filename: 2025-10-02_Unique_K-Number_Sum.py
================================================================================

class Solution:
    def combinationSum(self, n, k):
        if n < k or n > 9 * k: return []
        res = []
        def bt(start, rem, left, cur):
            if left == 0:
                if rem == 0: res.append(cur[:])
                return
            for i in range(start, 10):
                if rem < i: break
                cur.append(i)
                bt(i + 1, rem - i, left - 1, cur)
                cur.pop()
        bt(1, n, k, [])
        return res


================================================================================
Date: 2025-10-03
Problem: Possible Words From Phone Digits
Filename: 2025-10-03_Possible_Words_From_Phone_Digits.py
================================================================================

class Solution:
    def possibleWords(self, arr):
        res = [""]
        keys = ["", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"]
        for d in arr:
            if d < 2 or d > 9: continue
            res = [s + c for s in res for c in keys[d]]
        return res


================================================================================
Date: 2025-10-04
Problem: Expression Add Operators
Filename: 2025-10-04_Expression_Add_Operators.py
================================================================================

class Solution:
    def findExpr(self, s, target):
        res = []
        def dfs(i, val, prev, path):
            if i == len(s):
                if val == target: res.append(path)
                return
            for j in range(i, len(s)):
                if j > i and s[i] == '0': break
                cur = int(s[i:j+1])
                if i == 0: dfs(j + 1, cur, cur, str(cur))
                else:
                    dfs(j + 1, val + cur, cur, path + '+' + str(cur))
                    dfs(j + 1, val - cur, -cur, path + '-' + str(cur))
                    dfs(j + 1, val - prev + prev * cur, prev * cur, path + '*' + str(cur))
        dfs(0, 0, 0, '')
        return res


================================================================================
Date: 2025-10-05
Problem: Rat in a Maze
Filename: 2025-10-05_Rat_in_a_Maze.py
================================================================================

class Solution:
    def ratInMaze(self, m):
        res = []
        n = len(m)
        if not m[0][0] or not m[n-1][n-1]: return res
        self.solve(0, 0, m, n, "", res)
        return res
    
    def solve(self, i, j, m, n, p, res):
        if i == n-1 and j == n-1:
            res.append(p)
            return
        m[i][j] = 0
        if i+1 < n and m[i+1][j]: self.solve(i+1, j, m, n, p+'D', res)
        if j-1 >= 0 and m[i][j-1]: self.solve(i, j-1, m, n, p+'L', res)
        if j+1 < n and m[i][j+1]: self.solve(i, j+1, m, n, p+'R', res)
        if i-1 >= 0 and m[i-1][j]: self.solve(i-1, j, m, n, p+'U', res)
        m[i][j] = 1


================================================================================
Date: 2025-10-06
Problem: The Knights tour problem
Filename: 2025-10-06_The_Knights_tour_problem.py
================================================================================

class Solution:
    def knightTour(self, n):
        b = [[-1] * n for _ in range(n)]
        dx, dy = [2, 1, -1, -2, -2, -1, 1, 2], [1, 2, 2, 1, -1, -2, -2, -1]
        def solve(x, y, s):
            if s == n * n: return True
            for i in range(8):
                nx, ny = x + dx[i], y + dy[i]
                if 0 <= nx < n and 0 <= ny < n and b[nx][ny] == -1:
                    b[nx][ny] = s
                    if solve(nx, ny, s + 1): return True
                    b[nx][ny] = -1
            return False
        b[0][0] = 0
        return b if solve(0, 0, 1) else []


================================================================================
Date: 2025-10-07
Problem: Bottom View of Binary Tree
Filename: 2025-10-07_Bottom_View_of_Binary_Tree.py
================================================================================

'''
class Node:
    def __init__(self, val):
        self.data = val
        self.right = None
        self.left = None
'''

class Solution:
    def bottomView(self, root):
        if not root: return []
        d = {}
        q = deque([(root, 0)])
        while q:
            node, hd = q.popleft()
            d[hd] = node.data
            if node.left: q.append((node.left, hd - 1))
            if node.right: q.append((node.right, hd + 1))
        return [d[k] for k in sorted(d)]


================================================================================
Date: 2025-10-08
Problem: Construct Tree from Preorder  Postorder
Filename: 2025-10-08_Construct_Tree_from_Preorder__Postorder.py
================================================================================

'''
class Node:
    def __init__(self, val):
        self.data = val
        self.right = None
        self.left = None

'''

class Solution:
    def constructTree(self, pre, post):
        self.idx = 0
        return self.build(pre, post, 0, len(post) - 1)
    
    def build(self, pre, post, l, r):
        root = Node(pre[self.idx])
        self.idx += 1
        if l != r and self.idx < len(pre):
            pos = post.index(pre[self.idx], l, r + 1)
            root.left = self.build(pre, post, l, pos)
            root.right = self.build(pre, post, pos + 1, r - 1)
        return root


================================================================================
Date: 2025-10-09
Problem: Postorder Traversal
Filename: 2025-10-09_Postorder_Traversal.py
================================================================================

'''
class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None
'''

class Solution:
    def postOrder(self, root):
        res = []
        curr = root
        while curr:
            if not curr.right:
                res.append(curr.data)
                curr = curr.left
            else:
                pred = curr.right
                while pred.left and pred.left != curr:
                    pred = pred.left
                if not pred.left:
                    res.append(curr.data)
                    pred.left = curr
                    curr = curr.right
                else:
                    pred.left = None
                    curr = curr.left
        res.reverse()
        return res


================================================================================
Date: 2025-10-10
Problem: ZigZag Tree Traversal
Filename: 2025-10-10_ZigZag_Tree_Traversal.py
================================================================================

'''
class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None
'''

class Solution:
    def zigZagTraversal(self, root):
        res = []
        if not root: return res
        q = deque([root])
        ltr = True
        while q:
            sz = len(q)
            lvl = [0] * sz
            for i in range(sz):
                node = q.popleft()
                idx = i if ltr else sz - 1 - i
                lvl[idx] = node.data
                if node.left: q.append(node.left)
                if node.right: q.append(node.right)
            ltr = not ltr
            res.extend(lvl)
        return res


================================================================================
Date: 2025-10-11
Problem: Maximum path sum
Filename: 2025-10-11_Maximum_path_sum.py
================================================================================

'''
class Node:
    def __init__(self,val):
        self.data = val
        self.left = None
        self.right = None
'''

class Solution:
    def findMaxSum(self, root): 
        self.res = float('-inf')
        
        def dfs(node):
            if not node: return 0
            l = max(0, dfs(node.left))
            r = max(0, dfs(node.right))
            self.res = max(self.res, node.data + l + r)
            return node.data + max(l, r)
        
        dfs(root)
        return self.res


================================================================================
Date: 2025-10-12
Problem: Distribute Candies
Filename: 2025-10-12_Distribute_Candies.py
================================================================================

'''
class Node:
    def __init__(self, val):
        self.data = val
        self.right = None
        self.left = None
'''

class Solution:
    def distCandy(self, root):
        self.moves = 0
        def dfs(n):
            if not n: return 0
            bal = n.data - 1 + dfs(n.left) + dfs(n.right)
            self.moves += abs(bal)
            return bal
        dfs(root)
        return self.moves


================================================================================
Date: 2025-10-13
Problem: Maximum Non-Adjacent Nodes Sum
Filename: 2025-10-13_Maximum_Non-Adjacent_Nodes_Sum.py
================================================================================

'''
class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None
'''

class Solution:
    def getMaxSum(self, root):
        def helper(node):
            if not node: return (0, 0)
            l = helper(node.left)
            r = helper(node.right)
            inc = node.data + l[1] + r[1]
            exc = max(l) + max(r)
            return (inc, exc)
        return max(helper(root))


================================================================================
Date: 2025-10-14
Problem: Sum of Nodes in BST Range
Filename: 2025-10-14_Sum_of_Nodes_in_BST_Range.py
================================================================================

"""
class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None
"""

class Solution:
    def nodeSum(self, root, l, r):
        if not root: return 0
        if root.data < l: return self.nodeSum(root.right, l, r)
        if root.data > r: return self.nodeSum(root.left, l, r)
        return root.data + self.nodeSum(root.left, l, r) + self.nodeSum(root.right, l, r)


================================================================================
Date: 2025-10-15
Problem: k-th Smallest in BST
Filename: 2025-10-15_k-th_Smallest_in_BST.py
================================================================================

'''
class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None
'''

class Solution:
    def kthSmallest(self, root, k): 
        s, n, c = [], root, 0
        while n or s:
            while n:
                s.append(n)
                n = n.left
            n = s.pop()
            c += 1
            if c == k: return n.data
            n = n.right
        return -1


================================================================================
Date: 2025-10-16
Problem: Remove BST keys outside given range
Filename: 2025-10-16_Remove_BST_keys_outside_given_range.py
================================================================================

'''
class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None
'''

class Solution:
    def removekeys(self, root, l, r):
        if not root: return None
        root.left = self.removekeys(root.left, l, r)
        root.right = self.removekeys(root.right, l, r)
        if root.data < l: return root.right
        if root.data > r: return root.left
        return root


================================================================================
Date: 2025-10-17
Problem: BST to greater sum tree
Filename: 2025-10-17_BST_to_greater_sum_tree.py
================================================================================

'''
class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None
'''

class Solution:
    def transformTree(self, root):
        self.s = 0
        def f(n):
            if not n: return
            f(n.right)
            temp = n.data
            n.data = self.s
            self.s += temp
            f(n.left)
        f(root)


================================================================================
Date: 2025-10-18
Problem: Median of BST
Filename: 2025-10-18_Median_of_BST.py
================================================================================

'''
class Node:

    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None
'''

class Solution:
    def findMedian(self, root):
        n, c = 0, root
        while c:
            if not c.left:
                n += 1
                c = c.right
            else:
                p = c.left
                while p.right and p.right != c:
                    p = p.right
                if not p.right:
                    p.right = c
                    c = c.left
                else:
                    p.right = None
                    n += 1
                    c = c.right
        k, med, c = (n + 1) // 2, -1, root
        while c:
            if not c.left:
                med += 1
                if med == k - 1:
                    return c.data
                c = c.right
            else:
                p = c.left
                while p.right and p.right != c:
                    p = p.right
                if not p.right:
                    p.right = c
                    c = c.left
                else:
                    p.right = None
                    med += 1
                    if med == k - 1:
                        return c.data
                    c = c.right
        return -1


================================================================================
Date: 2025-10-19
Problem: K closest Values
Filename: 2025-10-19_K_closest_Values.py
================================================================================

'''
class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None
'''

class Solution:
    def getKClosest(self, root, target, k):
        in_order, stack, curr = [], [], root
        while curr or stack:
            while curr:
                stack.append(curr)
                curr = curr.left
            curr = stack.pop()
            in_order.append(curr.data)
            curr = curr.right
        n, l, r, pos = len(in_order), 0, len(in_order) - 1, 0
        while l <= r:
            m = (l + r) // 2
            if in_order[m] <= target:
                pos, l = m, m + 1
            else:
                r = m - 1
        res, l, r = [], pos, pos + 1
        while k:
            if r >= n or (l >= 0 and abs(in_order[l] - target) <= abs(in_order[r] - target)):
                res.append(in_order[l])
                l -= 1
            else:
                res.append(in_order[r])
                r += 1
            k -= 1
        return res


================================================================================
Date: 2025-10-20
Problem: Number of BST From Array
Filename: 2025-10-20_Number_of_BST_From_Array.py
================================================================================

class Solution:
    def countBSTs(self, arr):
        n = len(arr)
        p = sorted((arr[i], i) for i in range(n))
        c = [0] * (n + 1)
        c[0] = c[1] = 1
        for i in range(2, n + 1):
            for j in range(i):
                c[i] += c[j] * c[i - j - 1]
        res = [0] * n
        for i in range(n):
            res[p[i][1]] = c[i] * c[n - i - 1]
        return res


================================================================================
Date: 2025-10-21
Problem: Top K Frequent in Array
Filename: 2025-10-21_Top_K_Frequent_in_Array.py
================================================================================

class Solution:
    def topKFreq(self, arr, k):
        freq = {}
        maxFreq = 0
        for x in arr:
            freq[x] = freq.get(x, 0) + 1
            maxFreq = max(maxFreq, freq[x])
        buckets = [[] for _ in range(maxFreq + 1)]
        for num, f in freq.items():
            buckets[f].append(num)
        res = []
        for i in range(maxFreq, 0, -1):
            buckets[i].sort(reverse=True)
            for x in buckets[i]:
                res.append(x)
                if len(res) == k:
                    return res
        return res

2)
from collections import Counter
class Solution:
    def topKFreq(self, a, k):
        f=Counter(a)
        return [x for x,_ in sorted(f.items(),key=lambda x:(-x[1],-x[0]))[:k]]


================================================================================
Date: 2025-10-22
Problem: Nearly sorted
Filename: 2025-10-22_Nearly_sorted.py
================================================================================

class Solution:
    def nearlySorted(self, arr, k):
        import heapq
        h = arr[:min(k + 1, len(arr))]
        heapq.heapify(h)
        idx = 0
        for i in range(k + 1, len(arr)):
            arr[idx] = heapq.heappop(h)
            heapq.heappush(h, arr[i])
            idx += 1
        while h:
            arr[idx] = heapq.heappop(h)
            idx += 1


================================================================================
Date: 2025-10-23
Problem: K Closest Points to Origin
Filename: 2025-10-23_K_Closest_Points_to_Origin.py
================================================================================

class Solution:
    def kClosest(self, points, k):
        points.sort(key=lambda x: x[0]**2 + x[1]**2)
        return points[:k]


================================================================================
Date: 2025-10-24
Problem: Split Array Subsequences
Filename: 2025-10-24_Split_Array_Subsequences.py
================================================================================

class Solution:
    def isPossible(self, a, k):
        freq, need = {}, {}
        for x in a:
            freq[x] = freq.get(x, 0) + 1
        for x in a:
            if not freq[x]:
                continue
            freq[x] -= 1
            if need.get(x, 0):
                need[x] -= 1
                need[x + 1] = need.get(x + 1, 0) + 1
            else:
                for i in range(1, k):
                    if freq.get(x + i, 0) <= 0:
                        return False
                    freq[x + i] -= 1
                need[x + k] = need.get(x + k, 0) + 1
        return True


================================================================================
Date: 2025-10-25
Problem: Minimum Steps to Halve Sum
Filename: 2025-10-25_Minimum_Steps_to_Halve_Sum.py
================================================================================

class Solution:
    def minOperations(self, arr):
        import heapq
        s = sum(arr)
        t = s / 2
        h = [-x for x in arr]
        heapq.heapify(h)
        ops = 0
        while s > t:
            x = -heapq.heappop(h)
            s -= x / 2
            heapq.heappush(h, -x / 2)
            ops += 1
        return ops


================================================================================
Date: 2025-10-26
Problem: Minimum Cost of ropes
Filename: 2025-10-26_Minimum_Cost_of_ropes.py
================================================================================

import heapq

class Solution:
    def minCost(self, arr):
        heapq.heapify(arr)
        res = 0
        while len(arr) > 1:
            sum_val = heapq.heappop(arr) + heapq.heappop(arr)
            res += sum_val
            heapq.heappush(arr, sum_val)
        return res


================================================================================
Date: 2025-10-27
Problem: Find K Smallest Sum Pairs
Filename: 2025-10-27_Find_K_Smallest_Sum_Pairs.py
================================================================================

class Solution:
    def kSmallestPair(self, arr1, arr2, k):
        res = []
        pq = [(arr1[i] + arr2[0], i, 0) for i in range(min(len(arr1), k))]
        heapq.heapify(pq)
        while k and pq:
            s, i, j = heapq.heappop(pq)
            res.append([arr1[i], arr2[j]])
            if j + 1 < len(arr2): heapq.heappush(pq, (arr1[i] + arr2[j + 1], i, j + 1))
            k -= 1
        return res


================================================================================
Date: 2025-10-28
Problem: Distance of nearest cell having 1
Filename: 2025-10-28_Distance_of_nearest_cell_having_1.py
================================================================================

class Solution:
    def nearest(self, grid):
        n, m = len(grid), len(grid[0])
        dist = [[-1] * m for _ in range(n)]
        q = []
        for i in range(n):
            for j in range(m):
                if grid[i][j] == 1:
                    dist[i][j] = 0
                    q.append((i, j))
        dx, dy = [0, 0, 1, -1], [1, -1, 0, 0]
        idx = 0
        while idx < len(q):
            x, y = q[idx]
            idx += 1
            for i in range(4):
                nx, ny = x + dx[i], y + dy[i]
                if 0 <= nx < n and 0 <= ny < m and dist[nx][ny] == -1:
                    dist[nx][ny] = dist[x][y] + 1
                    q.append((nx, ny))
        return dist


================================================================================
Date: 2025-10-29
Problem: Graph Diameter
Filename: 2025-10-29_Graph_Diameter.py
================================================================================

class Solution:
    def diameter(self, V, edges):
        adj = [[] for _ in range(V)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        def bfs(src):
            dist = [-1] * V
            q = deque([src])
            dist[src] = 0
            far, maxD = src, 0
            while q:
                u = q.popleft()
                for v in adj[u]:
                    if dist[v] == -1:
                        dist[v] = dist[u] + 1
                        q.append(v)
                        if dist[v] > maxD:
                            maxD = dist[v]
                            far = v
            return far, maxD
        end1, _ = bfs(0)
        _, diam = bfs(end1)
        return diam


================================================================================
Date: 2025-10-30
Problem: Replace Os with Xs
Filename: 2025-10-30_Replace_Os_with_Xs.py
================================================================================

class Solution:
    def fill(self, g):
        m, n = len(g), len(g[0])
        for i in range(m):
            for j in range(n):
                if g[i][j] == 'O': g[i][j] = '-'
        def dfs(i, j):
            if i < 0 or i >= m or j < 0 or j >= n or g[i][j] != '-': return
            g[i][j] = 'O'
            dfs(i + 1, j); dfs(i - 1, j); dfs(i, j + 1); dfs(i, j - 1)
        for i in range(m): dfs(i, 0); dfs(i, n - 1)
        for j in range(n): dfs(0, j); dfs(m - 1, j)
        for i in range(m):
            for j in range(n):
                if g[i][j] == '-': g[i][j] = 'X'


================================================================================
Date: 2025-10-31
Problem: Shortest Cycle
Filename: 2025-10-31_Shortest_Cycle.py
================================================================================

class Solution:
    def shortCycle(self, V, edges):
        from collections import deque
        adj = [[] for _ in range(V)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        res = float('inf')
        for i in range(V):
            d = [-1] * V
            p = [-1] * V
            q = deque([i])
            d[i] = 0
            while q:
                u = q.popleft()
                for v in adj[u]:
                    if d[v] == -1:
                        d[v] = d[u] + 1
                        p[v] = u
                        q.append(v)
                    elif p[u] != v:
                        res = min(res, d[u] + d[v] + 1)
        return -1 if res == float('inf') else res


================================================================================
Date: 2025-11-01
Problem: Course Schedule II
Filename: 2025-11-01_Course_Schedule_II.py
================================================================================

class Solution:
    def findOrder(self, n, prerequisites):
        g = [[] for _ in range(n)]
        d = [0] * n
        for a, b in prerequisites:
            g[b].append(a)
            d[a] += 1
        q = [i for i in range(n) if d[i] == 0]
        r = []
        while q:
            u = q.pop(0)
            r.append(u)
            for v in g[u]:
                d[v] -= 1
                if d[v] == 0: q.append(v)
        return r if len(r) == n else []


================================================================================
Date: 2025-11-02
Problem: Max DAG Edges
Filename: 2025-11-02_Max_DAG_Edges.py
================================================================================

class Solution:
    def maxEdgesToAdd(self, V, edges):
        return V * (V - 1) // 2 - len(edges)


================================================================================
Date: 2025-11-03
Problem: Safe States
Filename: 2025-11-03_Safe_States.py
================================================================================

class Solution:
    def safeNodes(self, V, edges):
        out, g = [0] * V, [[] for _ in range(V)]
        for u, v in edges: out[u] += 1; g[v].append(u)
        q, safe = [], [0] * V
        for i in range(V):
            if not out[i]: q.append(i); safe[i] = 1
        for u in q:
            for v in g[u]:
                if not safe[v]:
                    out[v] -= 1
                    if not out[v]: q.append(v); safe[v] = 1
        return [i for i in range(V) if safe[i]]


================================================================================
Date: 2025-11-04
Problem: Frog Jump
Filename: 2025-11-04_Frog_Jump.py
================================================================================

class Solution:
    def minCost(self, height):
        n = len(height)
        if n == 1: return 0
        a, b = 0, abs(height[1] - height[0])
        for i in range(2, n):
            c = min(b + abs(height[i] - height[i - 1]), a + abs(height[i] - height[i - 2]))
            a, b = b, c
        return b


================================================================================
Date: 2025-11-05
Problem: Get Minimum Squares
Filename: 2025-11-05_Get_Minimum_Squares.py
================================================================================

class Solution:
    def minSquares(self, n):
        s = int(n ** 0.5)
        if s * s == n: return 1
        for i in range(1, int(n ** 0.5) + 1):
            r = int((n - i * i) ** 0.5)
            if r * r == n - i * i: return 2
        while n % 4 == 0: n //= 4
        return 4 if n % 8 == 7 else 3


================================================================================
Date: 2025-11-06
Problem: Ways To Tile A Floor
Filename: 2025-11-06_Ways_To_Tile_A_Floor.py
================================================================================

class Solution:
    def numberOfWays(self, n):
        if n <= 1: return 1
        a, b = 1, 1
        for _ in range(n - 1):
            a, b = b, a + b
        return b


================================================================================
Date: 2025-11-07
Problem: Weighted Job Scheduling
Filename: 2025-11-07_Weighted_Job_Scheduling.py
================================================================================

class Solution: 
    def maxProfit(self, jobs):
        jobs.sort()
        n = len(jobs)
        dp = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            l, r, nxt = i + 1, n - 1, n
            while l <= r:
                m = (l + r) // 2
                if jobs[m][0] >= jobs[i][1]:
                    nxt = m
                    r = m - 1
                else:
                    l = m + 1
            dp[i] = max(jobs[i][2] + dp[nxt], dp[i + 1])
        return dp[0]


================================================================================
Date: 2025-11-09
Problem: Chocolate Pickup II
Filename: 2025-11-09_Chocolate_Pickup_II.py
================================================================================

class Solution: 
    def chocolatePickup(self, mat): 
        n, m = len(mat), len(mat[0])
        dp = [[[-1] * m for _ in range(m)] for _ in range(n)]
        
        def solve(i1, j1, j2):
            i2 = i1 + j1 - j2
            if i1 >= n or i2 >= n or j1 >= m or j2 >= m or i2 < 0:
                return -10**8
            if mat[i1][j1] == -1 or mat[i2][j2] == -1:
                return -10**8
            if i1 == n - 1 and j1 == m - 1 and j2 == m - 1:
                return mat[i1][j1]
            if dp[i1][j1][j2] != -1:
                return dp[i1][j1][j2]
            res = -10**8
            for d1 in range(2):
                for d2 in range(2):
                    res = max(res, solve(i1 + 1 - d1, j1 + d1, j2 + d2))
            res += mat[i1][j1]
            if i1 != i2:
                res += mat[i2][j2]
            dp[i1][j1][j2] = res
            return res
        
        return max(0, solve(0, 0, 0))


================================================================================
Date: 2025-11-10
Problem: Stock Buy and Sell with Cooldown
Filename: 2025-11-10_Stock_Buy_and_Sell_with_Cooldown.py
================================================================================

class Solution:
    def maxProfit(self, arr):
        if not arr:
            return 0
        n = len(arr)
        hold = -arr[0]
        sold = 0
        rest = 0
        for price in arr[1:]:
            prev_hold = hold
            prev_sold = sold
            prev_rest = rest
            hold = max(prev_hold, prev_rest - price)
            sold = prev_hold + price
            rest = max(prev_rest, prev_sold)
        return max(sold, rest)


================================================================================
Date: 2025-11-11
Problem: Shortest Common Supersequence
Filename: 2025-11-11_Shortest_Common_Supersequence.py
================================================================================

class Solution:
    def minSuperSeq(self, s1, s2):
        m, n = len(s1), len(s2)
        prev, curr = [0] * (n + 1), [0] * (n + 1)
        for j in range(n + 1): prev[j] = j
        for i in range(1, m + 1):
            curr[0] = i
            for j in range(1, n + 1):
                curr[j] = 1 + prev[j - 1] if s1[i - 1] == s2[j - 1] else 1 + min(prev[j], curr[j - 1])
            prev = curr[:]
        return prev[n]


================================================================================
Date: 2025-11-12
Problem: Wildcard Pattern Matching
Filename: 2025-11-12_Wildcard_Pattern_Matching.py
================================================================================

class Solution:
    def wildCard(self, txt, pat):
        n, m = len(txt), len(pat)
        dp = [[False] * (m + 1) for _ in range(n + 1)]

        # Empty pattern matches empty text
        dp[0][0] = True

        # Handle patterns starting with '*'
        for j in range(1, m + 1):
            if pat[j - 1] == '*':
                dp[0][j] = dp[0][j - 1]

        # Fill DP table
        for i in range(1, n + 1):
            for j in range(1, m + 1):
                if pat[j - 1] == txt[i - 1] or pat[j - 1] == '?':
                    dp[i][j] = dp[i - 1][j - 1]
                elif pat[j - 1] == '*':
                    dp[i][j] = dp[i - 1][j] or dp[i][j - 1]
                else:
                    dp[i][j] = False

        dp[0][0] = True
        for j in range(1, m + 1):
            if pat[j - 1] == '*': dp[0][j] = dp[0][j - 1]
        for i in range(1, n + 1):
            for j in range(1, m + 1):
                if pat[j - 1] == '*':
                    dp[i][j] = dp[i][j - 1] or dp[i - 1][j]
                elif pat[j - 1] == '?' or txt[i - 1] == pat[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1]
        return dp[n][m]


================================================================================
Date: 2025-11-13
Problem: Interleaved Strings
Filename: 2025-11-13_Interleaved_Strings.py
================================================================================

class Solution:
    def isInterleave(self, s1, s2, s3):
        if len(s1) + len(s2) != len(s3): return False
        n, m = len(s1), len(s2)
        dp = [False] * (m + 1)
        dp[0] = True
        for j in range(1, m + 1): dp[j] = dp[j - 1] and s2[j - 1] == s3[j - 1]
        for i in range(1, n + 1):
            dp[0] = dp[0] and s1[i - 1] == s3[i - 1]
            for j in range(1, m + 1):
                dp[j] = (dp[j] and s1[i - 1] == s3[i + j - 1]) or (dp[j - 1] and s2[j - 1] == s3[i + j - 1])
        return dp[m]


================================================================================
Date: 2025-11-14
Problem: Minimum Cost to Merge Stones
Filename: 2025-11-14_Minimum_Cost_to_Merge_Stones.py
================================================================================

class Solution:
    def mergeStones(self, stones, k):
        n = len(stones)
        if (n - 1) % (k - 1): return -1
        s = [0] * (n + 1)
        for i in range(n): s[i + 1] = s[i] + stones[i]
        dp = [[0] * n for _ in range(n)]
        for l in range(k, n + 1):
            for i in range(n - l + 1):
                j = i + l - 1
                dp[i][j] = float('inf')
                for m in range(i, j, k - 1):
                    dp[i][j] = min(dp[i][j], dp[i][m] + dp[m + 1][j])
                if (j - i) % (k - 1) == 0:
                    dp[i][j] += s[j + 1] - s[i]
        return dp[0][n - 1]


================================================================================
Date: 2025-11-15
Problem: Minimum Cost to Cut a Stick of length N
Filename: 2025-11-15_Minimum_Cost_to_Cut_a_Stick_of_length_N.py
================================================================================

class Solution:
    def minCutCost(self, n, cuts):
        cuts = [0] + sorted(cuts) + [n]
        m = len(cuts)
        dp = [[0] * m for _ in range(m)]
        for gap in range(2, m):
            for i in range(m - gap):
                j = i + gap
                dp[i][j] = float('inf')
                for k in range(i + 1, j):
                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + cuts[j] - cuts[i])
        return dp[0][m - 1]


================================================================================
Date: 2025-11-16
Problem: Longest Common Increasing Subsequence
Filename: 2025-11-16_Longest_Common_Increasing_Subsequence.py
================================================================================

class Solution:
    def LCIS(self, a, b):
        m, n = len(a), len(b)
        dp = [0] * n
        res = 0

        for i in range(m):
            cur = 0
            for j in range(n):
                if a[i] == b[j]:
                    dp[j] = max(dp[j], cur + 1)
                if b[j] < a[i]:
                    cur = max(cur, dp[j])
                res = max(res, dp[j])

        return res


================================================================================
Date: 2025-11-17
Problem: Max Sum Increasing Subsequence
Filename: 2025-11-17_Max_Sum_Increasing_Subsequence.py
================================================================================

class Solution:
    def maxSumIS(self, arr):
        n = len(arr)
        dp = arr[:]  
        for i in range(n):
            for j in range(i):
                if arr[j] < arr[i]:
                    dp[i] = max(dp[i], dp[j] + arr[i])
        return max(dp)


================================================================================
Date: 2025-11-18
Problem: Number of Ways to Arrive at Destination
Filename: 2025-11-18_Number_of_Ways_to_Arrive_at_Destination.py
================================================================================

from heapq import heappush, heappop
class Solution:
    def countPaths(self, V, edges):
        adj = [[] for _ in range(V)]
        for u, v, w in edges:
            adj[u].append((v, w))
            adj[v].append((u, w))
        dist = [float('inf')] * V
        ways = [0] * V
        dist[0] = 0
        ways[0] = 1
        pq = [(0, 0)]
        MOD = 10**9 + 7
        while pq:
            d, u = heappop(pq)
            if d > dist[u]:
                continue
            for v, w in adj[u]:
                if d + w < dist[v]:
                    dist[v] = d + w
                    ways[v] = ways[u]
                    heappush(pq, (dist[v], v))
                elif d + w == dist[v]:
                    ways[v] = (ways[v] + ways[u]) % MOD
                    
        return ways[V - 1]


================================================================================
Date: 2025-11-19
Problem: Path With Minimum Effort
Filename: 2025-11-19_Path_With_Minimum_Effort.py
================================================================================

from heapq import heappush, heappop

class Solution:
    def minCostPath(self, mat):
        n, m = len(mat), len(mat[0])
        dist = [[float('inf')] * m for _ in range(n)]
        pq = [(0, 0, 0)]
        dist[0][0] = 0
        dx, dy = [-1, 1, 0, 0], [0, 0, -1, 1]
        while pq:
            d, x, y = heappop(pq)
            if x == n - 1 and y == m - 1: return d
            if d > dist[x][y]: continue
            for i in range(4):
                nx, ny = x + dx[i], y + dy[i]
                if 0 <= nx < n and 0 <= ny < m:
                    nd = max(d, abs(mat[nx][ny] - mat[x][y]))
                    if nd < dist[nx][ny]:
                        dist[nx][ny] = nd
                        heappush(pq, (nd, nx, ny))
        return dist[n - 1][m - 1]


================================================================================
Date: 2025-11-20
Problem: Make Strings Equal
Filename: 2025-11-20_Make_Strings_Equal.py
================================================================================

class Solution:
    def minCost(self, s, t, transform, cost):
        INF = int(1e9)
        d = [[INF] * 26 for _ in range(26)]
        for i in range(26): d[i][i] = 0
        for i in range(len(transform)):
            u, v = ord(transform[i][0]) - ord('a'), ord(transform[i][1]) - ord('a')
            d[u][v] = min(d[u][v], cost[i])
        for k in range(26):
            for i in range(26):
                for j in range(26):
                    if d[i][k] < INF and d[k][j] < INF:
                        d[i][j] = min(d[i][j], d[i][k] + d[k][j])
        res = 0
        for i in range(len(s)):
            if s[i] == t[i]: continue
            mn, a, b = INF, ord(s[i]) - ord('a'), ord(t[i]) - ord('a')
            for c in range(26):
                if d[a][c] < INF and d[b][c] < INF:
                    mn = min(mn, d[a][c] + d[b][c])
            if mn == INF: return -1
            res += mn
        return res


================================================================================
Date: 2025-11-21
Problem: Shortest Path Using Atmost One Curved Edge
Filename: 2025-11-21_Shortest_Path_Using_Atmost_One_Curved_Edge.py
================================================================================

class Solution:
    def shortestPath(self, V, a, b, edges):
        from heapq import heappush,heappop
        g=[[] for _ in range(V)]
        for u,v,w1,w2 in edges:
            g[u].append((v,w1,w2))
            g[v].append((u,w1,w2))
        d=[[float('inf')]*2 for _ in range(V)]
        d[a][0]=0
        pq=[(0,a,0)]
        while pq:
            dist,u,c=heappop(pq)
            if dist>d[u][c]:continue
            for v,w1,w2 in g[u]:
                if d[v][c]>dist+w1:
                    d[v][c]=dist+w1
                    heappush(pq,(d[v][c],v,c))
                if not c and d[v][1]>dist+w2:
                    d[v][1]=dist+w2
                    heappush(pq,(d[v][1],v,1))
        res=min(d[b][0],d[b][1])
        return -1 if res==float('inf') else res


================================================================================
Date: 2025-11-22
Problem: Minimum Operations to Connect Hospitals
Filename: 2025-11-22_Minimum_Operations_to_Connect_Hospitals.py
================================================================================

class Solution:
    def minConnect(self, V, edges):
        comp, e = V, len(edges)
        if e < V - 1: return -1
        p = list(range(V))
        def find(x): 
            if p[x] != x: p[x] = find(p[x])
            return p[x]
        for u, v in edges:
            x, y = find(u), find(v)
            if x != y: p[x] = y; comp -= 1
        return comp - 1


================================================================================
Date: 2025-11-23
Problem: Maximum Stone Removal
Filename: 2025-11-23_Maximum_Stone_Removal.py
================================================================================

class Solution:
    def maxRemove(self, stones):
        p = {}
        def find(x):
            if x not in p: p[x] = x
            if p[x] != x: p[x] = find(p[x])
            return p[x]
        def union(x, y):
            p[find(x)] = find(y)
        for r, c in stones:
            union(r, ~c)
        return len(stones) - len({find(r) for r, c in stones})


================================================================================
Date: 2025-11-24
Problem: Second Best Minimum Spanning Tree
Filename: 2025-11-24_Second_Best_Minimum_Spanning_Tree.py
================================================================================

class Solution:
    def secondMST(self, V, edges):
        edges.sort(key=lambda x: x[2])
        p = list(range(V))
        r = [0] * V
        def find(x):
            if p[x] != x: p[x] = find(p[x])
            return p[x]
        def unite(a, b):
            a, b = find(a), find(b)
            if a == b: return False
            if r[a] < r[b]: a, b = b, a
            p[b] = a
            if r[a] == r[b]: r[a] += 1
            return True
        mst, tree = 0, []
        for u, v, w in edges:
            if unite(u, v):
                mst += w
                tree.append((u, v, w))
        ans = float('inf')
        for su, sv, sw in tree:
            p = list(range(V))
            r = [0] * V
            cost = cnt = 0
            for u, v, w in edges:
                if (u == su and v == sv) or (u == sv and v == su): continue
                if unite(u, v):
                    cost += w
                    cnt += 1
                    if cnt == V - 1: break
            if cnt == V - 1 and cost > mst: ans = min(ans, cost)
        return -1 if ans == float('inf') else ans


================================================================================
Date: 2025-11-25
Problem: Game of XOR
Filename: 2025-11-25_Game_of_XOR.py
================================================================================

class Solution:
    def subarrayXor(self, arr):
        xor_sum = 0
        n = len(arr)
        for i in range(n):
            if ((i + 1) * (n - i)) & 1: xor_sum ^= arr[i]
        return xor_sum


================================================================================
Date: 2025-11-26
Problem: AND In Range
Filename: 2025-11-26_AND_In_Range.py
================================================================================

class Solution:
    def andInRange(self, l, r):
        while l < r: r &= r - 1
        return r


================================================================================
Date: 2025-11-27
Problem: All Subsets Xor Sum
Filename: 2025-11-27_All_Subsets_Xor_Sum.py
================================================================================

class Solution:
    def subsetXORSum(self, arr):
        orVal = 0
        for x in arr: orVal |= x
        return orVal << (len(arr) - 1)


================================================================================
Date: 2025-11-28
Problem: Subset XOR
Filename: 2025-11-28_Subset_XOR.py
================================================================================

class Solution:
    def subsetXOR(self, n : int):
        ans, r = [], n & 3
        start = 2 if r == 2 else 1
        end = n - 1 if r == 3 else n
        for i in range(start, end + 1):
            if r != 1 or i != n - 1: ans.append(i)
        return ans


================================================================================
Date: 2025-11-29
Problem: Count set bits
Filename: 2025-11-29_Count_set_bits.py
================================================================================

class Solution:
    def countSetBits(self, n):
        ans = 0
        while n:
            x = n.bit_length() - 1
            if x == 0:
                ans += 1
                break
            ans += x * (1 << (x - 1)) + (n - (1 << x) + 1)
            n -= 1 << x
        return ans


================================================================================
Date: 2025-11-30
Problem: Count of distinct substrings
Filename: 2025-11-30_Count_of_distinct_substrings.py
================================================================================

class Solution:
    def countSubs(self, s):
        class Node:
            def __init__(self):
                self.c = [None] * 26
        root, cnt, n = Node(), 0, len(s)
        for i in range(n):
            cur = root
            for j in range(i, n):
                idx = ord(s[j]) - ord('a')
                if not cur.c[idx]:
                    cur.c[idx] = Node()
                    cnt += 1
                cur = cur.c[idx]
        return cnt


================================================================================
Date: 2025-12-01
Problem: XOR Pairs less than K
Filename: 2025-12-01_XOR_Pairs_less_than_K.py
================================================================================

class Solution:
    class Node:
        def __init__(self):
            self.ch = [None, None]
            self.cnt = 0
    def add(self, r, v):
        for i in range(31, -1, -1):
            b = (v >> i) & 1
            if not r.ch[b]: r.ch[b] = self.Node()
            r.ch[b].cnt += 1
            r = r.ch[b]
    def query(self, r, v, k):
        res = 0
        for i in range(31, -1, -1):
            if not r: break
            bv, bk = (v >> i) & 1, (k >> i) & 1
            if bk:
                if r.ch[bv]: res += r.ch[bv].cnt
                r = r.ch[1 - bv]
            else: r = r.ch[bv]
        return res
    def cntPairs(self, a, k):
        r = self.Node()
        ans = 0
        for x in a:
            ans += self.query(r, x, k)
            self.add(r, x)
        return ans


================================================================================
Date: 2025-12-02
Problem: Maximise String Score
Filename: 2025-12-02_Maximise_String_Score.py
================================================================================

class Solution:
    def maxScore(self, s, jumps):
        n = len(s)
        jumps += [[chr(c), chr(c)] for c in range(97, 123)]
        nxt = [[-1] * 26 for _ in range(n)]
        last = [-1] * 26
        for i in range(n - 1, -1, -1):
            nxt[i] = last[:]
            last[ord(s[i]) - 97] = i
        ch = [[] for _ in range(26)]
        for u, v in jumps:
            ch[ord(u) - 97].append(ord(v))
        pre = [0] * (n + 1)
        for i in range(n):
            pre[i + 1] = pre[i] + ord(s[i])
        dp = [0] * n
        for i in range(n - 2, -1, -1):
            for c in ch[ord(s[i]) - 97]:
                j = nxt[i][c - 97]
                if j != -1:
                    dp[i] = max(dp[i], pre[j] - pre[i + (c == ord(s[i]))] + dp[j])
        return dp[0]


================================================================================
Date: 2025-12-03
Problem: Travelling Salesman Problem
Filename: 2025-12-03_Travelling_Salesman_Problem.py
================================================================================

class Solution:
    def tsp(self, cost):
        n = len(cost)
        if n <= 1: return cost[0][0] if n else 0
        FULL = (1 << n) - 1
        dp = [[float('inf')] * n for _ in range(1 << n)]
        dp[1][0] = 0
        for mask in range(1, (1 << n)):
            for i in range(n):
                if not (mask & (1 << i)) or dp[mask][i] == float('inf'): continue
                for j in range(n):
                    if mask & (1 << j): continue
                    nxt = mask | (1 << j)
                    dp[nxt][j] = min(dp[nxt][j], dp[mask][i] + cost[i][j])
        ans = float('inf')
        for i in range(n):
            if dp[FULL][i] != float('inf'):
                ans = min(ans, dp[FULL][i] + cost[i][0])
        return ans


================================================================================
Date: 2025-12-04
Problem: Optimal binary search tree
Filename: 2025-12-04_Optimal_binary_search_tree.py
================================================================================

class Solution:
    def minCost(self, keys, freq):
        n = len(keys)
        dp = [[0] * n for _ in range(n)]
        ps = [0] * (n + 1)
        for i in range(n):
            ps[i + 1] = ps[i] + freq[i]
            dp[i][i] = freq[i]
        for l in range(2, n + 1):
            for i in range(n - l + 1):
                j = i + l - 1
                dp[i][j] = float('inf')
                fsum = ps[j + 1] - ps[i]
                for r in range(i, j + 1):
                    c = (dp[i][r - 1] if r > i else 0) + (dp[r + 1][j] if r < j else 0) + fsum
                    dp[i][j] = min(dp[i][j], c)
        return dp[0][n - 1]


================================================================================
Date: 2025-12-05
Problem: Walls Coloring II
Filename: 2025-12-05_Walls_Coloring_II.py
================================================================================

class Solution:
    def minCost(self, costs):
        n, m = len(costs), len(costs[0])
        if m == 1 and n > 1: return -1
        m1, m2, idx = 0, 0, -1
        for i in range(n):
            nm1, nm2, nidx = float('inf'), float('inf'), -1
            for j in range(m):
                c = costs[i][j] + (m2 if j == idx else m1)
                if c < nm1: nm2, nm1, nidx = nm1, c, j
                elif c < nm2: nm2 = c
            m1, m2, idx = nm1, nm2, nidx
        return m1


================================================================================
Date: 2025-12-06
Problem: Optimal Strategy For A Game
Filename: 2025-12-06_Optimal_Strategy_For_A_Game.py
================================================================================

class Solution:
    def maximumAmount(self, arr):
        n, s = len(arr), 0
        dp = [0] * n
        for i in range(n - 1, -1, -1):
            s += arr[i]
            for j in range(i, n):
                dp[j] = arr[j] if i == j else max(arr[i] - dp[j], arr[j] - dp[j - 1])
        return (s + dp[n - 1]) // 2


================================================================================
Date: 2025-12-07
Problem: Number of distinct subsequences
Filename: 2025-12-07_Number_of_distinct_subsequences.py
================================================================================

class Solution:
    def distinctSubseq(self, str):
        mod, res = 10**9 + 7, 1
        last = [0] * 26
        for c in str:
            idx = ord(c) - ord('a')
            cur = (2 * res - last[idx]) % mod
            last[idx] = res
            res = cur
        return res


================================================================================
Date: 2025-12-16
Problem: Problem 16
Filename: 2025-12-16_Problem_16.py
================================================================================


class Solution:
    def areRotations(self, s1, s2):
        # If lengths differ, they can't be rotations
        if len(s1) != len(s2):
            return False
        
        # s2 must appear inside s1+s1 if it's a rotation
        return s2 in (s1 + s1)


================================================================================
Date: 2025-12-19
Problem: Bus Conductor
Filename: 2025-12-19_Bus_Conductor.py
================================================================================

class Solution:
    def findMoves(self, c, p):
        c.sort()
        p.sort()
        return sum(abs(x - y) for x, y in zip(c, p))


================================================================================
Date: 2026-01-11
Problem: Minimum Window Subsequence
Filename: 2026-01-11_Minimum_Window_Subsequence.py
================================================================================

class Solution:
    def minWindow(self, s1, s2):
        m, n = len(s1), len(s2)
        start, minLen = -1, float('inf')
        i = j = 0
        while i < m:
            if s1[i] == s2[j]:
                j += 1
            if j == n:
                end = i
                j -= 1
                while j >= 0:
                    if s1[i] == s2[j]:
                        j -= 1
                    i -= 1
                i += 1
                j += 1
                if end - i + 1 < minLen:
                    minLen = end - i + 1
                    start = i
            i += 1
        return "" if start == -1 else s1[start:start + minLen]


================================================================================
Date: 2026-01-12
Problem: K Sized Subarray Maximum
Filename: 2026-01-12_K_Sized_Subarray_Maximum.py
================================================================================

class Solution:
    def maxOfSubarrays(self, arr, k):
        res, dq = [], []
        for i in range(len(arr)):
            if dq and dq[0] <= i - k: dq.pop(0)
            while dq and arr[dq[-1]] <= arr[i]: dq.pop()
            dq.append(i)
            if i >= k - 1: res.append(arr[dq[0]])
        return res


================================================================================
Date: 2026-01-13
Problem: Problem 13
Filename: 2026-01-13_Problem_13.py
================================================================================

class Solution:
    def canServe(self, arr):
        f = t = 0
        for x in arr:
            if x == 5: f += 1
            elif x == 10:
                if not f: return False
                f -= 1; t += 1
            else:
                if t and f: t -= 1; f -= 1
                elif f >= 3: f -= 3
                else: return False
        return True


================================================================================
Date: 2026-01-14
Problem: Police and Thieves
Filename: 2026-01-14_Police_and_Thieves.py
================================================================================

class Solution:
    def catchThieves(self, arr, k):
        n, p, t, cnt = len(arr), 0, 0, 0
        while p < n and t < n:
            while p < n and arr[p] != 'P': p += 1
            while t < n and arr[t] != 'T': t += 1
            if p < n and t < n and abs(p - t) <= k:
                cnt += 1
                p += 1
                t += 1
            elif t < n and t < p: t += 1
            elif p < n and p < t: p += 1
        return cnt


================================================================================
Date: 2026-01-15
Problem: Candy
Filename: 2026-01-15_Candy.py
================================================================================

class Solution:
    def minCandy(self, arr):
        n, total, i = len(arr), len(arr), 1
        while i < n:
            if arr[i] == arr[i - 1]:
                i += 1
                continue
            peak = 0
            while i < n and arr[i] > arr[i - 1]:
                peak += 1
                total += peak
                i += 1
            valley = 0
            while i < n and arr[i] < arr[i - 1]:
                valley += 1
                total += valley
                i += 1
            total -= min(peak, valley)
        return total


================================================================================
Date: 2026-01-16
Problem: Minimum Number of Workers
Filename: 2026-01-16_Minimum_Number_of_Workers.py
================================================================================

class Solution:
    def minMen(self, arr):
        n = len(arr)
        v = []
        for i in range(n):
            if arr[i] != -1:
                v.append((max(0, i - arr[i]), min(n - 1, i + arr[i])))
        if not v: return -1
        v.sort()
        cnt, pos, i = 0, -1, 0
        while pos < n - 1:
            if i >= len(v) or v[i][0] > pos + 1: return -1
            reach = pos
            while i < len(v) and v[i][0] <= pos + 1:
                reach = max(reach, v[i][1])
                i += 1
            cnt += 1
            pos = reach
        return cnt


================================================================================
Date: 2026-01-17
Problem: Expression contains redundant bracket or not
Filename: 2026-01-17_Expression_contains_redundant_bracket_or_not.py
================================================================================

class Solution:
    def checkRedundancy(self, s):
        st = []
        for c in s:
            if c == ')':
                op = False
                while st[-1] != '(':
                    if st.pop() in '+-*/': op = True
                st.pop()
                if not op: return True
            elif c == '(' or c in '+-*/':
                st.append(c)
        return False


================================================================================
Date: 2026-01-18
Problem: Next element with greater frequency
Filename: 2026-01-18_Next_element_with_greater_frequency.py
================================================================================

class Solution:
    def nextFreqGreater(self, arr):
        freq = {}
        for x in arr: freq[x] = freq.get(x, 0) + 1
        res = [-1] * len(arr)
        st = []
        for i in range(len(arr) - 1, -1, -1):
            while st and freq[arr[st[-1]]] <= freq[arr[i]]: st.pop()
            if st: res[i] = arr[st[-1]]
            st.append(i)
        return res


================================================================================
Date: 2026-01-19
Problem: Remove K Digits
Filename: 2026-01-19_Remove_K_Digits.py
================================================================================

class Solution:
    def removeKdig(self, s, k):
        stk = []
        for c in s:
            while stk and k and stk[-1] > c:
                stk.pop()
                k -= 1
            if stk or c != '0':
                stk.append(c)
        while stk and k:
            stk.pop()
            k -= 1
        return ''.join(stk) if stk else '0'


================================================================================
Date: 2026-01-20
Problem: Implement UNDO  REDO
Filename: 2026-01-20_Implement_UNDO__REDO.py
================================================================================

class Solution:
    def __init__(self):
        self.d = []
        self.r = []
    
    def append(self, x):
        self.d.append(x)
        self.r.clear()
    
    def undo(self):
        if self.d:
            self.r.append(self.d.pop())
    
    def redo(self):
        if self.r:
            self.d.append(self.r.pop())
    
    def read(self):
        return ''.join(self.d)


================================================================================
Date: 2026-01-21
Problem: Stock span problem
Filename: 2026-01-21_Stock_span_problem.py
================================================================================

class Solution:
    def calculateSpan(self, arr):
        n = len(arr)
        res = []
        s = []
        for i in range(n):
            while s and arr[s[-1]] <= arr[i]: s.pop()
            res.append(i + 1 if not s else i - s[-1])
            s.append(i)
        return res


================================================================================
Date: 2026-01-22
Problem: Sum of subarray ranges
Filename: 2026-01-22_Sum_of_subarray_ranges.py
================================================================================

class Solution:
    def subarrayRanges(self, a):
        n = len(a)
        res = 0
        s = []
        for i in range(n + 1):
            while s and (i == n or a[s[-1]] > a[i]):
                j = s.pop()
                k = s[-1] if s else -1
                res -= a[j] * (i - j) * (j - k)
            s.append(i)
        s.clear()
        for i in range(n + 1):
            while s and (i == n or a[s[-1]] < a[i]):
                j = s.pop()
                k = s[-1] if s else -1
                res += a[j] * (i - j) * (j - k)
            s.append(i)
        return res


================================================================================
Date: 2026-01-23
Problem: Maximum People Visible in a Line
Filename: 2026-01-23_Maximum_People_Visible_in_a_Line.py
================================================================================

class Solution:
    def maxPeople(self, arr):
        n = len(arr)
        l, r, s = [1] * n, [1] * n, []
        for i in range(n):
            while s and arr[s[-1]] < arr[i]: l[i] += l[s.pop()]
            s.append(i)
        s.clear()
        for i in range(n - 1, -1, -1):
            while s and arr[s[-1]] < arr[i]: r[i] += r[s.pop()]
            s.append(i)
        return max(l[i] + r[i] - 1 for i in range(n))


================================================================================
Date: 2026-01-24
Problem: Josephus problem
Filename: 2026-01-24_Josephus_problem.py
================================================================================

class Solution:
    def josephus(self, n, k):
        pos = 0
        for i in range(2, n + 1): pos = (pos + k) % i
        return pos + 1


================================================================================
Date: 2026-01-25
Problem: Number of Valid Parentheses
Filename: 2026-01-25_Number_of_Valid_Parentheses.py
================================================================================

class Solution:
    def findWays(self, n):
        if n & 1: return 0
        n >>= 1
        res = 1
        for i in range(n):
            res = res * (2 * n - i) // (i + 1)
        return res // (n + 1)


================================================================================
Date: 2026-01-26
Problem: Generate Permutations of an array
Filename: 2026-01-26_Generate_Permutations_of_an_array.py
================================================================================

class Solution:
    def permuteDist(self, arr):
        from itertools import permutations
        return [list(p) for p in permutations(arr)]


================================================================================
Date: 2026-01-27
Problem: Word Search
Filename: 2026-01-27_Word_Search.py
================================================================================

class Solution:
    def isWordExist(self, b, w):
        def search(r, c, idx):
            if idx == len(w): return True
            if r < 0 or c < 0 or r >= len(b) or c >= len(b[0]) or b[r][c] != w[idx]: return False
            tmp, b[r][c] = b[r][c], '*'
            res = search(r + 1, c, idx + 1) or search(r - 1, c, idx + 1) or search(r, c + 1, idx + 1) or search(r, c - 1, idx + 1)
            b[r][c] = tmp
            return res
        
        return any(search(i, j, 0) for i in range(len(b)) for j in range(len(b[0])))


================================================================================
Date: 2026-01-28
Problem: Count Subset With Target Sum II
Filename: 2026-01-28_Count_Subset_With_Target_Sum_II.py
================================================================================

class Solution:
    def countSubset(self, arr, k):
        n, m = len(arr), len(arr) // 2
        lf, rf = {}, {}
        def gen(i, e, s, f):
            if i == e: f[s] = f.get(s, 0) + 1; return
            gen(i + 1, e, s + arr[i], f)
            gen(i + 1, e, s, f)
        gen(0, m, 0, lf)
        gen(m, n, 0, rf)
        return sum(c * rf.get(k - s, 0) for s, c in lf.items())


================================================================================
Date: 2026-01-29
Problem: Stream First Non-repeating
Filename: 2026-01-29_Stream_First_Non-repeating.py
================================================================================

class Solution:
    def firstNonRepeating(self, s):
        freq = [0] * 26
        q = []
        res = []
        for c in s:
            freq[ord(c) - ord('a')] += 1
            q.append(c)
            while q and freq[ord(q[0]) - ord('a')] > 1:
                q.pop(0)
            res.append(q[0] if q else '#')
        return ''.join(res)


================================================================================
Date: 2026-02-06
Problem: Happiest Triplet
Filename: 2026-02-06_Happiest_Triplet.py
================================================================================

class Solution:
    def smallestDiff(self, a, b, c):
        a.sort()
        b.sort()
        c.sort()
        i = j = k = 0
        diff = float('inf')
        res = [0, 0, 0]
        while i < len(a) and j < len(b) and k < len(c):
            minVal = min(a[i], b[j], c[k])
            maxVal = max(a[i], b[j], c[k])
            midVal = a[i] + b[j] + c[k] - minVal - maxVal
            if maxVal - minVal < diff:
                diff = maxVal - minVal
                res = [maxVal, midVal, minVal]
            if minVal == a[i]: i += 1
            elif minVal == b[j]: j += 1
            else: k += 1
        return res


================================================================================
Date: 2026-02-07
Problem: Max sum in the configuration
Filename: 2026-02-07_Max_sum_in_the_configuration.py
================================================================================

class Solution:
    def maxSum(self, arr):
        n = len(arr)
        s = sum(arr)
        cur = sum(i * arr[i] for i in range(n))
        mx = cur
        for i in range(n - 1):
            cur += n * arr[i] - s
            mx = max(mx, cur)
        return mx


================================================================================
Date: 2026-02-08
Problem: Maximum Product Subarray
Filename: 2026-02-08_Maximum_Product_Subarray.py
================================================================================

class Solution:
    def maxProduct(self, arr):
        mx = mn = r = arr[0]
        for i in range(1, len(arr)):
            a, b = mx * arr[i], mn * arr[i]
            mx = max(a, b, arr[i])
            mn = min(a, b, arr[i])
            r = max(r, mx)
        return r


================================================================================
Date: 2026-02-09
Problem: Find Kth Rotation
Filename: 2026-02-09_Find_Kth_Rotation.py
================================================================================

class Solution:
    def findKRotation(self, arr):
        l, r = 0, len(arr) - 1
        while l < r:
            m = (l + r) // 2
            if arr[m] > arr[r]: l = m + 1
            else: r = m
        return l


